XAS99 CROSS-ASSEMBLER   VERSION 3.4.0
     **** ****     > build.asm
0001               
0005               
0009               
0010               ; bank 0 source files
0011                   copy "./bank0/0-00-Header.asm"
     **** ****     > ./bank0/0-00-Header.asm
0001               ;  _____            _           _____           _   _
0002               ; |_   _|_   _ _ __| |__   ___ |  ___|___  _ __| |_| |__
0003               ;   | | | | | | '__| '_ \ / _ \| |_  / _ \| '__| __| '_ \
0004               ;   | | | |_| | |  | |_) | (_) |  _|| (_) | |  | |_| | | |
0005               ;   |_|  \__,_|_|  |_.__/ \___/|_|   \___/|_|   \__|_| |_|
0006               ; ################################################
0007               ; TurboForth
0008               ; (C) Mark Wills 2009-2012
0009               ; Written in TMS9900 machine code for the TI-99/4A
0010               ; May the Forth be with you.
0011               ; ################################################
0012               ;  ____              _       ___
0013               ; | __ )  __ _ _ __ | | __  / _ \
0014               ; |  _ \ / _` | '_ \| |/ / | | | |
0015               ; | |_) | (_| | | | |   <  | |_| |
0016               ; |____/ \__,_|_| |_|_|\_\  \___/
0017               ;
0018               ; This is bank 0 - the main bank, containing:
0019               ;    Forth dictionary
0020               ;    Any words written in Forth
0021               ;    Console routines (keyboard, scrolling, cursor etc)
0022               ;
0023               ;    Due to memory contraints, some dictionary entries are stub entries
0024               ;    containing only the dictionary entry and a call into bank 1 where the
0025               ;    main code resides. I have tried to keep routines that need to run quickly
0026               ;    (i.e. without the overhead of a bank-switch/branch and bank-switch/return
0027               ;    in this bank.
0028               
0029               ;  _    _                _
0030               ; | |  | |              | |
0031               ; | |__| | ___  __ _  __| | ___ _ __
0032               ; |  __  |/ _ \/ _` |/ _` |/ _ \ '__|
0033               ; | |  | |  __/ (_| | (_| |  __/ |
0034               ; |_|  |_|\___|\__,_|\__,_|\___|_|
0035               
0036                       aorg >6000                  ; cartridge rom
0037               
0038                   ; cartridge ROM header
0039               
0040 6000 AA               byte >aa                    ; standard header
0041 6001   0C             byte >0c                    ; version number
0042 6002 01               byte >01                    ; number of programs
0043 6003   00             byte >00                    ; not used
0044 6004 0000             data >0000                  ; pointer to power-up list
0045 6006 600C             data menu                   ; pointer to program list
0046 6008 0000             data 0                      ; pointer to DSRL list
0047 600A 0000             data 0                      ; pointer to subprogram list
0048               
0049 600C 6026     menu    data menu40                 ; pointer to next menu item
0050 600E 605A             data start80                ; code entry point
0051 6010 14               byte 20                     ; length of text
0052 6011   54             text 'TURBOFORTH 80 COLUMN'
     6012 5552     
     6014 424F     
     6016 464F     
     6018 5254     
     601A 4820     
     601C 3830     
     601E 2043     
     6020 4F4C     
     6022 554D     
     6024 4E       
0053                       even
0054 6026 0000     menu40  data 0                      ; no more menu entries
0055 6028 6050             data start40                ; code entry point (see 0-01-Startup.a99)
0056 602A 11               byte 17                     ; length of text
0057 602B   54     mtext   text 'TURBOFORTH V1.2.3 (c) 2016 Mark Wills'
     602C 5552     
     602E 424F     
     6030 464F     
     6032 5254     
     6034 4820     
     6036 5631     
     6038 2E32     
     603A 2E33     
     603C 2028     
     603E 6329     
     6040 2032     
     6042 3031     
     6044 3620     
     6046 4D61     
     6048 726B     
     604A 2057     
     604C 696C     
     604E 6C73     
0058                       even
0059               
0060               ; 40 column mode entry point
0061 6050 02E0  18 start40 lwpi wkspc
     6052 8300     
0062 6054 04E0  34         clr @sumode
     6056 A07A     
0063 6058 1009  14         jmp startB0                 ; defined in 0-01-Startup.a99
0064               
0065               ; 80 column mode entry point
0066 605A 02E0  18 start80 lwpi wkspc
     605C 8300     
0067 605E 0200  20         li r0,2
     6060 0002     
0068 6062 C800  38         mov r0,@sumode
     6064 A07A     
0069 6066 1002  14         jmp startB0                 ; defined in 0-01-Startup.a99
0070               
0071               ; codes for bank 0 and bank 1 - used by the interrupt handler to determine which
0072               ; bank to return to after processing an interrupt.
0073               ; Set by the VDP routines (see 0-22-VDP.a99)
0074               ; DO NOT MOVE THESE! Identical definitions are made in bank 1, and they MUST
0075               ; be at identical addresses!
0076 6068 6002     bank0    data >6002                 ; code to select bank 0
0077 606A 6000     bank1_   data >6000                 ; code to select bank 1
0078               
0079               
0080               ; General Equates
0081      8300     wkspc    equ  >8300                 ; workspace pointer
0082      0000     link     equ 0                      ; chain of links
0083      837C     gplst    equ >837c                  ; gpl status byte
0084      8375     keyin    equ >8375                  ; location of ascii key pressed (via KSCAN)
0085      009D     quitky   equ 157                    ; key code for cold reset (157=CTRL and =)
0086      834A     fac      equ >834a                  ; FAC
0087      83C4     ISR      equ >83c4                  ; address of isr hook
0088               
0089      0003     pc       equ 3                     ; friendly name for program counter register
0090      0004     stack    equ 4                     ; friendly name for data stack register
0091      0005     rstack   equ 5                     ; friendly name for return stack register
0092      000C     NEXT     equ 12                    ; friendly name for NEXT routine
0093               
0094      8000     immed    equ >8000                  ; flag for immediate words
                   < build.asm
0012                   copy "./bank0/0-01-Startup.asm"
     **** ****     > ./bank0/0-01-Startup.asm
0001               ;   _____ _              _
0002               ;  / ____| |            | |
0003               ; | (___ | |_  __ _ _ __| |_ _   _ _ __
0004               ;  \___ \| __|/ _` | '__| __| | | | '_ \
0005               ;  ____) | |_| (_| | |  | |_| |_| | |_) |
0006               ; |_____/ \__|\__,_|_|   \__|\__,_| .__/
0007               ;                                 | |
0008               ;                                 |_|
0009               ; STARTUP - general initialisation code for bank 0
0010               ; and a few high level Forth kernal words for starting
0011               ; the interpreter, cold starting, etc
0012               
0013               ; START
0014 606C 0300  22 startB0 limi 0                      ; no interrupts thank-you, we're British
     606E 0000     
0015               
0016 6070 04E0  34         clr @>6000                  ; we're now in bank 1
     6072 6000     
0017                       ; note, bank 1 has identical code at these addresses so we
0018                       ; can safely bank switch
0019 6074 0460  28         b @init                     ; init is defined in 1-15-Initialise.a99
     6076 7C32     
0020               
0021 6078 020C  20 afteri  li next ,_next              ; we'll use r12 as a pointer to NEXT
     607A 8326     
0022 607C 0203  20         li pc,cstart                ; setup Forth instruction pointer (R3)
     607E 60D2     
0023 6080 045C  20         b *r12                      ; call NEXT (start execution)
0024                       ; from this point we're actually running in forth
0025               
0026               
0027                   ;    pc = instruction pointer (R3)
0028                   ;    stack = data stack pointer (R4)
0029                   ;    rstack = return stack pointer (R5)
0030               
0031               ; space saving routines... these replace common phrases found in the source
0032               ; The following four routines save 2 bytes each time they are used
0033 6082 6084     lit0    data $+2                ; push 0 to stack
0034 6084 0644  14         dect stack
0035 6086 04D4  26         clr *stack
0036 6088 045C  20         b *next
0037               
0038 608A 8320     lit1    data docol,lit,1,exit   ; push 1 to stack
     608C 70B8     
     608E 0001     
     6090 832C     
0039 6092 8320     lit8    data docol,lit,8,exit   ; push 8 to stack
     6094 70B8     
     6096 0008     
     6098 832C     
0040               
0041 609A 609C     litm1   data $+2                ; push -1 to stack
0042 609C 0644  14         dect stack
0043 609E 0714  26         seto *stack
0044 60A0 045C  20         b *next
0045               
0046               ; another common phrase is COMPILE BRANCH
0047 60A2 8320     combra  data docol,compile,branch,exit
     60A4 7262     
     60A6 65D6     
     60A8 832C     
0048               
0049               ; COMPILE LIT COMMA
0050 60AA 8320     clc     data docol,compile,lit,comma,exit
     60AC 7262     
     60AE 70B8     
     60B0 70D2     
     60B2 832C     
0051               
0052               ; Alternative to TYPE. A typical phrase is LIT <ADDR> LIT <LEN> TYPE
0053               ; This routine allows the above phrase to be replaced with TOTERM <ADDR> <LEN>
0054               ; Saving 4 bytes each time it is used. Net saving ~80 bytes.
0055 60B4 8320     toterm  data docol,term1,type,exit
     60B6 60BC     
     60B8 6C96     
     60BA 832C     
0056 60BC 60BE     term1   data $+2
0057 60BE C055  26         mov *rstack,r1              ; get address of address of length byte
0058 60C0 C051  26         mov *r1,r1                  ; point to address byte
0059 60C2 D0B1  28         movb *r1+,r2                ; get length
0060 60C4 0982  32         srl r2,8                    ; move to low byte
0061 60C6 0644  14         dect stack                  ; create stack entry
0062 60C8 C501  30         mov r1,*stack               ; push address of text
0063 60CA 0644  14         dect stack                  ; create stack entry
0064 60CC C502  30         mov r2,*stack               ; push length
0065 60CE 05D5  26         inct *rstack
0066 60D0 045C  20         b *next
0067               
0068               
0069               ; COLD START
0070               ; This routine is called when the system starts for the first time.
0071 60D2 60D4     cstart  data bootup
0072 60D4 8320     bootup  data docol,synth            ; check if speech synth is fitted
     60D6 6100     
0073                       ; the graphics mode is loaded by the cart startup menus
0074 60D8 70B8             data lit,sumode,fetch,gmode ; set appropriate graphics mode
     60DA A07A     
     60DC 6822     
     60DE 794E     
0075 60E0 70B8             data lit,mtext,lit,37,type,cr    ; type title to screen
     60E2 602B     
     60E4 70B8     
     60E6 0025     
     60E8 6C96     
     60EA 6E8C     
0076 60EC 6E5C             data keyq,cboot             ; scan keyboard and call cboot
     60EE 6108     
0077 60F0 65E8             data zbrnch,skipld          ; skip bootloader if enter key was pressed
     60F2 60FE     
0078 60F4 608A             data lit1,load              ; boot from disk - load block 1
     60F6 7C10     
0079 60F8 70B8             data lit,doboot,store0      ; reset booting flag
     60FA A050     
     60FC 6884     
0080 60FE 7460     skipld  data ab0rt                  ; call QUIT.
0081 6100 6102     synth   data $+2                    ; check if speech synth is fitted
0082 6102 06A0  28         bl @bank1
     6104 8332     
0083 6106 66E6             data isspch                 ; see 1-05-speech.a99
0084               
0085               ; permit booting from DSKx where x is any ASCII character
0086               ; To boot from something other than DSK1 just hold down the appropriate key at
0087               ; boot-time.
0088 6108 610A     cboot   data $+2
0089 610A 06A0  28         bl @bank1
     610C 8332     
0090 610E 7F50             data _cboot                 ; defined in 1-15-Initialise.a99
0091               
0092               
0093               ; EXIT         --                            C,79
0094               ; Compiled within a colon definition such that when executed, that colon
0095               ; definition returns control to the definition that passed control to it by
0096               ; returning control to the return point on the top of the return stack.
0097               ; An error condition exists if the top of the return stack does not contain a
0098               ; valid return point.
0099               ; See: ;  "stack, return"  "9.3 Return Stack"
0100               ;
0101               ; Note: This word is the last word in the dictionary. Consequently it's link
0102               ; field has a value of 0. FIND uses this to determine if it has searched every
0103               ; word in the dictionary.
0104 6110 0000     exith   data 0,4
     6112 0004     
0105 6114 4558             text 'EXIT'
     6116 4954     
0106 6118 611A     exitt   data $+2
0107 611A 0460  24         b @exit+2
     611C 832E     
0108               
0109               
0110               ; QUIT         --                            79
0111               ; Clears the return stack, sets interpret state, accepts new input from the
0112               ; current input device, and begins text interpretation.  No message is
0113               ; displayed.
0114 611E 6110     quith   data exith,4
     6120 0004     
0115 6122 5155             text 'QUIT'
     6124 4954     
0116 6126 8320     quit    data docol
0117 6128 70B8     quitlp  data lit,>0500,lit,keydev,store ; set keyscan code
     612A 0500     
     612C 70B8     
     612E A024     
     6130 6844     
0118 6132 6154             data rrstack                    ; reset return stack
0119 6134 772E             data tib_,fetch,lit,80,expect   ; get some input
     6136 6822     
     6138 70B8     
     613A 0050     
     613C 69D4     
0120 613E 72FE             data interp                     ; call INTERPRET
0121 6140 73CA             data stkuf                      ; check for stack underflow
0122 6142 60B4             data toterm,oktxt               ; type OK
     6144 6150     
0123 6146 623E             data depth,dot,cr               ; display stack depth
     6148 782C     
     614A 6E8C     
0124 614C 65D6             data branch,quitlp              ; repeat endlessly
     614E 6128     
0125 6150 03       oktxt   byte 3  ; length of text
0126 6151   6F             text 'ok:'
     6152 6B3A     
0127                       even
0128 6154 6156     rrstack data $+2
0129 6156 0205  20         li rstack,retstk                ; reset return stack pointer
     6158 A28C     
0130 615A 045C  20         b *next
0131               
0132               
0133               ; COLD ( -- )
0134               ; performs a cold reset of the system
0135 615C 611E     coldh   data quith,4
     615E 0004     
0136 6160 434F             text 'COLD'
     6162 4C44     
0137 6164 6166             data $+2
0138 6166 1082  14 cold    jmp startB0                      ; restart the whole shebang
0139               
                   < build.asm
0013                   copy "./bank0/0-02-Stack.asm"
     **** ****     > ./bank0/0-02-Stack.asm
0001               ;   _____ _              _     __          __            _
0002               ;  / ____| |            | |    \ \        / /           | |
0003               ; | (___ | |_  __ _  ___| | __  \ \  /\  / /___  _ __ __| |___
0004               ;  \___ \| __|/ _` |/ __| |/ /   \ \/  \/ // _ \| '__/ _` / __|
0005               ;  ____) | |_| (_| | (__|   <     \  /\  /| (_) | | | (_| \__ \
0006               ; |_____/ \__|\__,_|\___|_|\_\     \/  \/  \___/|_|  \__,_|___/
0007               ; Core words pertaining to data and return stack manipulation
0008               
0009               
0010               ; DROP         16b --                        79
0011               ; 16b is removed from the stack.
0012 6168 615C     droph   data coldh,4                ; link to previous word and length of word
     616A 0004     
0013 616C 4452             text 'DROP'                 ; name of word
     616E 4F50     
0014 6170 838A     drop    data _drop                  ; code is in high-speed ram.
0015                                                   ; see 1-15-Initialise.a99
0016               
0017               
0018               ; SWAP         16b1 16b2 -- 16b2 16b1        79
0019               ; The top two stack entries are exchanged.
0020 6172 6168     swaph   data droph,4
     6174 0004     
0021 6176 5357             text 'SWAP'
     6178 4150     
0022 617A 835C     swap    data _swap                  ; code is in high-speed ram.
0023                                                   ; see 1-15-Initialise.a99
0024               
0025               
0026               ; DUP          16b -- 16b 16b                79             "dupe"
0027               ; Duplicate 16b.
0028 617C 6172     duph    data swaph,3
     617E 0003     
0029 6180 4455             text 'DUP '
     6182 5020     
0030 6184 8382     dup     data _dup                   ; code is in high-speed ram.
0031                                                   ; see 1-15-Initialise.a99
0032               
0033               
0034               ; ROT          16b1 16b2 16b3 -- 16b2 16b3 16b1  79         "rote"
0035               ; The top three stack entries are rotated, bringing the deepest to the top.
0036 6186 617C     roth    data duph,3
     6188 0003     
0037 618A 524F             text 'ROT '
     618C 5420     
0038 618E 6190     rot     data $+2
0039 6190 C1A4  34         mov @4(stack),r6            ; save x1
     6192 0004     
0040 6194 C924  54         mov @2(stack),@4(stack)     ; move x2 backwards on stack
     6196 0002     
     6198 0004     
0041 619A C914  46         mov *stack,@2(stack)        ; move x3 bacwards on stack
     619C 0002     
0042 619E C506  30         mov r6,*stack               ; put x1 on top of stack
0043 61A0 045C  20         b *next
0044               
0045               
0046               ; -ROT         16b1 16b2 16b3 -- 16b3 16b1 16b2
0047               ; The top three stack entries are rotated, sending the top item to the deepest
0048               ; poisition
0049 61A2 6186     nroth   data roth,4
     61A4 0004     
0050 61A6 2D52             text '-ROT'
     61A8 4F54     
0051 61AA 61AC     nrot    data $+2
0052 61AC C194  26         mov *stack,r6               ; save x3
0053 61AE C524  46         mov @2(stack),*stack        ; move x2 forwards on stack
     61B0 0002     
0054 61B2 C924  54         mov @4(stack),@2(stack)     ; move x1 forwards on stack
     61B4 0004     
     61B6 0002     
0055 61B8 C906  38         mov r6,@4(stack)            ; put x3 on bottom
     61BA 0004     
0056 61BC 045C  20         b *next
0057               
0058               
0059               ; OVER         16b1 16b2 -- 16b1 16b2 16b3   79
0060               ; 16b3 is a copy of 16b1.
0061 61BE 61A2     overh   data nroth,4
     61C0 0004     
0062 61C2 4F56             text 'OVER'
     61C4 4552     
0063 61C6 838E     over    data _over                  ; code is in high-speed ram.
0064                                                   ; see 1-15-Initialise.a99
0065               
0066               
0067               ; NIP          16b1 16b2 -- 16b2
0068               ; 16b1 is removed from the stack
0069 61C8 61BE     niph    data overh,3
     61CA 0003     
0070 61CC 4E49             text 'NIP '
     61CE 5020     
0071 61D0 61D2     nip     data $+2
0072 61D2 C534  42         mov *stack+,*stack          ; copy 16b2 and perform pop
0073 61D4 045C  20         b *next
0074               
0075               
0076               ; TUCK         16b1 16b2 -- 16b2 16b1 16b2
0077               ; places a copy of 16b2 at the third data stack position.
0078               ; 16b1 and 16b2 move upwards.
0079 61D6 61C8     tuckh   data niph,4
     61D8 0004     
0080 61DA 5455             text 'TUCK'
     61DC 434B     
0081 61DE 61E0     tuck    data $+2
0082 61E0 0644  14         dect stack
0083 61E2 C524  46         mov @2(stack),*stack
     61E4 0002     
0084 61E6 C924  54         mov @4(stack),@2(stack)
     61E8 0004     
     61EA 0002     
0085 61EC C914  46         mov *stack,@4(stack)
     61EE 0004     
0086 61F0 045C  20         b *next
0087               
0088               
0089               ; ?DUP         16b -- 16b 16b                79    "question-dupe"
0090               ; or: 0 -- 0. Duplicate 16b if it is non-zero.
0091 61F2 61D6     dup0h   data tuckh,4
     61F4 0004     
0092 61F6 3F44             text '?DUP'
     61F8 5550     
0093 61FA 61FC     qdup    data $+2
0094 61FC C514  38         mov *stack,*stack           ; set EQ bit in status register if TOS=0
0095 61FE 1303  14         jeq qdupx                   ; jump if TOS=0 and exit
0096 6200 0644  14         dect stack                  ; create stack entry
0097 6202 C524  46         mov @2(stack),*stack        ; copy tos
     6204 0002     
0098 6206 045C  20 qdupx   b *next
0099               
0100               
0101               ; PICK         +n -- 16b                     83
0102               ; 16b is a copy of the +nth stack value, not counting +n itself.
0103               ; {0..the number of elements on stack-1}
0104               ;    0 PICK is equivalent to DUP
0105               ;    1 PICK is equivalent to OVER
0106 6208 61F2     pickh   data dup0h,4
     620A 0004     
0107 620C 5049             text 'PICK'
     620E 434B     
0108 6210 6212     pick    data $+2
0109 6212 06A0  28         bl @bank1
     6214 8332     
0110 6216 78EA             data _pick
0111               
0112               
0113               ; >< ( xy -- yx )
0114               ; Swaps bytes in the top data stack cell. For example $1234 becomes $3412
0115 6218 6208     swpbh   data pickh,2
     621A 0002     
0116 621C 3E3C             text '><'
0117 621E 6220     swpb_   data $+2
0118 6220 06D4  26         swpb *stack                 ; swap bytes in TOS
0119 6222 045C  20         b *next
0120               
0121               
0122               ; ROLL         +n --                         83
0123               ; The +nth stack value, not counting +n itself is first removed and then
0124               ; transferred to the top of the stack, moving the remaining values into the
0125               ; vacated position.
0126               ; {0..the number of elements on the stack-1}
0127               ;    2 ROLL is equivalent to ROT
0128               ;    0 ROLL is a null operation
0129 6224 6218     rollh   data swpbh,4
     6226 0004     
0130 6228 524F             text 'ROLL'
     622A 4C4C     
0131 622C 622E     roll    data $+2
0132 622E 06A0  28         bl @bank1
     6230 8332     
0133 6232 78F8             data _roll
0134               
0135               
0136               ; DEPTH        -- +n                         79
0137               ; +n is the number of 16-bit values contained in the data stack before +n was
0138               ; placed on the stack.
0139 6234 6224     depthh  data rollh,5
     6236 0005     
0140 6238 4445             text 'DEPTH '
     623A 5054     
     623C 4820     
0141 623E 6240     depth   data $+2
0142 6240 06A0  28         bl @bank1
     6242 8332     
0143 6244 791A             data _depth
0144               
0145               
0146               ; .S ( -- )
0147               ; produce non-destructive stack dump to the screen.
0148 6246 6234     ndsh    data depthh,2
     6248 0002     
0149 624A 2E53             text '.S'
0150 624C 8320     dots    data docol,depth,zbrnch,dotst
     624E 623E     
     6250 65E8     
     6252 6270     
0151 6254 608A             data lit1,depth,sub1
     6256 623E     
     6258 62B4     
0152 625A 66E8             data do,dotst
     625C 6270     
0153 625E 678C     dots1   data   geti,sub1,pick,nts,type,space1
     6260 62B4     
     6262 6210     
     6264 788E     
     6266 6C96     
     6268 6D32     
0154 626A 609A             data   litm1
0155 626C 676A             data ploop,dots1
     626E 625E     
0156 6270 60B4     dotst   data toterm,dottxt
     6272 6276     
0157 6274 832C             data exit
0158 6276 05       dottxt  byte 5  ; length of text
0159 6277   3C             text '<TOP '
     6278 544F     
     627A 5020     
0160               
0161               
0162               ; RETURN STACK WORDS:
0163               
0164               ; >R           16b --                        C,79           "to-r"
0165               ; Transfers 16b to the return stack.
0166 627C 6246     rspshh  data ndsh,2
     627E 0002     
0167 6280 3E52             text '>R'
0168 6282 6284     rspush  data $+2
0169 6284 0645  14         dect rstack                 ; move return stack to the next position
0170 6286 C574  42         mov *stack+,*rstack         ; pop word on data stack to return stack
0171 6288 045C  20         b *next
0172               
0173               
0174               ; R@           -- 16b                        C,79        "r-fetch"
0175               ; 16b is a copy of the top of the return stack.
0176 628A 627C     rsch    data rspshh,2
     628C 0002     
0177 628E 5240             text 'R@'
0178 6290 6292     rsc     data $+2
0179 6292 0644  14         dect stack                  ; move forward on data stack
0180 6294 C515  38         mov *rstack,*stack          ; copy word from return stack to data stack
0181 6296 045C  20         b *next
0182               
0183               
0184               ; R>           -- 16b                        C,79         "r-from"
0185               ; 16b is removed from the return stack and transferred to the data stack.
0186 6298 628A     rspoph  data rsch,2
     629A 0002     
0187 629C 523E             text 'R>'
0188 629E 62A0     rspop   data $+2
0189 62A0 0644  14         dect stack                  ; move forward on data stack
0190 62A2 C535  42         mov *rstack+,*stack         ; pop top of return stack to data stack
0191 62A4 045C  20         b *next
0192               
                   < build.asm
0014                   copy "./bank0/0-03-Math.asm"
     **** ****     > ./bank0/0-03-Math.asm
0001               ;  __  __       _   _      __          __            _
0002               ; |  \/  |     | | | |     \ \        / /           | |
0003               ; | \  / | __ _| |_| |__    \ \  /\  / /___  _ __ __| |___
0004               ; | |\/| |/ _` | __| '_ \    \ \/  \/ // _ \| '__/ _` / __|
0005               ; | |  | | (_| | |_| | | |    \  /\  /| (_) | | | (_| \__ \
0006               ; |_|  |_|\__,_|\__|_| |_|     \/  \/  \___/|_|  \__,_|___/
0007               
0008               
0009               ;[ 1+           w1 -- w2                      79         "one-plus"
0010               ; w2 is the result of adding one to w1 according to the operations of +
0011 62A6 6298     plus1h  data rspoph,2
     62A8 0002     
0012 62AA 312B             text '1+'
0013 62AC 8396     plus1   data _plus1                 ; code is in high-speed ram.
0014                                                   ; see 1-15-Initialise.a99
0015               ;]
0016               
0017               ;[ 1-           w1 -- w2                      79        "one-minus"
0018               ; w2 is the result of subtracting one from w1 according to the operation of -
0019 62AE 62A6     sub1h   data plus1h,2
     62B0 0002     
0020 62B2 312D             text '1-'
0021 62B4 62B6     sub1    data $+2
0022 62B6 0614  26         dec *stack
0023 62B8 045C  20         b *next
0024               ;]
0025               
0026               ;[ 2+           w1 -- w2                      79         "two-plus"
0027               ; w2 is the result of adding two to w1 according to the operation of +
0028 62BA 62AE     plus2h  data sub1h,2
     62BC 0002     
0029 62BE 322B             text '2+'
0030 62C0 839A     plus2   data _plus2                 ; code is in high-speed ram.
0031                                                   ; see 1-15-Initialise.a99
0032               ;]
0033               
0034               ;[ CELL+        w1 -- w2+2
0035               ; adds two (the cell size) to top of stack
0036 62C2 62BA     cellph  data plus2h,5
     62C4 0005     
0037 62C6 4345             text 'CELL+ '
     62C8 4C4C     
     62CA 2B20     
0038 62CC 839A     cellp   data _plus2
0039               ;]
0040               
0041               ;[ CHAR+        w1 -- w2+2
0042               ; adds two (the cell size) to top of stack
0043 62CE 62C2     charph  data cellph,5
     62D0 0005     
0044 62D2 4348             text 'CHAR+ '
     62D4 4152     
     62D6 2B20     
0045 62D8 8396     charp   data _plus1
0046               ;]
0047               
0048               ;[ 2-           w1 -- w2                      79        "two-minus"
0049               ; w2 is the result of subtracting two from w1 according to the operation of -
0050 62DA 62CE     sub2h   data charph,2
     62DC 0002     
0051 62DE 322D             text '2-'
0052 62E0 839E     sub2    data _sub2                  ; code is in high-speed ram.
0053                                                   ; see 1-15-Initialise.a99
0054               ;]
0055               
0056               ;[ 2* ( x -- x<<1 )
0057               ; shifts the value on the stack left by one bit.
0058 62E2 62DA     mul2h   data sub2h,2
     62E4 0002     
0059 62E6 322A             text '2*'
0060 62E8 62EA     mul2    data $+2
0061 62EA A514  38 mul3    a *stack,*stack             ; :-)
0062 62EC 045C  20         b *next
0063               ;]
0064               
0065               ;[ CELLS ( x1 -- x1*2 )
0066               ; returns the memory size required to hold x1 cells
0067 62EE 62E2     cellsh  data mul2h,5
     62F0 0005     
0068 62F2 4345             text 'CELLS '
     62F4 4C4C     
     62F6 5320     
0069 62F8 62EA     cells   data mul3                   ; use the word 2* to do our work for us
0070               ;]
0071               
0072               ;[ 2/           n1 -- n2                      83       "two-divide"
0073               ; n2 is the result of arithmetically shifting n1 right one bit.
0074               ; The sign is included in the shift and remains unchanged.
0075 62FA 62EE     div2h   data cellsh,2
     62FC 0002     
0076 62FE 322F             text '2/'
0077 6300 6302     div2    data $+2
0078 6302 C214  26         mov *stack,r8               ; TOS in r8
0079 6304 0818  18         sra r8,1                    ; shift right
0080 6306 C508  30         mov r8,*stack               ; store on stack
0081 6308 045C  20         b *next
0082               ;]
0083               
0084               ;[ +            w1 w2 -- w3                   79             "plus"
0085               ; w3 is the arithmetic sum of w1 plus w2.
0086 630A 62FA     addh    data div2h,1
     630C 0001     
0087 630E 2B20             text '+ '
0088 6310 83A2     add     data _add                   ; code is in high-speed ram.
0089                                                   ; see 1-15-Initialise.a99
0090               ;]
0091               
0092               ;[ -            w1 w2 -- w3                   79            "minus"
0093               ; w3 is the result of subtracting w2 from w1.
0094 6312 630A     subh    data addh,1
     6314 0001     
0095 6316 2D20             text '- '
0096 6318 83A6     sub     data _sub                   ; code is in high-speed ram.
0097                                                   ; see 1-15-Initialise.a99
0098               ;]
0099               
0100               ;[ *            w1 w2 -- w3                   79            "times"
0101               ; w3 is the least-significant 16 bits of the arithmetic product of w1 times w2.
0102 631A 6312     mulh    data subh,1
     631C 0001     
0103 631E 2A20             text '* '
0104 6320 83AA     mul     data _mul                   ; code is in high-speed ram.
0105                                                   ; see 1-15-Initialise.a99
0106               ;]
0107               
0108               ;[ */           n1 n2 n3 -- n4                83     "times-divide"
0109               ; n1 is first multiplied by n2 producing an intermediate 32-bit result.
0110               ; n4 is the floor of the quotient of the intermediate 32-bit result divided by
0111               ; the divisor n3.
0112               ; The product of n1 times n2 is maintained as an intermediate 32-bit result for
0113               ; greater precision than the otherwise equivalent sequence: n1 n2 * n3 / .
0114               ; An error condition results if the divisor is zero or if the quotient falls
0115               ; outside of the range {-32,768..32,767}.
0116 6322 631A     sslash  data mulh,2
     6324 0002     
0117 6326 2A2F             text '*/'
0118 6328 8320             data docol
0119 632A 6378             data ssm                    ; */MOD
0120 632C 61D0             data nip                    ; discard remainder
0121 632E 832C             data exit
0122 6330 045C  20         b *next
0123               ;]
0124               
0125               ;[ UM*          u1 u2 -- ud                   83        "u-m-times"
0126               ; ud is the unsigned-double product of u1 times u2.
0127               ; All values and arithmetic are unsigned.
0128               ; high word of ud to top of stack
0129 6332 6322     umsh    data sslash,3
     6334 0003     
0130 6336 554D             text 'UM* '
     6338 2A20     
0131 633A 633C             data $+2
0132 633C C014  26         mov *stack,r0               ; get u2
0133 633E C064  34         mov @2(stack),r1            ; get r1
     6340 0002     
0134 6342 3840  58         mpy r0,r1                   ; perform unsigned multiply
0135 6344 C501  30         mov r1,*stack               ; push high word
0136 6346 C902  38         mov r2,@2(stack)            ; push low word
     6348 0002     
0137 634A 045C  20         b *next
0138               ;]
0139               
0140               ;[ /MOD         n1 n2 -- n3 n4                83       "divide-mod"
0141               ; n3 is the remainder and n4 the floor of the quotient of n1 divided by the
0142               ; divisor n2.
0143               ; n3 has the same sign as n2 or is zero.
0144               ; An error condition results if the divisor is zero or if the quotient falls
0145               ; outside of the range {-32,768..32,767}.
0146 634C 6332     smodh   data umsh,4
     634E 0004     
0147 6350 2F4D             text '/MOD'
     6352 4F44     
0148 6354 6356     smod    data $+2
0149 6356 C014  26         mov *stack,r0               ; get n2 (divisor)
0150 6358 0701  14         seto r1                     ; dividend is 32-bit, assume negative
0151 635A C0A4  34         mov @2(stack),r2            ; get n1 (dividend)
     635C 0002     
0152 635E 1101  14         jlt smod1                   ; if negative then skip
0153 6360 04C1  14         clr r1                      ; otherwise it's positive. clear upper word
0154 6362 06A0  32 smod1   bl @sidiv                   ; do a signed division
     6364 6414     
0155 6366 C501  30         mov r1,*stack               ; push quotient
0156 6368 C902  38         mov r2,@2(stack)            ; push remainder
     636A 0002     
0157 636C 045C  20         b *next
0158               ;]
0159               
0160               ;[ */MOD        n1 n2 n3 -- n4 n5             83 "times-divide-mod"
0161               ; n1 is first multiplied by n2 producing an intermediate 32-bit result.
0162               ; n4 is the remainder and n5 is the floor of the quotient of the intermediate
0163               ; 32-bit result divided by the divisor n3.  A 32-bit intermediate product is
0164               ; used as for */ .  n4 has the same sign as n3 or is zero.  An error condition
0165               ; results if the divisor is zero or if the quotient falls outside of the range
0166               ; {-32,768..32,767}.
0167 636E 634C     ssmh    data smodh,5
     6370 0005     
0168 6372 2A2F             text '*/MOD '
     6374 4D4F     
     6376 4420     
0169 6378 637A     ssm     data $+2
0170 637A C024  34         mov @2(stack),r0            ; get n2
     637C 0002     
0171 637E C064  34         mov @4(stack),r1            ; get n1
     6380 0004     
0172 6382 06A0  32         bl @simul                   ; signed multiply
     6384 644E     
0173 6386 C034  30         mov *stack+,r0              ; pop n3 to r0 (divisor)
0174 6388 06A0  32         bl @sidiv                   ; signed divide
     638A 6414     
0175 638C C501  30         mov r1,*stack               ; push quotient
0176 638E C902  38         mov r2,@2(stack)            ; push remainder
     6390 0002     
0177 6392 045C  20         b *next
0178               ;]
0179               
0180               ;[ UM/MOD       ud u1 -- u2 u3                83   "u-m-divide-mod"
0181               ; u2 is the remainder and u3 is the floor of the quotient after dividing ud by
0182               ; the divisor u1.  All values and arithmetic are unsigned.  An error condition
0183               ; results if the divisor is zero or if the quotient lies outside the range
0184 6394 636E     umodh   data ssmh,6
     6396 0006     
0185 6398 554D             text 'UM/MOD'
     639A 2F4D     
     639C 4F44     
0186 639E 63A0     usmod   data $+2
0187 63A0 C034  30         mov *stack+,r0              ; pop u1 to r0 (divisor)
0188 63A2 C054  26         mov *stack,r1               ; high word of ud to r1
0189 63A4 C0A4  34         mov @2(stack),r2            ; low word of ud to r2
     63A6 0002     
0190 63A8 3C40 128         div r0,r1                   ; perform unsigned division
0191 63AA C501  30         mov r1,*stack               ; push quotient
0192 63AC C902  38         mov r2,@2(stack)            ; push remainder
     63AE 0002     
0193 63B0 045C  20         b *next
0194               ;]
0195               
0196               ;[ /            n1 n2 -- n3                   83           "divide"
0197               ; n3 is the floor of the quotient of n1 divided by the divisor n2.
0198               ; An error condition results if the divisor is zero or if the quotient falls
0199               ; outside of the range {-32,768..32,767}.
0200 63B2 6394     sdivh   data umodh,1
     63B4 0001     
0201 63B6 2F20             text '/ '
0202 63B8 8320     sdiv    data docol,smod,nip,exit
     63BA 6354     
     63BC 61D0     
     63BE 832C     
0203               ;]
0204               
0205               ;[ MOD          n1 n2 -- n3                   83
0206               ; n3 is the remainder after dividing n1 by the divisor n2.
0207               ; n3 has the same sign as n2 or is zero.
0208               ; An error condition results if the divisor is zero or if the quotient falls
0209               ; outside of the range {-32,768..32,767}.
0210 63C0 63B2     modh    data sdivh,3
     63C2 0003     
0211 63C4 4D4F             text 'MOD '
     63C6 4420     
0212 63C8 8320     mod     data docol,smod,drop,exit
     63CA 6354     
     63CC 6170     
     63CE 832C     
0213               ;]
0214               
0215               ;[ NEGATE       n1 -- n2                      79
0216               ; n2 is the two's complement of n1, i.e, the difference of zero less n1.
0217 63D0 63C0     negh    data modh,6
     63D2 0006     
0218 63D4 4E45             text 'NEGATE'
     63D6 4741     
     63D8 5445     
0219 63DA 63DC     neg_    data $+2
0220 63DC 0514  26 neg2    neg *stack                  ; negate the word on TOS
0221 63DE 045C  20         b *next
0222               ;]
0223               
0224               ;[ ABS          n -- u                        79         "absolute"
0225               ; u is the absolute value of n.  If n is -32,768 then u is the same value.
0226               ; STATUS: TESTED OK 13 APR 2009
0227 63E0 63D0     absh    data negh,3
     63E2 0003     
0228 63E4 4142             text 'ABS '
     63E6 5320     
0229 63E8 63EA     abs_    data $+2
0230 63EA 0754  30         abs *stack                  ; compute abs of the word on TOS
0231 63EC 045C  20         b *next
0232               ;]
0233               
0234               ;[ MIN          n1 n2 -- n3                   79              "min"
0235               ; n3 is the lesser of n1 and n2 according to the operation of < .
0236 63EE 63E0     minh    data absh,3
     63F0 0003     
0237 63F2 4D49             text 'MIN '
     63F4 4E20     
0238 63F6 63F8     min     data $+2
0239 63F8 8534  38         c *stack+,*stack            ; compare n2 and n1 (and pop n2)
0240 63FA 1101  14         jlt keepn2                  ; keep n2 if it's lower
0241 63FC 045C  20         b *next                     ; otherwise keep n1
0242 63FE C524  46 keepn2  mov @-2(stack),*stack       ; keep n2
     6400 FFFE     
0243 6402 045C  20         b *next
0244               ;]
0245               
0246               ;[ MAX          n1 n2 -- n3                   79              "max"
0247               ; n3 is the greater of n1 and n2 according to the operation of > .
0248 6404 63EE     maxh    data minh,3
     6406 0003     
0249 6408 4D41             text 'MAX '
     640A 5820     
0250 640C 640E     max     data $+2
0251 640E 8534  38         c *stack+,*stack            ; compare n2 and n1 (and pop n2)
0252 6410 15F6  14         jgt keepn2                  ; keep n2 if it's higher
0253 6412 045C  20         b *next                     ; otherwise keep n1
0254               ;]
0255               
0256               
0257               ; Floored math subroutines:
0258               
0259               ;[ Signed divide using Floored Integer Division
0260               ; Divides a 32 bit value in r1 and r2 by a 16 bit value in r0
0261               ; Inputs:
0262               ;   r0=divisor
0263               ;   r1=upper 16 bits dividend
0264               ;   r2=lower 16 bits dividend
0265               ; Outputs:
0266               ;   r1=16-bit quotient
0267               ;   r2=16-bit remainder
0268               sidiv   ; set flags to reflect signs of operands, and force operands positive...
0269 6414 04CE  14         clr r14                     ; sign of divisor (-1=negative sign)
0270 6416 04CF  14         clr r15                     ; sign of dividend (-1=negative sign)
0271 6418 0740  18         abs r0                      ; force divisor positive
0272 641A 1501  14         jgt sdiv1                   ; if positive then jump
0273 641C 070E  14         seto r14                    ; flag negative divisor
0274 641E C041  18 sdiv1   mov r1,r1                   ; check sign of dividend
0275 6420 1304  14         jeq sdiv2
0276 6422 1503  14         jgt sdiv2                   ; if positive then jump
0277 6424 0541  14         inv r1                      ; otherwise negate the dividend
0278 6426 0502  14         neg r2                      ;
0279 6428 070F  14         seto r15                    ; and flag dividend as negative
0280                   ; perform division...
0281 642A C202  18 sdiv2   mov r2,r8                   ; store a copy of the dividend
0282 642C 3C40 128         div r0,r1                   ; perform the division. r1=quot, r2=rem
0283                   ; check if floor should be applied... (signs different and remainder<>0)
0284 642E 83CE  18 sdiv3   c r14,r15                   ; compare signs of dividend and divisor
0285 6430 1309  14         jeq signdo                  ; if same then jump
0286 6432 0501  14         neg r1                      ; negate quotient
0287 6434 C082  18         mov r2,r2                   ; check remainder
0288 6436 1306  14         jeq signdo                  ; jump if no remainder
0289                   ; apply floor rule...
0290 6438 0601  14 floor   dec r1                      ; floor the quotient
0291                       ; compute remainder remainder=(divisor*quotient)-dividend
0292 643A C241  18         mov r1,r9                   ; get floored quotient
0293 643C 0749  18         abs r9                      ; force positive
0294 643E 3A40  58         mpy r0,r9                   ; divisor*quotient (result in r10)
0295 6440 6288  18         s r8,r10                    ; subtract dividend
0296 6442 C08A  18         mov r10,r2                  ; overwrite original remainder
0297                   ; apply sign of divisor to remainder
0298 6444 C38E  18 signdo  mov r14,r14                 ; check sign of divisor
0299 6446 1101  14         jlt floor1                  ; if negative then jump
     **** ****     > RT
0001 6448 045B  20        b * r11
                   < 0-03-Math.asm
0301 644A 0502  14 floor1  neg r2                      ; remainder takes sign of divisor
     **** ****     > RT
0001 644C 045B  20        b * r11
                   < 0-03-Math.asm
0303               ;]
0304               
0305               ;[ Signed Multiply
0306               ; multiplies two signed 16-bit values, n1 & n2, giving a signed 32-bit product
0307               ; Inputs:
0308               ;   r0=n1
0309               ;   r1=n2
0310               ; Outputs:
0311               ;   r1=product, upper 16-bits
0312               ;   r2=product, lower 16-bits
0313                   ; check if signs of inputs are different
0314 644E C180  18 simul   mov r0,r6                   ; copy n1
0315 6450 2981  16         xor r1,r6                   ; check signs (r6=negative if signs differ)
0316 6452 0740  18         abs r0                      ; force positive
0317 6454 0741  18         abs r1                      ; force positive
0318 6456 3840  58         mpy r0,r1                   ; n1*n2 (product in r1 & r2)
0319                   ; if input signs were different then negate results
0320 6458 C186  18         mov r6,r6                   ; check signs flag
0321 645A 1504  14         jgt simul1                  ; if same then leave positive
0322 645C 0541  14         inv r1                      ; invert high word
0323 645E 0502  14         neg r2                      ; negate low word
0324 6460 1701  14         jnc simul1                  ; skip if no carry
0325 6462 0581  14         inc r1                      ; add 1 to high word to compensate for carry
     **** ****     > RT
0326               simul1  .rt
0001 6464 045B  20        b * r11
                   < 0-03-Math.asm
0327               ;]
                   < build.asm
0015                   copy "./bank0/0-04-Comparison.asm"
     **** ****     > ./bank0/0-04-Comparison.asm
0001               ;   _____                                  _
0002               ;  / ____|                                (_)
0003               ; | |      ___  _ __ ___  _ __   __ _ _ __ _ ___  ___  _ __
0004               ; | |     / _ \| '_ ` _ \| '_ \ / _` | '__| / __|/ _ \| '_ \
0005               ; | |____| (_) | | | | | | |_) | (_| | |  | \__ \ (_) | | | |
0006               ;  \_____|\___/|_| |_| |_| .__/ \__,_|_|  |_|___/\___/|_| |_|
0007               ;                        | |
0008               ;                        |_|
0009               ; __          __            _
0010               ; \ \        / /           | |
0011               ;  \ \  /\  / /___  _ __ __| |___
0012               ;   \ \/  \/ // _ \| '__/ _` / __|
0013               ;    \  /\  /| (_) | | | (_| \__ \
0014               ;     \/  \/  \___/|_|  \__,_|___/
0015               
0016               ;[ =            n1 n2 -- flag                 83           "equals"
0017               ; flag is true if n1 is equal to n2.
0018 6466 6404     eqh     data maxh,1
     6468 0001     
0019 646A 3D20             text '= '
0020 646C 646E     eq      data $+2
0021 646E 8534  38         c *stack+,*stack            ; compare and pop n2
0022 6470 1369  14         jeq sTrue                   ; set true if n1=n2
0023 6472 106A  14         jmp sFalse                  ; else set result to false
0024               ;]
0025               
0026               ;[ >            n1 n2 -- flag                 83     "greater-than"
0027               ; flag is true if n1 is greater than n2.
0028               ;    -32768 32767 > must return false.
0029               ;    -32768 0 > must return false.
0030 6474 6466     gth     data eqh,1
     6476 0001     
0031 6478 3E20             text '> '
0032 647A 647C     gt      data $+2
0033 647C 8534  38         c *stack+,*stack            ; compare n2 to n1. pop n2
0034 647E 1162  14         jlt sTrue                   ; set true if n2<n1
0035 6480 1063  14         jmp sFalse                  ; else set result to false
0036               ;]
0037               
0038               ;[ <            n1 n2 -- flag                 83        "less-than"
0039               ; flag is true if n1 is less than n2.
0040               ;    -32678 32767 < must return true.
0041               ;    -32768 0 < must return true.
0042 6482 6474     lth     data gth,1
     6484 0001     
0043 6486 3C20             text '< '
0044 6488 648A     lt      data $+2
0045 648A 8534  38         c *stack+,*stack            ; compare n2 to n1. pop n2
0046 648C 155B  14         jgt sTrue                   ; set true if n2>n1
0047 648E 105C  14         jmp sFalse                  ; else set result to false
0048               ;]
0049               
0050               ;[ >=           n1 n2 -- flag
0051               ; returns true if n1>=n2
0052 6490 6482     gteh    data lth,2
     6492 0002     
0053 6494 3E3D             text '>='
0054 6496 6498     gte     data $+2
0055 6498 8534  38         c *stack+,*stack            ; compare n2 to n2. pop n2
0056 649A 1154  14         jlt sTrue                   ; set true if n2<n1
0057 649C 1353  14         jeq sTrue                   ; or if n2=n1
0058 649E 1054  14         jmp sFalse                  ; else set result to false
0059               ;]
0060               
0061               ;[ <= (SIGNED)  ( n1 n2 -- flag )
0062               ; returns true if n1<=n2
0063 64A0 6490     lteh    data gteh,2
     64A2 0002     
0064 64A4 3C3D             text '<='
0065 64A6 64A8     lte     data $+2
0066 64A8 8534  38         c *stack+,*stack            ; compare n2 to n1. pop n2
0067 64AA 154C  14         jgt sTrue                   ; set true if n2>n1
0068 64AC 134B  14         jeq sTrue                   ; or if n2=n1
0069 64AE 104C  14         jmp sFalse                  ; else set result to false
0070               ;]
0071               
0072               ;[ <>  ( n1 n2 -- flag )
0073               ; returns true if n1!=n2
0074 64B0 64A0     neqhh   data lteh,2
     64B2 0002     
0075 64B4 3C3E             text '<>'
0076 64B6 64B8     neq     data $+2
0077 64B8 8534  38         c *stack+,*stack            ; compare n2 to n1. pop n2
0078 64BA 1644  14         jne sTrue                   ; set true if n2<>n1
0079 64BC 1045  14         jmp sFalse                  ; else set result to false
0080               ;]
0081               
0082               ;[ 0=           w -- flag                     83      "zero-equals"
0083               ; flag is true if w is zero.
0084 64BE 64B0     eqzh    data neqhh,2
     64C0 0002     
0085 64C2 303D             text '0='
0086 64C4 64C6     eqz     data $+2
0087 64C6 C514  38         mov *stack,*stack           ; compare to tos to 0
0088 64C8 133D  14         jeq sTrue                   ; set true if tos=0
0089 64CA 103E  14         jmp sFalse                  ; else set result to false
0090               ;]
0091               
0092               ;[ 0<>  ( x -- flag )
0093               ; returns true if x!=0
0094 64CC 64BE     neqzh   data eqzh,3
     64CE 0003     
0095 64D0 303C             text '0<> '
     64D2 3E20     
0096 64D4 64D6     neqz    data $+2
0097 64D6 C514  38         mov *stack,*stack           ; compare tos to 0
0098 64D8 1635  14         jne sTrue                   ; set true if tos<>0
0099 64DA 1036  14         jmp sFalse                  ; else set result to false
0100               ;]
0101               
0102               ;[ 0<           n -- flag                     83        "zero-less"
0103               ; flag is true if n is less than zero (negative).
0104 64DC 64CC     ltzh    data neqzh,2
     64DE 0002     
0105 64E0 303C             text '0<'
0106 64E2 64E4     ltz     data $+2
0107 64E4 C514  38         mov *stack,*stack           ; compare tos to 0
0108 64E6 112E  14         jlt sTrue                   ; set true if tos<0
0109 64E8 102F  14         jmp sFalse                  ; else set result to false
0110               ;]
0111               
0112               ;[ 0>           n -- flag                     83     "zero-greater"
0113               ; flag is true if n is greater than zero.
0114 64EA 64DC     gtzh    data ltzh,2
     64EC 0002     
0115 64EE 303E             text '0>'
0116 64F0 64F2     gtz     data $+2
0117 64F2 C514  38         mov *stack,*stack           ; compare tos to 0
0118 64F4 1527  14         jgt sTrue                   ; set true if tos>0
0119 64F6 1028  14         jmp sFalse                  ; else set result to false
0120               ;]
0121               
0122               ;[ U<           u1 u2 -- flag                 83      "u-less-than"
0123               ; flag is true if u1 is less than u2.
0124 64F8 64EA     ulessh  data gtzh,2
     64FA 0002     
0125 64FC 553C             text 'U<'
0126 64FE 6500     uless   data $+2
0127 6500 8534  38         c *stack+,*stack            ; compare u2 to u1. pop u2
0128 6502 1B20  14         jh sTrue                    ; set true if u2>u1
0129 6504 1021  14         jmp sFalse                  ; else set false
0130               ;]
0131               
0132               ;[ WITHIN ( n low high -- true|false )
0133               ; returns true if n is within low and high+1
0134 6506 64F8     withh   data ulessh,6
     6508 0006     
0135 650A 5749             text 'WITHIN'
     650C 5448     
     650E 494E     
0136 6510 8320     within  data docol,over,sub,rspush,sub,rspop,uless,exit
     6512 61C6     
     6514 6318     
     6516 6282     
     6518 6318     
     651A 629E     
     651C 64FE     
     651E 832C     
0137               ;]
0138               
0139               ;[ 0<=  ( x -- flag )
0140               ; returns true if x<=0
0141 6520 6506     ltezh   data withh,3
     6522 0003     
0142 6524 303C             text '0<= '
     6526 3D20     
0143 6528 652A     ltez    data $+2
0144 652A C514  38         mov *stack,*stack           ; compare tos to 0
0145 652C 110B  14         jlt sTrue                   ; set true if tos<0
0146 652E 130A  14         jeq sTrue                   ; or if tos=0
0147 6530 100B  14         jmp sFalse                  ; else set result to false
0148               ;]
0149               
0150               ;[ 0>=  ( x -- flag )
0151               ; returns true if x>=0
0152 6532 6520     gtezh   data ltezh,3
     6534 0003     
0153 6536 303E             text '0>= '
     6538 3D20     
0154 653A 653C     gtez    data $+2
0155 653C C514  38         mov *stack,*stack           ; compare tos to 0
0156 653E 1502  14         jgt sTrue                   ; set true if tos>0
0157 6540 1301  14         jeq sTrue                   ; or if tos=0
0158 6542 1002  14         jmp sFalse                  ; else set result to false
0159               ;]
0160               
0161               ; The following routines are common to all the routines above.
0162               ; The first routine returns a true result, the second routine a false result.
0163               ; Each routine has two entry points, depending on whether 1 or 2 parameters
0164               ; should be removed from the stack.
0165               
0166                   ; called when the result of the comparison is true
0167 6544 0714  26 sTrue   seto *stack                 ; set value to -1 (true)
0168 6546 045C  20         b *next
0169               
0170                   ; called when the result of the comparison is false
0171 6548 04D4  26 sFalse  clr *stack                  ; set result to 0 (false)
0172 654A 045C  20         b *next
                   < build.asm
0016                   copy "./bank0/0-05-FlowControl.asm"
     **** ****     > ./bank0/0-05-FlowControl.asm
0001               ;  ______ _                  _____             _             _
0002               ; |  ____| |                / ____|           | |           | |
0003               ; | |__  | | _____      __ | |      ___  _ __ | |_ _ __ ___ | |
0004               ; |  __| | |/ _ \ \ /\ / / | |     / _ \| '_ \| __| '__/ _ \| |
0005               ; | |    | | (_) \ V  V /  | |____| (_) | | | | |_| | | (_) | |
0006               ; |_|    |_|\___/ \_/\_/    \_____|\___/|_| |_|\__|_|  \___/|_|
0007               ; Flow control words
0008               
0009               ; MARK & AHEAD: Utilities for flow control words
0010               ;   : MARK  ( -- addr) HERE 0 , ;
0011 654C 8320     mark    data docol
0012 654E 77FE             data ghere,lit0,comma
     6550 6082     
     6552 70D2     
0013 6554 832C             data exit
0014               
0015               ;   : AHEAD  ( -- addr ) POSTPONE BRANCH  MARK ;  IMMEDIATE
0016 6556 8320     ahead   data docol
0017 6558 7262             data compile,branch,mark
     655A 65D6     
     655C 654C     
0018 655E 832C             data exit
0019               
0020               
0021               ;[ FOR ( loop_count -- )
0022               ; Implements FOR...NEXT looping as in COUNT FOR .. .. NEXT
0023               ; I is available for retrieving the index.
0024               ; : FOR ( start--) COMPILE LIT 0 , COMPILE SWAP [COMPILE] DO ; IMMEDIATE
0025 6560 6532     forh    data gtezh,immed+3
     6562 8003     
0026 6564 464F             text 'FOR '
     6566 5220     
0027 6568 8320     for     data docol
0028 656A 7262             data compile,lit0
     656C 6082     
0029 656E 7262             data compile,swap,do1
     6570 617A     
     6572 66CC     
0030 6574 832C             data exit
0031               ;]
0032               
0033               ;[ NEXT
0034               ; : NEXT ( --) COMPILE LIT -1 , [COMPILE] +LOOP ; IMMEDIATE
0035 6576 6560     nexth   data forh,immed+4
     6578 8004     
0036 657A 4E45             text 'NEXT'
     657C 5854     
0037 657E 8320     fnext1  data docol
0038 6580 609A             data litm1,clc,ploop1
     6582 60AA     
     6584 674C     
0039 6586 832C             data exit
0040               ;]
0041               
0042               ;   : IF ( -- addr )    POSTPONE ?BRANCH  MARK ;  IMMEDIATE
0043               ;[ IF           flag --                       C,I,79
0044               ;                       -- sys   (compiling)
0045               ; Used in the form:
0046               ;        flag IF ... ELSE ... THEN
0047               ; or     flag IF ... THEN
0048               ; If flag is true, the words following IF are executed and the words following
0049               ; ELSE until just after THEN are skipped.  The ELSE part is optional.
0050               ; If flag is false, the words from IF through ELSE , or from IF through THEN
0051               ; (when no ELSE is used), are skipped.
0052               ; sys is balanced with its corresponding ELSE or THEN .
0053               ; See:  "9.9 Control Structures"
0054 6588 6576     ifh     data nexth,immed+2
     658A 8002     
0055 658C 4946             text 'IF'
0056 658E 8320     if      data docol
0057 6590 70B8             data lit,ifcnt,refup
     6592 A07E     
     6594 67AC     
0058 6596 7262             data compile,zbrnch,mark
     6598 65E8     
     659A 654C     
0059 659C 832C             data exit
0060               ;]
0061               
0062               ;   : THEN  HERE SWAP ! ;  IMMEDIATE
0063               ;[ THEN         --                            C,I,79
0064               ;             sys --   (compiling)
0065               ; Used in the form:
0066               ;       flag IF ... ELSE ... THEN
0067               ; or    flag IF ... THEN
0068               ; THEN is the point where execution continues after ELSE , or IF when no ELSE
0069               ; is present.
0070               ; sys is balanced with its corresponding IF or ELSE .  See:  IF  ELSE
0071 659E 6588     thenh   data ifh,immed+4
     65A0 8004     
0072 65A2 5448             text 'THEN'
     65A4 454E     
0073 65A6 8320     then    data docol
0074 65A8 70B8             data lit,ifcnt,refdn
     65AA A07E     
     65AC 67B4     
0075 65AE 77FE             data ghere,swap,store
     65B0 617A     
     65B2 6844     
0076 65B4 832C             data exit
0077               ;]
0078               
0079               ;   : ELSE  POSTPONE AHEAD  SWAP  POSTPONE THEN ;  IMMEDIATE
0080               ;[ ELSE         --                            C,I,79
0081               ;            sys1 -- sys2   (compiling)
0082               ; Used in the form:
0083               ;       flag IF ... ELSE ... THEN
0084               ; ELSE executes after the true part following IF .  ELSE forces execution to
0085               ; continue at just after THEN .  sys1 is balanced with its corresponding IF .
0086               ; sys2 is balanced with its corresponding THEN .  See:  IF  THEN
0087 65B6 659E     elseh   data thenh,immed+4
     65B8 8004     
0088 65BA 454C             text 'ELSE'
     65BC 5345     
0089 65BE 8320     else    data docol
0090 65C0 6556             data ahead,swap,ghere,swap,store
     65C2 617A     
     65C4 77FE     
     65C6 617A     
     65C8 6844     
0091 65CA 832C             data exit
0092               ;]
0093               
0094               ;[ BRANCH ( -- )
0095               ; unconditional branch: e.g: BRANCH 4 will branch forwards four words.
0096               ; Negative offsets supported.
0097 65CC 65B6     brnchh  data elseh,6
     65CE 0006     
0098 65D0 4252             text 'BRANCH'
     65D2 414E     
     65D4 4348     
0099 65D6 65D8     branch  data $+2
0100                       ; at entry, R3 is pointing at the branch address...
0101 65D8 C0D3  26         mov *pc,pc              ; get the in-line address and move to the
0102 65DA 045C  20         b *next                 ; instruction pointer
0103               
0104               ;]
0105               
0106               ;[ 0BRANCH ( flag -- )
0107               ; Branch if data on the stack is 0. e.g: 0BRANCH 4 will branch forwards 4
0108               ; bytes if the value on the data stack is 0
0109 65DC 65CC     zbrchh  data brnchh,7
     65DE 0007     
0110 65E0 3042             text '0BRANCH '
     65E2 5241     
     65E4 4E43     
     65E6 4820     
0111 65E8 83B4     zbrnch  data _zbrnch            ; code is in high-speed ram.
0112                                               ; see 1-15-Initialise.a99
0113               ;]
0114               
0115               ;[ CASE..OF..ENDCASE ( -- )
0116               ; Part of CASE..OF..ENDCASE
0117               ; CASE
0118 65EA 65DC     caseh   data zbrchh,immed+4
     65EC 8004     
0119 65EE 4341             text 'CASE'
     65F0 5345     
0120 65F2 8320     case    data docol
0121 65F4 70B8             data lit,cascnt,refup   ; reference count
     65F6 A084     
     65F8 67AC     
0122 65FA 6082             data lit0
0123 65FC 832C             data exit
0124               
0125               ; OF
0126 65FE 65EA     ofh     data caseh,immed+2
     6600 8002     
0127 6602 4F46             text 'OF'
0128 6604 8320     of      data docol
0129 6606 70B8             data lit,ofcnt,refup
     6608 A086     
     660A 67AC     
0130 660C 7262             data compile,over,compile,eq,if,compile,drop
     660E 61C6     
     6610 7262     
     6612 646C     
     6614 658E     
     6616 7262     
     6618 6170     
0131 661A 832C             data exit
0132               
0133               ; ENDOF
0134 661C 65FE     endofh  data ofh,immed+5
     661E 8005     
0135 6620 454E             text 'ENDOF '
     6622 444F     
     6624 4620     
0136 6626 8320     endof   data docol
0137 6628 70B8             data lit,ofcnt,refdn,else
     662A A086     
     662C 67B4     
     662E 65BE     
0138 6630 832C             data exit
0139               
0140               ; ENDCASE
0141 6632 661C     endcah  data endofh,immed+7
     6634 8007     
0142 6636 454E             text 'ENDCASE '
     6638 4443     
     663A 4153     
     663C 4520     
0143 663E 8320     endcas  data docol
0144 6640 70B8             data lit,cascnt,refdn   ; reference count
     6642 A084     
     6644 67B4     
0145 6646 7262             data compile,drop,qdup,zbrnch,$+8,then,branch,$-10
     6648 6170     
     664A 61FA     
     664C 65E8     
     664E 6656     
     6650 65A6     
     6652 65D6     
     6654 664A     
0146 6656 832C             data exit
0147               ;]
0148               
0149               ;   : BEGIN  HERE ; IMMEDIATE \ synonym purely for readability
0150               ;[ BEGIN        --                            C,I,79
0151               ;                 -- sys   (compiling)
0152               ; Used in the form:
0153               ;       BEGIN ... flag UNTIL
0154               ; or    BEGIN ... flag WHILE ... REPEAT
0155               ; BEGIN marks the start of a word sequence for repetitive execution.
0156               ; A BEGIN-UNTIL loop will be repeated until flag is true.
0157               ; A BEGIN-WHILE-REPEAT will be repeated until flag is false.
0158               ; The words after UNTIL or REPEAT will be executed when either loop is finished.
0159               ; sys is balanced with its corresponding UNTIL or WHILE .
0160               ; See:  "9.9 Control Structures"
0161 6658 6632     beginh  data endcah,immed+5
     665A 8005     
0162 665C 4245             text 'BEGIN '
     665E 4749     
     6660 4E20     
0163 6662 8320     begin   data docol
0164 6664 70B8             data lit,begcnt,refup
     6666 A088     
     6668 67AC     
0165 666A 77FE             data ghere
0166 666C 832C             data exit
0167               ;]
0168               
0169               ;   : UNTIL  POSTPONE ?BRANCH , ;  IMMEDIATE
0170               ;[ UNTIL ( address -- )
0171 666E 6658     untilh  data beginh,immed+5
     6670 8005     
0172 6672 554E             text 'UNTIL '
     6674 5449     
     6676 4C20     
0173 6678 8320     until   data docol
0174 667A 70B8             data lit,begcnt,refdn
     667C A088     
     667E 67B4     
0175 6680 7262             data compile,zbrnch,comma
     6682 65E8     
     6684 70D2     
0176 6686 832C             data exit
0177               ;]
0178               
0179               ;   : AGAIN  POSTPONE BRANCH , ; IMMEDIATE
0180               ;[ AGAIN ( address -- )
0181 6688 666E     againh  data untilh,immed+5
     668A 8005     
0182 668C 4147             text 'AGAIN '
     668E 4149     
     6690 4E20     
0183 6692 8320     again   data docol
0184 6694 70B8             data lit,begcnt,refdn
     6696 A088     
     6698 67B4     
0185 669A 7262             data compile,branch,comma
     669C 65D6     
     669E 70D2     
0186 66A0 832C             data exit
0187               ;]
0188               
0189               ;   : WHILE  POSTPONE IF  SWAP ; IMMEDIATE
0190               ;[ WHILE        flag --                       C,I,79
0191               ;                  sys1 -- sys2   (compiling)
0192               ; Used in the form:
0193               ;       BEGIN ... flag WHILE ... REPEAT
0194               ; Selects conditional execution based on flag.  When flag is true, execution
0195               ; continues to just after the WHILE through to the REPEAT which then continues
0196               ; execution back to just after the BEGIN.
0197               ; When flag is false, execution continues to just after the REPEAT, exiting the
0198               ; control structure.
0199               ; sys1 is balanced with its corresponding BEGIN.
0200               ; sys2 is balanced with its corresponding REPEAT.  See:  BEGIN
0201 66A2 6688     whileh  data againh,immed+5
     66A4 8005     
0202 66A6 5748             text 'WHILE '
     66A8 494C     
     66AA 4520     
0203 66AC 8320     while   data docol
0204 66AE 658E             data if,swap
     66B0 617A     
0205 66B2 832C             data exit
0206               ;]
0207               
0208               ;   : REPEAT  POSTPONE AGAIN  POSTPONE THEN ; IMMEDIATE
0209               ;[ REPEAT       --                            C,I,79
0210               ;             sys --   (compiling)
0211               ; Used in the form:
0212               ;       BEGIN ... flag WHILE ... REPEAT
0213               ; At execution time, REPEAT continues execution to just after the corresponding
0214               ; BEGIN.
0215               ; sys is balanced with its corresponding WHILE.  See:  BEGIN
0216 66B4 66A2     repeth  data whileh,immed+6
     66B6 8006     
0217 66B8 5245             text 'REPEAT'
     66BA 5045     
     66BC 4154     
0218 66BE 8320     repeat  data docol
0219 66C0 6692             data again,then
     66C2 65A6     
0220 66C4 832C             data exit
0221               ;]
0222               
0223               ;[ DO           w1 w2 --                      C,I,83
0224               ;                        -- sys   (compiling)
0225               ; Used in the form:
0226               ;       DO ... LOOP
0227               ; or    DO ... +LOOP
0228               ; Begins a loop which terminates based on control parameters.
0229               ; The loop index begins at w2, and terminates based on the limit w1.
0230               ; See LOOP and +LOOP for details on how the loop is terminated.
0231               ; The loop is always executed at least once.
0232               ; For example: w DUP DO ... LOOP executes 65,536 times.
0233               ; sys is balanced with its corresponding LOOP or +LOOP .
0234               ; See:  "9.9 Control Structures"
0235               ; note: DO is immediate and compiles a reference to (DO)
0236               ;
0237               ; Loop frame format:
0238               ;  0 = current loop index   <----- RSTACK points to this value
0239               ; +2 = loop limit
0240               ; +4 = loop exit address
0241               ; To drop a loop frame, add 6 to RSTACK
0242               ;
0243               ; In words, for A B DO ... LOOP
0244               ; (DO) puts three things on to the return stack
0245               ; 1. the address of the word after LOOP - where execution continues when
0246               ; the loop executes
0247               ; 2. A + >8000  (A with its sign bit 'permuted')
0248               ; 3. B minus the value computed at step 2 <-- top of return stack
0249               ;
0250               ; LOOP and +LOOP add 1 or whatever to the value at 3.
0251               ; If the overflow flag is set, drop two elements from the return stack,
0252               ; pop the final value from R (the address at 1. above)
0253               ; into I and execute next.
0254               ;
0255               ; I becomes:
0256               ; 4.  Move the value at 2. above to the data stack
0257               ; 5.  Add the value at 3. above to the data stack
0258               ;
0259 66C6 66B4     do1h    data repeth,immed+2
     66C8 8002     
0260 66CA 444F             text 'DO'
0261 66CC 8320     do1     data docol
0262 66CE 70B8             data lit,docnt,refup    ; increase reference counters
     66D0 A080     
     66D2 67AC     
0263 66D4 7262             data compile,do,ghere,lit0,comma ; compile (do) here 0 ,
     66D6 66E8     
     66D8 77FE     
     66DA 6082     
     66DC 70D2     
0264 66DE 832C             data exit
0265               
0266 66E0 66C6     doh     data do1h,4
     66E2 0004     
0267 66E4 2844             text '(DO)'
     66E6 4F29     
0268 66E8 66EA     do      data $+2
0269 66EA C034  30         mov *stack+,r0          ; pop initial index
0270 66EC C074  30         mov *stack+,r1          ; pop loop termination value
0271 66EE 0221  22         ai r1,>8000             ; flip sign bit
     66F0 8000     
0272 66F2 6001  18         s r1,r0                 ; calculate initial index
0273 66F4 0645  14         dect rstack             ; new return stack entry
0274 66F6 C573  42         mov *pc+,*rstack        ; loop exit address to return stack
0275 66F8 0645  14         dect rstack             ; new return stack entry
0276 66FA C541  30         mov r1,*rstack          ; loop limit to return stack
0277 66FC 0645  14         dect rstack             ; new return stack entry
0278 66FE C540  30         mov r0,*rstack          ; loop index to return stack
0279 6700 045C  20         b *next
0280               ;]
0281               
0282               ;[ LOOP         --                            C,I,83
0283               ;             sys --   (compiling)
0284               ; Increments the DO-LOOP index by one.  If the new index was incremented across
0285               ; the boundary between limit-1 and limit the loop is terminated and loop control
0286               ; parameters are discarded.  When the loop is not terminated, execution
0287               ; continues to just after the corresponding DO.
0288               ; sys is balanced with its corresponding DO .  See:  DO
0289               ; note: LOOP is immediate and compiles a reference to (LOOP)
0290 6702 66E0     loop1h  data doh,immed+4
     6704 8004     
0291 6706 4C4F             text 'LOOP'
     6708 4F50     
0292 670A 8320     loop1   data docol
0293 670C 70B8             data lit,docnt,refdn    ; reduce DO/LOOP reference counters
     670E A080     
     6710 67B4     
0294 6712 6184             data dup,compile,loop
     6714 7262     
     6716 6730     
0295 6718 77FE     loop2   data ghere,plus2,swap,store,plus2,comma
     671A 62C0     
     671C 617A     
     671E 6844     
     6720 62C0     
     6722 70D2     
0296 6724 832C             data exit
0297               
0298 6726 6702     looph   data loop1h,6
     6728 0006     
0299 672A 284C             text '(LOOP)'
     672C 4F4F     
     672E 5029     
0300 6730 6732     loop    data $+2
0301 6732 0595  26         inc *rstack             ; increment loop count
0302 6734 1904  14 loopchk jno lagain              ; if no overflow then loop again
0303 6736 0225  22 loopx   ai rstack,6             ; otherwise pop loop frame
     6738 0006     
0304 673A 05C3  14         inct pc                 ; move past (LOOP)'s in-line parameter
0305 673C 045C  20         b *next
0306 673E C0D3  26 lagain  mov *pc,pc              ; reload loop address
0307 6740 045C  20         b *next
0308               ;]
0309               
0310               ;[ +LOOP        n --                          C,I,83    "plus-loop"
0311               ;               sys --   (compiling)
0312               ; n is added to the loop index.  If the new index was incremented across the
0313               ; boundary between limit-1 and limit then the loop is terminated and loop
0314               ; control parameters are discarded.  When the loop is not terminated, execution
0315               ; continues to just after the corresponding DO.
0316               ; sys is balanced with its corresponding DO.  See:  DO
0317               ; note: +LOOP is immediate and compiles a reference to (+LOOP)
0318 6742 6726     plooh1  data looph,immed+5
     6744 8005     
0319 6746 2B4C             text '+LOOP '
     6748 4F4F     
     674A 5020     
0320 674C 8320     ploop1  data docol
0321 674E 70B8             data lit,docnt,refdn
     6750 A080     
     6752 67B4     
0322 6754 6184             data dup,compile,ploop,branch,loop2   ; compile (+LOOP) then as (LOOP)
     6756 7262     
     6758 676A     
     675A 65D6     
     675C 6718     
0323               
0324 675E 6742     plooph  data plooh1,7
     6760 0007     
0325 6762 282B             text '(+LOOP) '
     6764 4C4F     
     6766 4F50     
     6768 2920     
0326 676A 676C     ploop   data $+2
0327 676C A574  42         a *stack+,*rstack       ; pop increment and add to index on return stack
0328 676E 10E2  14         jmp loopchk
0329               ;]
0330               
0331               ;[ LEAVE        --                            C,I,83
0332               ;                 --   (compiling)
0333               ; Transfers execution to just beyond the next LOOP or +LOOP .
0334               ; The loop is terminated and loop control parameters are discarded.
0335               ; May only be used in the form:
0336               ;       DO ... LEAVE ... LOOP
0337               ; or    DO ... LEAVE ... +LOOP
0338               ; LEAVE may appear within other control structures which are nested within the
0339               ; do-loop structure.  More than one LEAVE may appear within a do-loop.
0340               ; See:  "9.3 Return Stack"
0341               ; Note: LEAVE *must* appear within an IF ... THEN block for correct operation.
0342 6770 675E     leaveh  data plooph,5
     6772 0005     
0343 6774 4C45             text 'LEAVE '
     6776 4156     
     6778 4520     
0344 677A 677C     leave   data $+2
0345 677C C0E5  34         mov @4(rstack),pc       ; load pc with exit address
     677E 0004     
0346 6780 0225  22         ai rstack,6             ; pop loop frame from return stack
     6782 0006     
0347 6784 045C  20         b *next
0348               ;]
0349               
0350               ;[ I            -- w                          C,79
0351               ; w is a copy of the loop index.  May only be used in the
0352               ; form:
0353               ;       DO ... I ... LOOP
0354               ; or    DO ... I ... +LOOP
0355               ; or    FOR .. I ... NEXT
0356 6786 6770     getih   data leaveh,1
     6788 0001     
0357 678A 4920             text 'I '
0358 678C 678E     geti    data $+2
0359 678E 0644  14         dect stack              ; new data stack entry
0360 6790 C525  46         mov @2(rstack),*stack   ; place index on data stack
     6792 0002     
0361 6794 A515  38         a *rstack,*stack        ; adjust
0362 6796 045C  20         b *next
0363               ;]
0364               
0365               ;[ J            -- w                          C,79
0366               ; w is a copy of the index of the next outer loop.
0367               ; May only be used within a nested DO-LOOP or DO-+LOOP in the form, for example:
0368               ; DO ... DO ... J ... LOOP ... +LOOP
0369               ; Also active in nested FOR...NEXT loops.
0370 6798 6786     getjh   data getih,1
     679A 0001     
0371 679C 4A20             text 'J '
0372 679E 67A0     getj    data $+2
0373 67A0 0644  14         dect stack              ; new data stack entry
0374 67A2 C525  46         mov @8(rstack),*stack   ; place outer loop index on data stack
     67A4 0008     
0375 67A6 A525  46         a @6(rstack),*stack     ; adjust
     67A8 0006     
0376 67AA 045C  20         b *next
0377               ;]
0378               
0379               ;[ utility routines for reference counting
0380 67AC 67AE     refup   data $+2
0381 67AE C034  30         mov *stack+,r0          ; pop address of reference counter
0382 67B0 0590  26         inc *r0                 ; increase reference counter
0383 67B2 045C  20         b *next
0384               
0385 67B4 67B6     refdn   data $+2
0386 67B6 C034  30         mov *stack+,r0          ; pop address of reference of counter
0387 67B8 0610  26         dec *r0                 ; decrease reference counter
0388 67BA 045C  20         b *next
0389               ;]
                   < build.asm
0017                   copy "./bank0/0-06-Logical.asm"
     **** ****     > ./bank0/0-06-Logical.asm
0001               ;  _                  _            _  __          __            _
0002               ; | |                (_)          | | \ \        / /           | |
0003               ; | |      ___   __ _ _  ___  __ _| |  \ \  /\  / /___  _ __ __| |___
0004               ; | |     / _ \ / _` | |/ __|/ _` | |   \ \/  \/ // _ \| '__/ _` / __|
0005               ; | |____| (_) | (_| | | (__| (_| | |    \  /\  /| (_) | | | (_| \__ \
0006               ; |______|\___/ \__, |_|\___|\__,_|_|     \/  \/  \___/|_|  \__,_|___/
0007               ;                __/ |
0008               ;               |___/
0009               ;
0010               ;[ AND          16b1 16b2 -- 16b3             79
0011               ; 16b3 is the bit-by-bit logical 'and' of 16b1 with 16b2.
0012 67BC 6798     andh    data getjh,3
     67BE 0003     
0013 67C0 414E             text 'AND '
     67C2 4420     
0014 67C4 67C6     and     data $+2
0015 67C6 0554  26         inv *stack                  ; invert 16b2 for SZC instruction
0016                                                   ; (see ED/AS manual, page 190)
0017 67C8 4534  42         szc *stack+,*stack          ; perform AND function and pop 16b2
0018 67CA 045C  20         b *next
0019               ;]
0020               
0021               ;[ OR           16b1 16b2 -- 16b3             79
0022               ; 16b3 is the bit-by-bit inclusive-or of 16b1 with 16b2.
0023 67CC 67BC     orh     data andh,2
     67CE 0002     
0024 67D0 4F52             text 'OR'
0025 67D2 67D4     or_     data $+2
0026 67D4 E534  42         soc *stack+,*stack          ; or 16b2 and 16b1. pop 16b2
0027 67D6 045C  20         b *next
0028               ;]
0029               
0030               ;[ XOR          16b1 16b2 -- 16b3             79             "x-or"
0031               ; 16b3 is the bit-by-bit exclusive-or of 16b1 with 16b2.
0032 67D8 67CC     xorh    data orh,3
     67DA 0003     
0033 67DC 584F             text 'XOR '
     67DE 5220     
0034 67E0 67E2     xor_    data $+2
0035 67E2 C234  30         mov *stack+,r8              ; pop 16b2 in r8
0036 67E4 2A14  28         xor *stack,r8               ; xor 16b1 with 16b2. result in r8
0037 67E6 C508  30         mov r8,*stack               ; result to TOS
0038                       ; (what a total shitter that I can't do a simple XOR *STACK+,*STACK )
0039 67E8 045C  20         b *next
0040               ;]
0041               
0042               ;[ NOT          16b1 -- 16b2                  83
0043               ; 16b2 is the one's complement of 16b1.
0044 67EA 67D8     invh    data xorh,3
     67EC 0003     
0045 67EE 4E4F             text 'NOT '
     67F0 5420     
0046 67F2 67F4     inv_    data $+2
0047 67F4 0554  26         inv *stack                  ; invert the word on TOS
0048 67F6 045C  20         b *next
0049               ;]
0050               
0051               ;[ << (bitwise) ( x count -- x )
0052               ; left shift x count bits (arithmetic shift)
0053 67F8 67EA     lsfth   data invh,2
     67FA 0002     
0054 67FC 3C3C             text '<<'
0055 67FE 6800     lsft    data $+2
0056 6800 C034  30         mov *stack+,r0              ; pop shift count into r0
0057 6802 C214  26         mov *stack,r8               ; x
0058 6804 0A08  56         sla r8,r0                   ; shift x by r0 bits
0059 6806 C508  30         mov r8,*stack               ; result back onto stack
0060 6808 045C  20         b *next
0061               ;]
0062               
0063               ;[ >> ( x count -- x )
0064               ; right shift x count bits (logical shift)
0065 680A 67F8     rsfth   data lsfth,2
     680C 0002     
0066 680E 3E3E             text '>>'
0067 6810 6812     rsft    data $+2
0068 6812 C034  30         mov *stack+,r0              ; pop shift count into r0
0069 6814 C214  26         mov *stack,r8               ; x
0070 6816 0908  56         srl r8,r0                   ; shift x by r0 bits
0071 6818 C508  30         mov r8,*stack               ; result back onto stack
0072 681A 045C  20         b *next
0073               ;]
                   < build.asm
0018                   copy "./bank0/0-07-Memory.asm"
     **** ****     > ./bank0/0-07-Memory.asm
0001               ;  __  __
0002               ; |  \/  |                                     /\
0003               ; | \  / | ___ _ __ ___   ___  _ __ _   _     /  \   ___  ___  ___ ___ ___
0004               ; | |\/| |/ _ \ '_ ` _ \ / _ \| '__| | | |   / /\ \ / __|/ __|/ _ | __/ __|
0005               ; | |  | |  __/ | | | | | (_) | |  | |_| |  / ____ \ (__| (__|  __|__ \__ \
0006               ; |_|  |_|\___|_| |_| |_|\___/|_|   \__, | /_/    \_\___|\___|\___|___/___/
0007               ; Memory access words                __/ |
0008               ;                                   |___/
0009               
0010      9C02     grmwa    equ >9c02                  ; GROM Write Address Register
0011      9802     grmra    equ >9802                  ; GROM Read Address Register
0012      9800     grmrd    equ >9800                  ; GROM Read Data Register
0013      9C00     grmwd    equ >9c00                  ; GROM Write Data Register
0014               
0015               ;[ @            addr -- 16b                   79            "fetch"
0016               ; 16b is the value at addr.
0017 681C 680A     fetchh  data rsfth,1
     681E 0001     
0018 6820 4020             text '@ '
0019 6822 6824     fetch   data $+2
0020 6824 C214  26         mov *stack,r8               ; get address
0021 6826 C518  38         mov *r8,*stack              ; peek address and put on data stack
0022 6828 045C  20         b *next
0023               ;]
0024               
0025               ;[ @++  ( addr -- addr+2 value )
0026               ; fetches the cell at memory address "address" then increments address
0027               ; and leaves it on the stack
0028 682A 681C     faddph  data fetchh,3
     682C 0003     
0029 682E 402B             text '@++'
     6830 2B       
0030 6832 6834     ftchpp  data $+2
0031 6834 C214  26         mov *stack,r8               ; get addr
0032 6836 05D4  26         inct *stack                 ; advance addr to get addr+2
0033 6838 0644  14         dect stack                  ; new stack entry
0034 683A C518  38         mov *r8,*stack              ; peek address and value put on  data stack
0035 683C 045C  20         b *next
0036               ;]
0037               
0038               ;[ !            16b addr --                   79            "store"
0039               ; 16b is stored at addr.
0040 683E 682A     storeh  data faddph,1
     6840 0001     
0041 6842 2120             text '! '
0042 6844 6846     store   data $+2
0043 6846 C234  30         mov *stack+,r8              ; pop addr
0044 6848 C634  42         mov *stack+,*r8             ; pop 16b and write to addr
0045 684A 045C  20         b *next
0046               ;]
0047               
0048               ;[ +!           w1 addr --                    79       "plus-store"
0049               ; w1 is added to the w value at addr using the convention for + .
0050               ; This sum replaces the original value at addr.
0051 684C 683E     staddh  data storeh,2
     684E 0002     
0052 6850 2B21             text '+!'
0053 6852 6854     stadd   data $+2
0054 6854 C234  30         mov *stack+,r8              ; pop addr
0055 6856 A634  42         a *stack+,*r8               ; pop w1 and add to value at addr
0056 6858 045C  20         b *next
0057               ;]
0058               
0059               ;[ C@           addr -- 8b                    79          "c-fetch"
0060               ; 8b is the contents of the byte at addr.
0061 685A 684C     chrfh   data staddh,2
     685C 0002     
0062 685E 4340             text 'C@'
0063 6860 6862     chrftc  data $+2
0064 6862 C214  26         mov *stack,r8               ; address in r8
0065 6864 D218  26         movb *r8,r8                 ; peek address and store in msb of r8
0066 6866 0988  40         srl r8,8                    ; move to low byte
0067 6868 C508  30         mov r8,*stack               ; move msb of r8 onto data stack
0068 686A 045C  20         b *next
0069               ;]
0070               
0071               ;[ C!           16b addr --                   79          "c-store"
0072               ; The least-significant 8 bits of 16b are stored into the byte at addr.
0073 686C 685A     stbh    data chrfh,2
     686E 0002     
0074 6870 4321             text 'C!'
0075 6872 6874     stb     data $+2
0076 6874 C234  30         mov *stack+,r8              ; pop addr
0077 6876 C1F4  30         mov *stack+,r7              ; pop 16b
0078 6878 06C7  14         swpb r7                     ; rotate LOW BYTE into MSB
0079 687A D607  30         movb r7,*r8                 ; move the byte into the address in r8
0080 687C 045C  20         b *next
0081               ;]
0082               
0083               ;[ 0! ( addr -- )
0084               ; store 0 at addr
0085 687E 686C     stor0h  data stbh,2
     6880 0002     
0086 6882 3021             text '0!'
0087 6884 6886     store0  data $+2
0088 6886 C234  30         mov *stack+,r8              ; pop address
0089 6888 04D8  26         clr *r8                     ; zero it
0090 688A 045C  20 stor0x  b *next
0091               ;]
0092               
0093               ;[ CHARS ( x1 -- x1 )
0094               ; return the memory size required to hold x2 chars (bytes)
0095               ; note: since this word does nothing, it is immediate, to avoid a run-time
0096               ; speed penalty
0097 688C 687E     charsh  data stor0h,immed+5
     688E 8005     
0098 6890 4348             text 'CHARS '
     6892 4152     
     6894 5320     
0099 6896 688A     chars   data stor0x     ; do nothing, and use the exit in 0! to do it!
0100                                       ; (saves 2 bytes)
0101               ;]
0102               
0103               ;[ V@ ( address -- value )
0104               ; read vdp address and return BYTE as 16 bit right justified cell
0105 6898 688C     vdpfh   data charsh,2
     689A 0002     
0106 689C 5640             text 'V@'
0107 689E 68A0     vdpftc  data $+2
0108 68A0 C014  26         mov *stack,r0               ; vdp address from data stack to r0
0109 68A2 06A0  32         bl @vsbr                    ; execute VDP single byte read routine
     68A4 7F64     
0110 68A6 0981  40         srl r1,8                    ; value move to low byte
0111 68A8 C501  30         mov r1,*stack               ; place it on the stack
0112 68AA 045C  20         b *next
0113               ;]
0114               
0115               ;[ V! ( value addr -- )
0116               ; store BYTE value (as 16 bit right justified cell) at VDP address
0117 68AC 6898     vdpwh   data vdpfh,2
     68AE 0002     
0118 68B0 5621             text 'V!'
0119 68B2 68B4     vdpstr  data $+2
0120 68B4 C034  30         mov *stack+,r0              ; pop addr
0121 68B6 C074  30         mov *stack+,r1              ; pop value
0122 68B8 06C1  14         swpb r1                     ; get lsb of value into msb
0123 68BA 06A0  32         bl @vsbw                    ; write to vdp
     68BC 7F9E     
0124 68BE 045C  20         b *next
0125               ;]
0126               
0127               ;[ VDP Write Word ( address value -- )
0128 68C0 68AC     vdpwwh  data vdpwh,3
     68C2 0003     
0129 68C4 5632             text 'V2! '
     68C6 2120     
0130 68C8 8320             data docol,swap,vdpww,drop,exit
     68CA 617A     
     68CC 7D50     
     68CE 6170     
     68D0 832C     
0131               ;]
0132               
0133               ;[ VDP Read Word ( vdp_address -- word_value)
0134 68D2 68C0     vdprwh  data vdpwwh,3
     68D4 0003     
0135               ;       DUP V@ >< SWAP 1+ V@ OR ;
0136 68D6 5632             text 'V2@ '
     68D8 4020     
0137 68DA 8320     vdprw   data docol,dup,vdpftc,swpb_,swap,plus1,vdpftc,or_,exit
     68DC 6184     
     68DE 689E     
     68E0 621E     
     68E2 617A     
     68E4 62AC     
     68E6 689E     
     68E8 67D2     
     68EA 832C     
0138               ;]
0139               
0140               ;[ VDP Write To Register ( value register -- )
0141 68EC 68D2     vwtrfh  data vdprwh,4
     68EE 0004     
0142 68F0 5657             text 'VWTR'
     68F2 5452     
0143 68F4 68F6     vwtrf   data $+2
0144 68F6 06A0  28         bl @bank1
     68F8 8332     
0145 68FA 6676             data _vwtrf                 ; see 1-04-Memory.a99
0146               ;]
0147               
0148               ;[ VMBR ( vdp_address cpu_address byte_count -- )
0149 68FC 68EC     vmbrh   data vwtrfh,4
     68FE 0004     
0150 6900 564D             text 'VMBR'
     6902 4252     
0151 6904 6906     fvmbr   data $+2
0152 6906 0206  20         li r6,vmbr                  ; address of vdp routine to call
     6908 7F86     
0153 690A 1007  14         jmp vdpm
0154               ;]
0155               
0156               ;[ VMBW ( vdp_address cpu_address byte_count -- )
0157 690C 68FC     vmbwh   data vmbrh,4
     690E 0004     
0158 6910 564D             text 'VMBW'
     6912 4257     
0159 6914 6916     fvmbw   data $+2
0160 6916 0206  20         li r6,vmbw                  ; address of vdp routine to call
     6918 7FC6     
0161                       ; fall down to vdpm routine below...
0162               ;]
0163               
0164               ;[ utility routine used by VMBR & VMBW above
0165               vdpm
0166 691A C0B4  30         mov *stack+,r2              ; pop byte count
0167 691C C074  30         mov *stack+,r1              ; pop cpu address
0168 691E C034  30         mov *stack+,r0              ; pop vdp address
0169 6920 C082  18         mov r2,r2                   ; check for zero byte count
0170 6922 1301  14         jeq vdpx                    ; if zero then just exit
0171 6924 0696  24         bl *r6                      ; execute appropriate routine
0172 6926 045C  20 vdpx    b *next
0173               ;]
0174               
0175               ;[ ; >MAP ( bank address -- )
0176               ; If a SAMS card is present, maps memory bank "bank" to address "address"
0177 6928 690C     samsh   data vmbwh,4
     692A 0004     
0178 692C 3E4D             text '>MAP'
     692E 4150     
0179 6930 6932     sams_   data $+2
0180 6932 06A0  28         bl @bank1
     6934 8332     
0181 6936 664C             data _sams                  ; implemented in 1-04-Memory.a99
0182               ;]
0183               
0184               ;[ HFREE ( -- free_bytes )
0185               ; returns the number of free bytes in upper 24k RAM
0186 6938 6928     hfreeh  data samsh,5
     693A 0005     
0187 693C 4846             text 'HFREE '
     693E 5245     
     6940 4520     
0188 6942 8320     hfree   data docol,lit,>ffff,ffaih,fetch,sub,plus1,exit
     6944 70B8     
     6946 FFFF     
     6948 7740     
     694A 6822     
     694C 6318     
     694E 62AC     
     6950 832C     
0189               ;]
0190               
0191               ;[ LFREE ( -- free_bytes )
0192               ; returns the number of free bytes in lower 8k RAM
0193 6952 6938     lfreeh  data hfreeh,5
     6954 0005     
0194 6956 4C46             text 'LFREE '
     6958 5245     
     695A 4520     
0195 695C 8320     lfree   data docol,lit
     695E 70B8     
0196 6960 4000     bit1    data >4000                  ; note: also used by VSBW to save 2 bytes
0197                                                   ; yes! memory is THAT tight!
0198 6962 7756             data ffaml,fetch,sub,exit
     6964 6822     
     6966 6318     
     6968 832C     
0199               ;]
0200               
0201               ;[ FILL         addr u 8b --                  83
0202               ; u bytes of memory beginning at addr are set to 8b.
0203               ; No action is taken if u is zero.
0204 696A 6952     fillh   data lfreeh,4
     696C 0004     
0205 696E 4649             text 'FILL'
     6970 4C4C     
0206 6972 6974     fill    data $+2
0207 6974 06A0  28         bl @bank1
     6976 8332     
0208 6978 65FC             data _fill                  ; implemented in 1-04-Memory.a99
0209               ;]
0210               
0211               ;[ CMOVE        addr1 addr2 u --              83           "c-move"
0212               ; Move u bytes beginning at address addr1 to addr2.
0213               ; The byte at addr1 is moved first, proceeding toward high memory.
0214               ; If u is zero nothing is moved.
0215 697A 696A     cmoveh  data fillh,5
     697C 0005     
0216 697E 434D             text 'CMOVE '
     6980 4F56     
     6982 4520     
0217 6984 6986     cmove   data $+2
0218 6986 06A0  28         bl @bank1
     6988 8332     
0219 698A 660E             data _cmove                 ; implemented in 1-04-Memory.a99
0220               ;]
0221               
0222               ;[ CMOVE>       addr1 addr2 u --              83        "c-move-up"
0223               ; Move the u bytes at address addr1 to addr2.
0224               ; The move begins by moving the byte at (addr1 plus u minus 1) to
0225               ; (addr2 plus u minus 1) and proceeds to successively lower addresses for u
0226               ; bytes.
0227               ; If u is zero nothing is moved. Useful for sliding a string towards higher
0228               ; addresses.
0229 698C 697A     cmovfh  data cmoveh,6
     698E 0006     
0230 6990 434D             text 'CMOVE>'
     6992 4F56     
     6994 453E     
0231 6996 6998     cmovf   data $+2
0232 6998 06A0  28         bl @bank1
     699A 8332     
0233 699C 661E             data _cmovf                 ; implemented in 1-04-Memory.a99
0234               ;]
0235               
0236               ;[ MEM ( -- )
0237               ; Displays the number of free bytes in low memory, high memory, and the total
0238               ; number of free bytes to the screen.
0239 699E 698C     freeh   data cmovfh,3
     69A0 0003     
0240 69A2 4D45             text 'MEM '
     69A4 4D20     
0241 69A6 8320             data docol
0242 69A8 6942             data hfree,lfree,dup2,udot,udot,add,udot,exit
     69AA 695C     
     69AC 75E0     
     69AE 781C     
     69B0 781C     
     69B2 6310     
     69B4 781C     
     69B6 832C     
0243               ;]
0244               
0245               ;[ COPYW (source destination count -- )
0246               ; copy WORDS from source to destination for 'count' words
0247               ; no action taken if count=0
0248 69B8 699E     copywh  data freeh,5
     69BA 0005     
0249 69BC 434F             text 'COPYW '
     69BE 5059     
     69C0 5720     
0250 69C2 69C4     copyw   data $+2
0251 69C4 06A0  28         bl @bank1
     69C6 8332     
0252 69C8 663C             data _copyw                 ; implemented in 1-04-Memory.a99
0253               ;]
0254               
                   < build.asm
0019                   copy "./bank0/0-08-Parsing.asm"
     **** ****     > ./bank0/0-08-Parsing.asm
0001               ;  _____                _              __          __            _
0002               ; |  __ \              (_)             \ \        / /           | |
0003               ; | |__) |__ _ _ __ ___ _ _ __   __ _   \ \  /\  / /___  _ __ __| |___
0004               ; |  ___// _` | '__/ __| | '_ \ / _` |   \ \/  \/ // _ \| '__/ _` / __|
0005               ; | |   | (_| | |  \__ \ | | | | (_| |    \  /\  /| (_) | | | (_| \__ \
0006               ; |_|    \__,_|_|  |___/_|_| |_|\__, |     \/  \/  \___/|_|  \__,_|___/
0007               ;                                __/ |
0008               ;                               |___/
0009               ; Dictionary lookup and associated parsing words
0010               
0011               ;[ EXPECT       addr +n --                    M,83
0012               ; Receive characters and store each into memory.  The transfer begins at addr
0013               ; proceeding towards higher addresses one byte per character until either a
0014               ; "return" is received or until +n characters have been transferred.
0015               ; No more than +n characters will be stored.
0016               ; The "return" is not stored into memory.
0017               ; No characters are received or transferred if +n is zero.
0018               ; All characters actually received and stored into memory will be displayed,
0019               ; with the "return" displaying as a space.  See:  SPAN  "9.5.2 EXPECT"
0020 69CA 69B8     expcth  data copywh,6
     69CC 0006     
0021 69CE 4558             text 'EXPECT'
     69D0 5045     
     69D2 4354     
0022 69D4 69D6     expect  data $+2
0023 69D6 04E0  34         clr @in                     ; clear >IN variable
     69D8 A044     
0024 69DA 04CE  14         clr r14                     ; counter for number of characters
0025                                                   ; *actually* in the buffer
0026 69DC C374  30         mov *stack+,r13             ; pop length in r13
0027 69DE C2B4  30         mov *stack+,r10             ; pop address address in r10
0028 69E0 C34D  18         mov r13,r13                 ; check length
0029 69E2 133E  14         jeq zchars                  ; quit if 0 characters requested
0030 69E4 06A0  32 expnxt  bl @kscn                    ; scan keyboard (wait for a keypress)
     69E6 6DDC     
0031                                                   ; ascii code returned on the stack
0032                   ; check for enter key...
0033 69E8 8814  42         c *stack,@datCR             ; compare to carriage return (enter key)
     69EA 6A66     
0034 69EC 1337  14         jeq exp2                    ; exit routine if enter was pressed
0035               ;[    ; check for backspace key...
0036 69EE 8814  42         c *stack,@lit8+4            ; compare to backspace key
     69F0 6096     
0037 69F2 161F  14         jne skipbs                  ; skip if backspace not pressed
0038 69F4 05C4  14         inct stack                  ; remove backspace from stack
0039 69F6 C38E  18         mov r14,r14                 ; check if anything in the buffer
0040 69F8 13F5  14         jeq expnxt                  ; tib is empty, ignore...
0041                   ; do backspace...
0042 69FA 06A0  32         bl @ccp                     ; compute cursor position
     69FC 6F18     
0043 69FE 0201  20         li r1,>2000                 ; load a space character
     6A00 2000     
0044 6A02 06A0  32         bl @vsbw                    ; erase the cursor
     6A04 7F9E     
0045 6A06 C020  34         mov @scrX,r0                ; get current x position
     6A08 A02A     
0046 6A0A 160B  14         jne back1                   ; if x>0 we don't need to move up one line
0047 6A0C C820  54         mov @xmax,@scrX             ; move to end of line
     6A0E A02E     
     6A10 A02A     
0048 6A12 0620  34         dec @scrX                   ; correct X
     6A14 A02A     
0049 6A16 0620  34         dec @scrY                   ; up one screen line
     6A18 A02C     
0050 6A1A C020  34         mov @scrY,r0                ; check y
     6A1C A02C     
0051 6A1E 1106  14         jlt bumpY                   ; if <0 then reset to 0
0052 6A20 1002  14         jmp back2
0053 6A22 0620  34 back1   dec @scrX                   ; move back one character
     6A24 A02A     
0054 6A26 060E  14 back2   dec r14                     ; decrement buffer index pointer
0055 6A28 060A  14         dec r10                     ; decrement buffer position
0056 6A2A 10DC  14         jmp expnxt                  ; get another keypress
0057 6A2C 05A0  34 bumpY   inc @scrY                   ; prevent Y from going <0
     6A2E A02C     
0058 6A30 10FA  14         jmp back2
0059               ;]
0060                   ; process keypress...
0061 6A32 0644  14 skipbs  dect stack                  ; new stack entry
0062 6A34 C524  46         mov @2(stack),*stack        ; duplicate value on stack for EMIT
     6A36 0002     
0063 6A38 06A0  32         bl @emit_                   ; call emit (which may/may not call SCRLUP)
     6A3A 6D9A     
0064 6A3C 06D4  26         swpb *stack                 ; shift ascii code into MSB
0065 6A3E C074  30         mov *stack+,r1
0066 6A40 C00A  18         mov r10,r0
0067 6A42 058A  14         inc r10
0068 6A44 06A0  32         bl @vsbw0
     6A46 7FAC     
0069 6A48 058E  14         inc r14                     ; increment 'number of characters in buffer so far'
0070                                                   ; counter
0071 6A4A 880E  34         c r14,@tibsiz               ; do we have #TIB characters in the buffer?
     6A4C A04C     
0072 6A4E 1302  14         jeq exp1                    ; if so, exit the routine
0073 6A50 838D  18         c r13,r14                   ; have we got 'length' characters?
0074 6A52 16C8  14         jne expnxt                  ; read another key if not
0075 6A54 C80E  38 exp1    mov r14,@_span              ; move character count into _span
     6A56 A04E     
0076 6A58 0460  28         b @space1+2                 ; type a space to the console and exit
     6A5A 6D34     
0077 6A5C 05C4  14 exp2    inct stack                  ; pop ascii 13 off the stack
0078 6A5E 10FA  14         jmp exp1
0079               
0080               ; special case if 0 characters were requested for some weird reason...
0081 6A60 04E0  34 zchars  clr @_span
     6A62 A04E     
0082 6A64 045C  20         b *next
0083 6A66 000D     datCR   data 13                     ; ascii code for carriage return
0084               ;]
0085               
0086               ;[ Comments: ( \ & .(
0087               ; Allows comments e.g. : 1TO3 ( comment) 1 2 3 ;
0088               ; Reads through the TIB until ) is found or end of line
0089 6A68 69CA     remh    data expcth,immed+1
     6A6A 8001     
0090 6A6C 2820             text '( '
0091 6A6E 8320     rem     data docol
0092 6A70 70B8             data lit,')',word,drop2
     6A72 0029     
     6A74 6AA4     
     6A76 75D2     
0093 6A78 832C             data exit
0094               
0095 6A7A 6A68     trcomh  data remh,immed+1
     6A7C 8001     
0096 6A7E 5C20             text '\ '
0097 6A80 6A82     trcom   data $+2
0098 6A82 06A0  28         bl @bank1
     6A84 8332     
0099 6A86 6BFC             data _trcom
0100               
0101 6A88 6A7A     typcmh  data trcomh,immed+2
     6A8A 8002     
0102 6A8C 2E28             text '.('
0103 6A8E 8320             data docol,lit,41,word,type,cr,exit
     6A90 70B8     
     6A92 0029     
     6A94 6AA4     
     6A96 6C96     
     6A98 6E8C     
     6A9A 832C     
0104               ;]
0105               
0106               ;[ WORD ( delimiter -- address length )
0107               ; Moves through TIB in VDP memory, discarding leading delimiters, looking for
0108               ; a word. A word is identified when a trailing delimiter is detected.
0109               ; The word is copied from VDP to CPU memory.
0110               ; Pushes the start address of the word (in CPU memory), and the length of
0111               ; the word to the stack.
0112               ; If no word is found (for example if we hit the end of the TIB without
0113               ; detecting a word then 0 0 is pushed on the stack.
0114               
0115 6A9C 6A88     wordh   data typcmh,4
     6A9E 0004     
0116 6AA0 574F             text 'WORD'
     6AA2 5244     
0117 6AA4 8320     word    data docol
0118                       ; tib @ blk @ ?dup if nip block then
0119 6AA6 772E             data tib_,fetch
     6AA8 6822     
0120 6AAA 7B50     word0   data blk,fetch,qdup,zbrnch,word2,nip,fblock
     6AAC 6822     
     6AAE 61FA     
     6AB0 65E8     
     6AB2 6AB8     
     6AB4 61D0     
     6AB6 7C4A     
0121 6AB8 6ABC     word2   data word1
0122 6ABA 832C             data exit
0123               
0124               ; at this point, data stack is ( delimeter address -- )
0125               ; where address is the address in vdp to start searching from.
0126               ; address is either TIB+>IN (if BLK=0) or block address+>IN
0127               ; if BLK>0. (the code to add >IN to the address is in _word)
0128 6ABC 6ABE     word1   data $+2
0129 6ABE 06A0  28         bl @bank1
     6AC0 8332     
0130 6AC2 6B7C             data _word                  ; see 1-08-Parsing.a99
0131               ;]
0132               
0133               ;[ BL ( -- 32 )
0134               ; pushes 32 decimal to the stack. BL is short for 'BLANK' often used in with
0135               ; word to specify the delimeter: e.g. BL WORD
0136 6AC4 6A9C     blh     data wordh,2
     6AC6 0002     
0137 6AC8 424C             text 'BL'
0138 6ACA 8320     bl_     data docol,lit,32,exit
     6ACC 70B8     
     6ACE 0020     
     6AD0 832C     
0139               ;]
0140               
0141               ;[ FIND         addr1 len -- addr2 n              83
0142               ; addr1 is the address of a string.  The string contains a word name to be
0143               ; located in the currently active search order.  If the word is not found, addr2
0144               ; is the string address addr1, and n is zero.
0145               ; If the word is found, addr2 is the compilation address and n is set to one of
0146               ; two non-zero values.  If the word found has the immediate attribute,
0147               ; n is set to one.  If the word is non-immediate, n is set to minus one (true).
0148               ; Len indicates the length of the string beginnig at addr1.
0149 6AD2 6AC4     findh   data blh,4
     6AD4 0004     
0150 6AD6 4649             text 'FIND'
     6AD8 4E44     
0151 6ADA 8320     find    data docol,lit,fndvec,fetch,execut,exit
     6ADC 70B8     
     6ADE A006     
     6AE0 6822     
     6AE2 72AA     
     6AE4 832C     
0152 6AE6 6AE8     vfind   data $+2                    ; vectored find
0153 6AE8 C1B4  30         mov *stack+,r6              ; pop length to r6
0154 6AEA C1E0  34         mov @latest,r7              ; get address of last dictionary entry
     6AEC A046     
0155 6AEE C227  34 fndnxt  mov @2(r7),r8               ; length of dictionary entry
     6AF0 0002     
0156 6AF2 0248  22         andi r8,>400f               ; mask out immediate bit and block numbers
     6AF4 400F     
0157 6AF6 8188  18         c r8,r6                     ; are they the same length?
0158 6AF8 1303  14         jeq lmatch                  ; jump if yes
0159 6AFA C1D7  26 find1   mov *r7,r7                  ; point to next dictionary entry
0160 6AFC 1326  14         jeq nomatch                 ; if 0 then no match. end of dictionary.
0161 6AFE 10F7  14         jmp fndnxt                  ; else check the next entry
0162                   ; the length matches.
0163                   ; now do a character comparison between the word in the buffer and the word
0164                   ; in the dictionary
0165 6B00 C287  18 lmatch  mov r7,r10
0166 6B02 022A  22         ai r10,4                    ; point to text of dictionary entry
     6B04 0004     
0167 6B06 C014  26         mov *stack,r0               ; buffer address in r0
0168 6B08 D070  28 cnxtch  movb *r0+,r1                ; otherwise get a character from buffer
0169 6B0A 06A0  32         bl @caschk                  ; convert case if case sensitive=off
     6B0C 6B50     
0170 6B0E C381  18         mov r1,r14                  ; save the character
0171 6B10 D07A  28         movb *r10+,r1               ; get character from dictionary entry
0172 6B12 06A0  32         bl @caschk                  ; convert case if case sensitive=off
     6B14 6B50     
0173 6B16 9381  18 find2   cb r1,r14                   ; compare the two characters
0174 6B18 16F0  14         jne find1                   ; if not equal then check next dict entry
0175 6B1A 0608  14         dec r8                      ; decrememnt length
0176 6B1C 16F5  14         jne cnxtch                  ; if not 0 then check next character
0177                   ; we have a match push cfa and word type
0178 6B1E C227  34         mov @2(r7),r8               ; get length of dictionary entry
     6B20 0002     
0179 6B22 C248  18         mov r8,r9                   ; make a copy
0180 6B24 0248  22         andi r8,>f                  ; retain length only
     6B26 000F     
0181 6B28 A1C8  18         a r8,r7                     ; add length
0182 6B2A 0227  22         ai r7,4                     ; take account of address & link field
     6B2C 0004     
0183 6B2E 0587  14         inc r7                      ; round up...
0184 6B30 0247  22         andi r7,>fffe               ; ...to even address
     6B32 FFFE     
0185 6B34 C507  30         mov r7,*stack               ; push cfa
0186 6B36 0644  14         dect stack                  ; prepare to push 'n' (see stack sig)
0187 6B38 0249  22 l8000   andi r9,immed               ; check immediate bit
     6B3A 8000     
0188 6B3C 1304  14         jeq noimm                   ; if not set then push -1 for status
0189 6B3E 0201  20         li r1,1                     ; else push a 1
     6B40 0001     
0190 6B42 C501  30         mov r1,*stack
0191 6B44 045C  20         b *next
0192 6B46 0714  26 noimm   seto *stack                 ; not immediate - push -1
0193 6B48 045C  20         b *next
0194 6B4A 0644  14 nomatch dect stack                  ; leave address unchanged on stack
0195 6B4C 04D4  26         clr *stack                  ; 0=not found
0196 6B4E 045C  20         b *next
0197               ; Convert lower case characters to upper case if case sensitivity is turned off
0198               ;  Input: r1 msb = character to test
0199               ; Output: r1 msb = upper case character
0200 6B50 D360  34 caschk  movb @cassen,r13            ; case sensitive mode switched off?
     6B52 A058     
0201 6B54 160B  14         jne casout                  ; skip case conversion if switched off
0202 6B56 D341  18         movb r1,r13                 ; get the character in a spare register
0203 6B58 098D  40         srl r13,8                   ; move to low byte
0204 6B5A 028D  22         ci r13,'a'                  ; compare to a
     6B5C 0061     
0205 6B5E 1106  14         jlt casout                  ; if less than it's not a lower case char
0206 6B60 028D  22         ci r13,'z'                  ; else compare to z
     6B62 007A     
0207 6B64 1503  14         jgt casout                  ; if greater than it's not a lower case char
0208 6B66 020D  20         li r13,-32*256              ; it's lower case. load -32 in the upper byte
     6B68 E000     
0209 6B6A B04D  18         ab r13,r1                   ; subtract -32 from the upper byte.
0210                       ; char is now upper case
     **** ****     > RT
0211               casout  .rt
0001 6B6C 045B  20        b * r11
                   < 0-08-Parsing.asm
0212               ;]
0213               
0214               ;[ NUMBER ( address length -- number flag )
0215               ; Attempts to convert the string at address into a number. If fully successful,
0216               ; the number is placed on the stack and flag will be 0. If it fails (for example
0217               ; contains an illegal character) then a partial number will be placed on the
0218               ; stack (the value computed up until the failure) and flag will be >0.
0219               ; Thus, if flag>0 the string failed to parse fully as a number.
0220               ; A minus sign is permitted for negative numbers.
0221               ; This routine uses BASE to parse numbers in the current BASE.
0222               ; Eg. If BASE=16 then digits 0-9 and A-F are considered legal and will be
0223               ; parsed properly.
0224               ; A facility also exists called 'quick hex' that allows a number to be entered
0225               ; in base 16, by placing a $ symbol at the end of the string. This avoids the
0226               ; need to change BASE to enter a number. E.g. instead of HEX FEED DECIMAL you
0227               ; can simply do $FEED. The number will be parsed as a HEX number without the
0228               ; need to change BASE.
0229               ; The numbers returned are (by default) singles (16 bits). NUMBER can can also
0230               ; return a double (32-bit (2 stack cells)) value by including a period in the
0231               ; number string. E.g. 100. 1.00 10.0 .100 will all return 100 decimal as a
0232               ; double.
0233               ; The various facilities can be mixed. For example, f. means -15 as a double.
0234               ; - $ and . can be specified in any order. However, $ if required, should be
0235               ; specified before any number digits. - and . can come anywhere in the string.
0236               ; in the number string.
0237 6B6E 6AD2     numbrh  data findh,6
     6B70 0006     
0238 6B72 4E55             text 'NUMBER'
     6B74 4D42     
     6B76 4552     
0239 6B78 8320     number  data docol,lit,numvec,fetch,execut,exit ; fetch NUMBER vector & execute
     6B7A 70B8     
     6B7C A004     
     6B7E 6822     
     6B80 72AA     
     6B82 832C     
0240 6B84 6B86     numbr1  data $+2
0241 6B86 06A0  28         bl @bank1
     6B88 8332     
0242 6B8A 6C1C             data _numbr                 ; see 1-08-Parsing.a99
0243               ;]
0244               
0245               ;[ EVALUATE ( i*x c-addr u -- j*x)
0246               ; evaluates the string specified by c-addr u
0247               ; the interpretation state is stored before evaluation and restored afterwards
0248               ; should not be directly called within a block (or when BLK>0)
0249 6B8C 6B6E     evalh   data numbrh,8
     6B8E 0008     
0250 6B90 4556             text 'EVALUATE'
     6B92 414C     
     6B94 5541     
     6B96 5445     
0251 6B98 8320     eval    data docol
0252 6B9A 76FC             data in_,fetch,rspush
     6B9C 6822     
     6B9E 6282     
0253 6BA0 7B50             data blk,fetch,rspush
     6BA2 6822     
     6BA4 6282     
0254 6BA6 7648             data span,fetch,rspush
     6BA8 6822     
     6BAA 6282     
0255 6BAC 772E             data tib_,fetch,rspush
     6BAE 6822     
     6BB0 6282     
0256               
0257 6BB2 76FC             data in_,store0             ; zero >IN
     6BB4 6884     
0258 6BB6 7B50             data blk,store0             ; zero BLK
     6BB8 6884     
0259 6BBA 7648             data span,store             ; load #tib with u
     6BBC 6844     
0260 6BBE 772E             data tib_,store             ; load tib with c-addr
     6BC0 6844     
0261               
0262 6BC2 609A             data litm1,lit,source,store ; set SOURCE-ID to -1
     6BC4 70B8     
     6BC6 A05A     
     6BC8 6844     
0263 6BCA 72FE             data interp                 ; call interpreter
0264 6BCC 70B8             data lit,source,store0      ; zero SOURCE-ID
     6BCE A05A     
     6BD0 6884     
0265               
0266 6BD2 629E             data rspop,tib_,store
     6BD4 772E     
     6BD6 6844     
0267 6BD8 629E             data rspop,span,store
     6BDA 7648     
     6BDC 6844     
0268 6BDE 629E             data rspop,blk,store
     6BE0 7B50     
     6BE2 6844     
0269 6BE4 629E             data rspop,in_,store
     6BE6 76FC     
     6BE8 6844     
0270 6BEA 832C             data exit
0271               ;]
0272               
0273               ;[ >CFA ( dictionary_address -- code_field_address)
0274               ; Given a dictionary address returns the code-field address (CFA) of the word
0275 6BEC 6B8C     cfah    data evalh,4
     6BEE 0004     
0276 6BF0 3E43             text '>CFA'
     6BF2 4641     
0277 6BF4 6BF6     cfa     data $+2
0278 6BF6 C094  26 _cfa    mov *stack,r2               ; dictionary address
0279 6BF8 C062  34         mov @2(r2),r1               ; word length
     6BFA 0002     
0280 6BFC 0581  14         inc r1                      ; round word length up to even number if odd
0281 6BFE 0241  22         andi r1,>000e               ; keep only rounded up length value
     6C00 000E     
0282 6C02 A042  18         a r2,r1                     ; add length to dictionary address
0283 6C04 8C71  42         c *r1+,*r1+                 ; adjust by two words, one word for header
0284                                                   ; word, one word for length word.
0285                                                   ; we're now pointing at the CFA. nice trick
0286                                                   ; to add 4 to a register in only 2 bytes!
0287 6C06 C501  30         mov r1,*stack               ; move to stack
0288 6C08 045C  20         b *next                     ; NEXT
0289               ;]
0290               
0291               ;[ >BODY ( cfa -- body_address )
0292               ; Given a CFA, returns the address of the body (the address of the "payload")
0293               ; of words created with CREATE. E.g. VARIABLE, VALUE, CONSTANT
0294 6C0A 6BEC     tbodyh  data cfah,5
     6C0C 0005     
0295 6C0E 3E42             text '>BODY '
     6C10 4F44     
     6C12 5920     
0296 6C14 839A     tobody  data _plus2                 ; execute 2+ (see 0-03-Math.a99)
0297               ;]
0298               
0299               ;[ >LINK ( cfa -- link_field_address )
0300               ; given a code field address, returns the address of the beginning of the dictionary
0301               ; entry (the address of the link field).
0302 6C16 6C0A     dfah    data tbodyh
0303 6C18 0005             data 5
0304 6C1A 3E4C             text '>LINK '
     6C1C 494E     
     6C1E 4B20     
0305 6C20 6C22     dfa     data $+2
0306 6C22 C020  34         mov @latest,r0              ; get latest dictionary entry
     6C24 A046     
0307 6C26 C040  18 dfa1    mov r0,r1                   ; copy it
0308 6C28 05C0  14         inct r0                     ; point to length
0309 6C2A C090  26         mov *r0,r2                  ; get the length
0310 6C2C 0640  14         dect r0                     ; point to beginning of dict entry again
0311 6C2E 0242  22         andi r2,>f                  ; mask out immediate, hidden, and block
     6C30 000F     
0312                                                   ; number, leaving length
0313 6C32 A042  18         a r2,r1                     ; add length
0314 6C34 0581  14         inc r1                      ; round up to...
0315 6C36 0241  22         andi r1,>fffe               ; ...word address
     6C38 FFFE     
0316 6C3A 05C1  14         inct r1                     ; account for the length word itself
0317 6C3C 05C1  14         inct r1
0318 6C3E 8501  26         c r1,*stack                 ; is it what we're looking for?
0319 6C40 1303  14         jeq dfafnd                  ; jump if yes
0320 6C42 C010  26         mov *r0,r0                  ; otherwise walk the list
0321 6C44 1301  14         jeq dfafnd                  ; if zero, we didn't find - push zero
0322 6C46 10EF  14         jmp dfa1                    ; otherwise check the next entry in the list
0323 6C48 C500  30 dfafnd  mov r0,*stack               ; place on stack
0324 6C4A 045C  20         b *next
0325               ;]
                   < build.asm
0020                   copy "./bank0/0-09-Console.asm"
     **** ****     > ./bank0/0-09-Console.asm
0001               ;   _____                       _       __          __            _
0002               ;  / ____|                     | |      \ \        / /           | |
0003               ; | |      ___  _ __  ___  ___ | | ___   \ \  /\  / /___  _ __ __| |___
0004               ; | |     / _ \| '_ \/ __|/ _ \| |/ _ \   \ \/  \/ // _ \| '__/ _` / __|
0005               ; | |____| (_) | | | \__ \ (_) | |  __/    \  /\  /| (_) | | | (_| \__ \
0006               ;  \_____|\___/|_| |_|___/\___/|_|\___|     \/  \/  \___/|_|  \__,_|___/
0007               ;  Console IO words
0008               
0009               ;[ BREAK? ( -- )
0010               ; scans keyboard and does an ABORT if break (FCTN 4) is pressed
0011 6C4C 6C16     breakh  data dfah,6
     6C4E 0006     
0012 6C50 4252             text 'BREAK?'
     6C52 4541     
     6C54 4B3F     
0013 6C56 8320     break   data docol,keyq,lit,2,eq,zbrnch,break1
     6C58 6E5C     
     6C5A 70B8     
     6C5C 0002     
     6C5E 646C     
     6C60 65E8     
     6C62 6C6E     
0014 6C64 6E8C             data cr,toterm,brkmsg,cr,ab0rt
     6C66 60B4     
     6C68 6C70     
     6C6A 6E8C     
     6C6C 7460     
0015 6C6E 832C     break1  data exit
0016 6C70 05       brkmsg  byte 5 ; length of text
0017 6C71   42             text 'Break '
     6C72 7265     
     6C74 616B     
     6C76 20       
0018               ;]
0019               
0020               ;[ GOTOXY ( x y -- )
0021               ; sets the screen cursor to the specified (0 based) x y screen coordinates
0022 6C78 6C4C     goxyh   data breakh,6
     6C7A 0006     
0023 6C7C 474F             text 'GOTOXY'
     6C7E 544F     
     6C80 5859     
0024 6C82 6C84     gotoxy  data $+2
0025 6C84 C834  50         mov *stack+,@scry           ; pop y
     6C86 A02C     
0026 6C88 C834  50         mov *stack+,@scrx           ; pop x
     6C8A A02A     
0027 6C8C 045C  20         b *next
0028               ;]
0029               
0030               ;[ TYPE         addr +n --                    M,79
0031               ; +n characters are displayed from memory beginning with the character at addr
0032               ; and continuing through consecutive addresses.
0033               ; Nothing is displayed if +n is zero.
0034               ; See: "9.5.4 TYPE"
0035 6C8E 6C78     typeh   data goxyh,4
     6C90 0004     
0036 6C92 5459             text 'TYPE'
     6C94 5045     
0037 6C96 6C98     type    data $+2
0038 6C98 C374  30 type1   mov *stack+,r13             ; pop length in r13
0039 6C9A C2B4  30         mov *stack+,r10             ; address in r10
0040 6C9C C34D  18         mov r13,r13                 ; check the length
0041 6C9E 1208  14         jle typout                  ; if 0 or negative then exit
0042 6CA0 D1FA  28 typlp   movb *r10+,r7               ; get byte from string in r7 MSB
0043 6CA2 06C7  14         swpb r7                     ; rotate MSB into LSB
0044 6CA4 0644  14         dect stack                  ; create space on stack
0045 6CA6 C507  30         mov r7,*stack               ; place on stack
0046 6CA8 06A0  32         bl @emit_                   ; call emit
     6CAA 6D9A     
0047 6CAC 060D  14         dec r13                     ; have we finished?
0048 6CAE 16F8  14         jne typlp                   ; if not, repeat
0049 6CB0 045C  20 typout  b *next
0050               ;]
0051               
0052               ;[ WORDS ( -- )
0053               ; displays a list of all the words in the dictionary
0054 6CB2 6C8E     wordsh  data typeh,5
     6CB4 0005     
0055 6CB6 574F             text 'WORDS '
     6CB8 5244     
     6CBA 5320     
0056 6CBC 8320     words_  data docol
0057 6CBE 6E8C             data cr,lit0,lates_
     6CC0 6082     
     6CC2 76CE     
0058 6CC4 6822     words1  data fetch,dup,zbrnch,words2
     6CC6 6184     
     6CC8 65E8     
     6CCA 6CFC     
0059 6CCC 6184             data dup,plus2,dup,fetch,lit,15,and
     6CCE 62C0     
     6CD0 6184     
     6CD2 6822     
     6CD4 70B8     
     6CD6 000F     
     6CD8 67C4     
0060 6CDA 617A             data swap,plus2,swap,type
     6CDC 62C0     
     6CDE 617A     
     6CE0 6C96     
0061 6CE2 6C56     words3  data break
0062 6CE4 6E5C     words4  data keyq,lit,>ffff,eq,zbrnch,words4
     6CE6 70B8     
     6CE8 FFFF     
     6CEA 646C     
     6CEC 65E8     
     6CEE 6CE4     
0063 6CF0 6D32             data space1,swap,plus1,swap
     6CF2 617A     
     6CF4 62AC     
     6CF6 617A     
0064 6CF8 65D6             data branch,words1
     6CFA 6CC4     
0065 6CFC 6170     words2  data drop,cr,dot
     6CFE 6E8C     
     6D00 782C     
0066 6D02 60B4             data toterm,wftxt
     6D04 6D08     
0067 6D06 832C             data exit
0068 6D08 06       wftxt   byte 6
0069 6D09   57             text 'Words '
     6D0A 6F72     
     6D0C 6473     
     6D0E 20       
0070               ;]
0071               
0072               ;[ XY? ( -- x y )
0073               ; places the cursor x and y coordinates on the stack
0074 6D10 6CB2     xyh     data wordsh,3
     6D12 0003     
0075 6D14 5859             text 'XY? '
     6D16 3F20     
0076 6D18 6D1A     xy      data $+2
0077 6D1A 0644  14         dect stack                  ; new stack entry
0078 6D1C C520  46         mov @scrX,*stack            ; push scrX to stack
     6D1E A02A     
0079 6D20 0644  14         dect stack                  ; new stack entry
0080 6D22 C520  46         mov @scrY,*stack            ; push scrY to stack
     6D24 A02C     
0081 6D26 045C  20         b *next
0082               ;]
0083               
0084               ;[ SPACE        --                            M,79
0085               ; Displays an ASCII space.
0086 6D28 6D10     spaceh  data xyh,5
     6D2A 0005     
0087 6D2C 5350             text 'SPACE '
     6D2E 4143     
     6D30 4520     
0088 6D32 6D34     space1  data $+2
0089 6D34 0644  14         dect stack                  ; new stack entry
0090 6D36 0200  20         li r0,32                    ; space character
     6D38 0020     
0091 6D3A C500  30         mov r0,*stack               ; push it to stack
0092 6D3C 06A0  32         bl @emit_                   ; call emit
     6D3E 6D9A     
0093 6D40 045C  20         b *next
0094               ;]
0095               
0096               ;[ SPACES       +n --                         M,79
0097               ; Displays +n ASCII spaces.  Nothing is displayed if +n is zero.
0098 6D42 6D28     spcesh  data spaceh,6
     6D44 0006     
0099 6D46 5350             text 'SPACES'
     6D48 4143     
     6D4A 4553     
0100 6D4C 6D4E     spces   data $+2
0101 6D4E C1F4  30         mov *stack+,r7              ; pop count in r7
0102 6D50 C1C7  18         mov r7,r7                   ; check for 0
0103 6D52 1309  14         jeq spcesx                  ; if zero, just quit
0104 6D54 0747  18         abs r7                      ; make positive if negative
0105 6D56 0644  14 spces1  dect stack                  ; create stack entry
0106 6D58 0208  20         li r8,32                    ; space character
     6D5A 0020     
0107 6D5C C508  30         mov r8,*stack               ; put space on stack
0108 6D5E 06A0  32         bl @emit_                   ; display the space via emit
     6D60 6D9A     
0109 6D62 0607  14         dec r7                      ; decrement count
0110 6D64 16F8  14         jne spces1                  ; repeat if not finished
0111 6D66 045C  20 spcesx  b *next
0112               ;]
0113               
0114               ;[ PAGE ( -- )
0115               ; clears screen
0116 6D68 6D42     clsh    data spcesh,4
     6D6A 0004     
0117 6D6C 5041             text 'PAGE'
     6D6E 4745     
0118 6D70 6D72     cls     data $+2
0119 6D72 06A0  28         bl @bank1
     6D74 8332     
0120 6D76 6134             data _cls                   ; see 1-02-Console.a99
0121               ;]
0122               
0123               ;[ JOYST ( joystick# -- value )
0124               ; Scans the joystick returning the direction value
0125 6D78 6D68     joysth  data clsh,5
     6D7A 0005     
0126 6D7C 4A4F             text 'JOYST '
     6D7E 5953     
     6D80 5420     
0127 6D82 6D84     joyst   data $+2
0128 6D84 06A0  28         bl @bank1                   ; see 1-02-Console.a99
     6D86 8332     
0129 6D88 6154             data _joyst
0130               ;]
0131               
0132               ;[ EMIT         16b --                        M,83
0133               ; The least-significant 8-bit ASCII character is displayed. SEE:  "9.5.3 EMIT"
0134 6D8A 6D78     emith   data joysth,4
     6D8C 0004     
0135 6D8E 454D             text 'EMIT'
     6D90 4954     
0136 6D92 6D94     emit    data $+2
0137                   ; EMIT as called from the Forth environment:
0138 6D94 06A0  32         bl @emit_                   ; call emit routine (see below)
     6D96 6D9A     
0139 6D98 045C  20         b *next
0140               
0141                   ; emit as an internal assembly sub-routine (used by SPACE, SPACES & TYPE):
0142               emit_
0143 6D9A C24B  18         mov r11,r9                  ; save return address
0144 6D9C 06A0  32         bl @ccp                     ; compute cursor position (loaded into r0)
     6D9E 6F18     
0145 6DA0 C074  30         mov *stack+,r1              ; pop character
0146 6DA2 06C1  14         swpb r1                     ; get byte in msb
0147 6DA4 06A0  32         bl @vsbw                    ; write char to screen at computed position
     6DA6 7F9E     
0148 6DA8 05A0  34         inc @scrX                   ; increment x postion of cursor
     6DAA A02A     
0149 6DAC 8820  50         c @scrx,@xmax               ; have we hit the right-most column?
     6DAE A02A     
     6DB0 A02E     
0150 6DB2 1301  14         jeq clipx                   ; if yes, reset x
0151 6DB4 0459  20         b *r9                       ; else return
0152 6DB6 04E0  34 clipx   clr @scrX                   ; reset x to 0
     6DB8 A02A     
0153 6DBA 05A0  34         inc @scrY                   ; increment y
     6DBC A02C     
0154 6DBE 8820  50         c @scrY,@ymax               ; have we hit the bottom of the screen?
     6DC0 A02C     
     6DC2 A030     
0155 6DC4 136E  14         jeq scrlup                  ; if yes then scroll screen up
0156 6DC6 0459  20 emitx   b *r9                       ; else return
0157               ;]
0158               
0159               ;[ KEY          -- 16b                        M,83
0160               ; The least-significant 7 bits of 16b is the next ASCII character received.
0161               ; All valid ASCII characters can be received.
0162               ; Control characters are not processed by the system for any editing purpose.
0163               ; Characters received by KEY will not be displayed.
0164               ; See:  "9.5.1 KEY"
0165      FF00     nokey   equ >ff00                   ; keycode for no key pressed
0166      0003     delkey  equ 3                       ; keycode for delete key
0167               
0168 6DC8 6D8A     kscnh   data emith,3
     6DCA 0003     
0169 6DCC 4B45             text 'KEY '
     6DCE 5920     
0170 6DD0 6DD2     key     data $+2
0171 6DD2 04E0  34         clr @cursrd
     6DD4 A026     
0172 6DD6 06A0  32         bl @kscn                    ; call key scan routine
     6DD8 6DDC     
0173 6DDA 045C  20         b *next                     ; NEXT
0174                   ; keyscan has been split from the forth word KEY.
0175                   ; this allows it to be called both as a forth word (KEY) and as a machine
0176                   ; code routine.
0177 6DDC C20B  18 kscn    mov r11,r8                  ; save return address
0178 6DDE 06A0  32 kscn1   bl @cflash                  ; call cursor flash routine
     6DE0 6E1C     
0179 6DE2 D820  46         movb @keydev,@>8374         ; set keyboard to scan
     6DE4 A024     
     6DE6 8374     
0180 6DE8 02E0  18         lwpi >83e0                  ; use gpl workspace
     6DEA 83E0     
0181 6DEC 06A0  28         bl @>000e                   ; call keyboard scanning routine
     6DEE 000E     
0182                   ; restore the turboforth workspace
0183                   ; TFs workspace is held in 'wp'. This routine writes a program in the GPL
0184                   ; workspace  starting at R0 which performs an LWPI instruction, and then
0185                   ; jumps the remainder of this keyscan routine below.
0186                   ;
0187 6DF0 0200  20     li r0,>02e0     ; lwpi instruction
     6DF2 02E0     
0188 6DF4 C060  34     mov @wp,r1      ; lwpi operand
     6DF6 A012     
0189 6DF8 0202  20     li r2,>0460     ; branch opcode
     6DFA 0460     
0190 6DFC 0203  20     li r3,kscn2     ; operand for branch instruction
     6DFE 6E02     
0191 6E00 0440  12     b r0
0192 6E02 D1E0  30 kscn2   movb @gplst,r7              ; get GPL STATUS byte in r7 MSB
     6E04 837C     
0193 6E06 0A37  30         sla r7,3                    ; shift COND bit into carry bit
0194 6E08 17EA  14         jnc kscn1                   ; no key pressed, or same key pressed as
0195                                                   ; previous scan. ignore and re-scan.
0196 6E0A D1E0  30         movb @keyin,r7              ; a new key was pressed: get ascii code in
     6E0C 8375     
0197                                                   ; r7 msb
0198 6E0E 0287  22         ci r7,nokey                 ; compare against 'no key pressed' code
     6E10 FF00     
0199 6E12 13E5  14         jeq kscn1                   ; no key was pressed
0200 6E14 0987  40         srl r7,8                    ; a key was pressed. move to low byte
0201 6E16 0644  14         dect stack                  ; new stack entry
0202 6E18 C507  30         mov r7,*stack               ; place ascii code onto stack
0203 6E1A 0458  20         b *r8                       ; return to caller
0204               
0205                   ; cursor flashing
0206 6E1C C820  54 cflash  mov @bank0,@retbnk          ; return to bank 0
     6E1E 6068     
     6E20 A070     
0207 6E22 0300  22         limi 2                      ; service isr
     6E24 0002     
0208 6E26 0300  22         limi 0
     6E28 0000     
0209 6E2A C18B  18         mov r11,r6                  ; save return address
0210 6E2C 0207  20         li r7,>2000                 ; load space & ascii 0 characters for cursor
     6E2E 2000     
0211 6E30 C020  34         mov @cursrd,r0              ; get cursor delay
     6E32 A026     
0212 6E34 0220  22         ai r0,>80                   ; increment
     6E36 0080     
0213 6E38 C800  38         mov r0,@cursrd              ; save it
     6E3A A026     
0214 6E3C 1305  14         jeq csrwrt                  ; if zero, write a blank cursor character
0215 6E3E 06C7  14         swpb r7                     ; load _ cursor character
0216 6E40 0280  22         ci r0,>8000                 ; cursror delay = >8000?
     6E42 8000     
0217 6E44 1301  14         jeq csrwrt                  ; if yes, write an _ cursor character
0218 6E46 0456  20         b *r6                       ; if neither, just return
0219 6E48 06A0  32 csrwrt  bl @ccp                     ; call compute cursor position
     6E4A 6F18     
0220 6E4C C047  18         mov r7,r1                   ; move cursor character to r1 for VSBW
0221 6E4E 06A0  32         bl @vsbw                    ; write the cursror character to the screen
     6E50 7F9E     
0222 6E52 0456  20         b *r6                       ; return to caller
0223               ;]
0224               
0225               ;[ KEY? ( -- ascii/-1 )
0226               ; Scans keyboard and returns the ascii code of the key pressed,
0227               ; or -1 if no key pressed
0228 6E54 6DC8     keyqh   data kscnh,4
     6E56 0004     
0229 6E58 4B45             text 'KEY?'
     6E5A 593F     
0230 6E5C 6E5E     keyq    data $+2
0231 6E5E 06A0  32         bl @keyqsr                  ; call as subroutine
     6E60 6E64     
0232 6E62 045C  20         b *next
0233 6E64 D820  46 keyqsr  movb @keydev,@>8374         ; set keyboard to scan
     6E66 A024     
     6E68 8374     
0234 6E6A 02E0  18         lwpi >83e0                  ; use gpl workspace
     6E6C 83E0     
0235 6E6E 06A0  28         bl @>000e                   ; call keyboard scanning routine
     6E70 000E     
0236 6E72 02E0  18         lwpi wkspc                  ; restore to our workspace
     6E74 8300     
0237 6E76 D1E0  30         movb @keyin,r7              ; a new key was pressed: get ascii code in r7 msb
     6E78 8375     
0238 6E7A 0887  32         sra r7,8                    ; move to low byte
0239 6E7C 0644  14         dect stack                  ; make space on stack
0240 6E7E C507  30         mov r7,*stack               ; place value on stack
0241 6E80 C80C  30         mov r12,@>83d6              ; defeat auto screen blanking
     6E82 83D6     
     **** ****     > RT
0001 6E84 045B  20        b * r11
                   < 0-09-Console.asm
0243               ;]
0244               
0245               ;[ CR           --                            M,79            "c-r"
0246               ; Displays a carriage-return and line-feed or equivalent operation.
0247 6E86 6E54     crh     data keyqh,2
     6E88 0002     
0248 6E8A 4352             text 'CR'
0249 6E8C 6E8E     cr      data $+2
0250 6E8E C24C  18         mov next,r9             ; return address if we take the jump to scrlup
0251 6E90 04E0  34         clr @scrx                   ; clear cursor x coordinate
     6E92 A02A     
0252 6E94 05A0  34         inc @scry                   ; move to next screen row
     6E96 A02C     
0253 6E98 8820  50         c @scry,@ymax               ; have we hit the bottom of the screen?
     6E9A A02C     
     6E9C A030     
0254 6E9E 1301  14         jeq scrlup                  ; if yes, then scroll the screen
0255 6EA0 045C  20 crexit  b *next                     ; NEXT
0256               ;]
0257               
0258               ; Scroll screen up by one line. Used by EMIT and CR to scroll the screen up if
0259               ; necessary (sub-routine, not a FORTH word).
0260 6EA2 C220  34 scrlup  mov @noscrl,r8              ; test NOSCROLL
     6EA4 A028     
0261 6EA6 1333  14         jeq scrlno                  ; scrolling is supressed
0262 6EA8 0620  34         dec @scrY                   ; clip y coordinate to 23
     6EAA A02C     
0263 6EAC C220  34         mov @here,r8
     6EAE A048     
0264 6EB0 0228  22         ai r8,4
     6EB2 0004     
0265 6EB4 0206  20         li r6,23                    ; 23 lines to shift
     6EB6 0017     
0266 6EB8 04C0  14         clr r0                      ; screen address
0267 6EBA A020  34 sclup_  a @xmax,r0                  ; move down one line
     6EBC A02E     
0268 6EBE C048  18         mov r8,r1                   ; address of buffer to store in
0269 6EC0 C0A0  34         mov @xmax,r2                ; number of bytes to store in the screen
     6EC2 A02E     
0270                                                   ; line buffer
0271 6EC4 06A0  32         bl @vmbr                    ; read screen data into buffer
     6EC6 7F86     
0272 6EC8 0520  34         neg @xmax                   ; set x negative
     6ECA A02E     
0273 6ECC A020  34         a @xmax,r0                  ; move up one line
     6ECE A02E     
0274 6ED0 0520  34         neg @xmax                   ; restore x to positive
     6ED2 A02E     
0275 6ED4 C0A0  34         mov @xmax,r2                ; number of bytes to write
     6ED6 A02E     
0276 6ED8 C048  18         mov r8,r1                   ; address of screen buffer
0277 6EDA 06A0  32         bl @vmbw                    ; write buffer to screen
     6EDC 7FC6     
0278 6EDE A020  34         a @xmax,r0                  ; move down a line
     6EE0 A02E     
0279 6EE2 0606  14         dec r6                      ; decrement number of lines left to shift
0280 6EE4 16EA  14         jne sclup_                  ; repeat if not finished
0281 6EE6 C0A0  34         mov @here,r2
     6EE8 A048     
0282 6EEA 0222  22         ai r2,4
     6EEC 0004     
0283 6EEE C1A0  34         mov @xmax,r6                ; screen width
     6EF0 A02E     
0284 6EF2 0201  20         li r1,>2020                 ; two space characters
     6EF4 2020     
0285 6EF6 CC81  34 blnkln  mov r1,*r2+                 ; write two spaces to the buffer
0286 6EF8 0646  14         dect r6                     ; decrement character count
0287 6EFA 16FD  14         jne blnkln                  ; loop if not finished
0288 6EFC C060  34         mov @here,r1
     6EFE A048     
0289 6F00 0221  22         ai r1,4
     6F02 0004     
0290 6F04 C0A0  34         mov @xmax,r2                ; number of bytes to write in r2
     6F06 A02E     
0291 6F08 06A0  32         bl @vmbw                    ; write blank line
     6F0A 7FC6     
0292 6F0C 0459  20         b *r9                       ; return
0293 6F0E 04E0  34 scrlno  clr @scrY                   ; scrolling is supressed, so zero Y
     6F10 A02C     
0294 6F12 04E0  34         clr @scrX                   ; and x
     6F14 A02A     
0295 6F16 0459  20         b *r9                       ; and return
0296               
0297               ; compute cursor position. common utility routine.
0298               ; used by EMIT and the cursor flash routine in KEY
0299 6F18 C020  34 ccp     mov @scry,r0                ; y coordinate of screen in r0
     6F1A A02C     
0300 6F1C C060  34         mov @xmax,r1                ; horizontal screen size in r1
     6F1E A02E     
0301 6F20 3840  58         mpy r0,r1                   ; multiply y by horizontal screen size.
0302                                                   ; result in r2
0303 6F22 C002  18         mov r2,r0                   ; move to r0 for vdp access routines
0304 6F24 A020  34         a @scrX,r0                  ; add x coordinate
     6F26 A02A     
     **** ****     > RT
0001 6F28 045B  20        b * r11
                   < 0-09-Console.asm
0306               
0307               ;[ BYE ( -- )
0308               ; resets the console back to the title screen
0309 6F2A 6E86     byeh    data crh,3
     6F2C 0003     
0310 6F2E 4259             text 'BYE '
     6F30 4520     
0311 6F32 6F34     bye     data $+2
0312 6F34 04E0  26         clr @isr                    ; remove isr hook
     6F36 83C4     
0313 6F38 0420  42         blwp @0                     ; cold reset console. So long, old pal.
     6F3A 0000     
0314               ;]
                   < build.asm
0021                   copy "./bank0/0-10-Compilation.asm"
     **** ****     > ./bank0/0-10-Compilation.asm
0001               ;   _____                       _ _ _              __          __            _
0002               ;  / ____|                     (_) (_)             \ \        / /           | |
0003               ; | |      ___  _ __ ___  _ __  _| |_ _ __   __ _   \ \  /\  / /___  _ __ __| |___
0004               ; | |     / _ \| '_ ` _ \| '_ \| | | | '_ \ / _` |   \ \/  \/ // _ \| '__/ _` / __|
0005               ; | |____| (_) | | | | | | |_) | | | | | | | (_| |    \  /\  /| (_) | | | (_| \__ \
0006               ;  \_____|\___/|_| |_| |_| .__/|_|_|_|_| |_|\__, |     \/  \/  \___/|_|  \__,_|___/
0007               ;                        | |                 __/ |
0008               ;                        |_|                |___/
0009               ; Compilation words...
0010               
0011               ;[ HEADER ( TIB:string -- )
0012               ; creates a word (from the input source) in the dictionary and links the
0013               ; dictionary
0014               ; *********************************************************************
0015               ; NOTE: FOR VERSIONS 1.2.1 ONWARDS:
0016               ; HEADER NOW DOES A "BL WORD" SEQUENCE INTERNALLY.
0017               ; NO NEED TO DO A "BL WORD HEADER" SEQUENCE IN CODE THAT USES HEADER.
0018               ; HEADER NOW DOES IT FOR YOU.
0019               ; *********************************************************************
0020 6F3C 6F2A     headrh  data byeh,6
     6F3E 0006     
0021 6F40 4845             text 'HEADER'
     6F42 4144     
     6F44 4552     
0022 6F46 8320     header  data docol
0023 6F48 70F2             data align          ; ensure HERE is aligned
0024 6F4A 72B2             data spword         ; get a word from the input source
0025 6F4C 6F50             data headr          ; create and link new dictionary entry
0026 6F4E 832C             data exit
0027 6F50 6F52     headr   data $+2
0028 6F52 06A0  28         bl @bank1
     6F54 8332     
0029 6F56 6D0E             data _headr         ; see 1-09-Compilation.a99
0030               ;]
0031               
0032               ;[ MARKER ( -- )
0033               ; creates a marker in the dictionary that, when executed, removes all words
0034               ; following the marker from the dictionary, and resets the compilation address
0035               ; to the first free address following the marker.
0036               ; Example:
0037               ; MARKER RESET      \ create a marker called reset
0038               ; : test1 1 2 3 ;   \ define some words
0039               ; : test2 4 5 6 ;
0040               ; : test3 7 8 9 ;
0041               ; RESET
0042               ; In the example above, upon execution of RESET, the words test1 test2 & test3
0043               ; are removed from the dictionary, LATEST points to the link field of RESET and
0044               ; H points to the next cell after the end of the definition of RESET.
0045               ; FFAIHM & FFAILM are also updated.
0046 6F58 6F3C     markrh  data headrh,6
     6F5A 0006     
0047 6F5C 4D41             text 'MARKER'
     6F5E 524B     
     6F60 4552     
0048 6F62 8320     markr   data docol
0049 6F64 6F46             data header
0050 6F66 7262             data compile,docol
     6F68 8320     
0051 6F6A 7262             data compile,domark
     6F6C 6F88     
0052 6F6E 76CE             data lates_,fetch,comma
     6F70 6822     
     6F72 70D2     
0053 6F74 77FE             data ghere,lit,6,add,comma
     6F76 70B8     
     6F78 0006     
     6F7A 6310     
     6F7C 70D2     
0054                       ; branch to code in FORGET to force update of FFAILM & FFAIHM...
0055 6F7E 7262             data compile,align
     6F80 70F2     
0056 6F82 7262             data compile,exit
     6F84 832C     
0057 6F86 832C             data exit
0058 6F88 6F8A     domark  data $+2
0059 6F8A C833  50         mov *pc+,@latest
     6F8C A046     
0060 6F8E C833  50         mov *pc+,@here
     6F90 A048     
0061 6F92 045C  20         b *next
0062               ;]
0063               
0064               ;[ CREATE       --                            M,79
0065               ; A defining word executed in the form:
0066               ;       CREATE <name>
0067               ; Creates a dictionary entry for <name>.  After <name> is created, the next
0068               ; available dictionary location is the first byte of <name>'s parameter field.
0069               ; When <name> is subsequently executed, the address of the first byte of
0070               ; <name>'s parameter field is left on the stack.
0071               ; CREATE does not allocate space in <name>'s parameter field.
0072 6F94 6F58     creath  data markrh,6
     6F96 0006     
0073 6F98 4352             text 'CREATE'
     6F9A 4541     
     6F9C 5445     
0074 6F9E 8320     create  data docol
0075 6FA0 6F46             data header                 ; create and link dictionary entry
0076 6FA2 7262             data compile,crtime         ; compile create's run-time to CREATEd CFA
     6FA4 6FA8     
0077 6FA6 832C             data exit
0078               
0079               ; the run-time behaviour of all words created with CREATE is to leave their PFA
0080               ; on the stack... Children of CREATE invoke the following code, called by the
0081               ; inner interpreter:
0082 6FA8 0644  14 crtime  dect stack                   ; make room for PFA
0083 6FAA C506  30         mov r6,*stack                ; place PFA on stack
0084 6FAC 045C  20         b *next
0085               ;]
0086               
0087               ;[ patches CFA of last created word with address of run-time code of parent.
0088               ; address contained in PATCH. Used by DOES>
0089 6FAE 6FB0     altcfa  data $+2
0090 6FB0 C020  34         mov   @patch,r0         ; CFA of most recent definition
     6FB2 A06C     
0091 6FB4 C403  30         mov   pc,*r0            ; patch it with parent's code field
0092 6FB6 C0F5  30         mov   *rstack+,pc       ; in-line EXIT that "ends" the definition
0093 6FB8 045C  20         b     *next             ; into which altcfa is compiled
0094               ;]
0095               
0096               ;[ DODOES
0097               ; dynamically compiles instructions (for run-time transition from child to
0098               ; parent for DOES> words) into the parent DOES> word.
0099 6FBA 8320     dodoes  data docol
0100 6FBC 7262             data compile,>0644      ; compile: "dect stack" instruction
     6FBE 0644     
0101 6FC0 7262             data compile,>C506      ; compile: "mov r6,*stack" instruction
     6FC2 C506     
0102 6FC4 7262             data compile,>0645      ; compile: "dect rstack" instruction
     6FC6 0645     
0103 6FC8 7262             data compile,>C543      ; compile: "mov pc,*rstack" instruction
     6FCA C543     
0104 6FCC 7262             data compile,>0203      ; compile: "li pc,xxx" instruction
     6FCE 0203     
0105                       ; calculate & compile address of xxx for li instruction:
0106 6FD0 77FE             data ghere,lit,4,add,comma
     6FD2 70B8     
     6FD4 0004     
     6FD6 6310     
     6FD8 70D2     
0107 6FDA 7262             data compile,>045C      ; compile "b *next" instruction
     6FDC 045C     
0108 6FDE 832C             data exit
0109               ;]
0110               
0111               ;[ DOES>        -- addr                       C,I,83         "does"
0112               ;                 --   (compiling)
0113               ; Defines the execution-time action of a word created by a high-level defining
0114               ; word.
0115               ; Used in the form:
0116               ;       : <namex> ... <create> ... DOES> ... ;
0117               ; and then
0118               ;       <namex> <name>
0119               ; where <create> is CREATE or any user defined word which executes CREATE.
0120               ;
0121               ; Marks the termination of the defining part of the defining word <namex> and
0122               ; then begins the definition of the execution-time action for words that will
0123               ; later be defined by <namex>.  When <name> is later executed, the address of
0124               ; <name>'s parameter field is placed on the stack and then the sequence of words
0125               ; between DOES> and ; are executed.
0126 6FE0 6F94     doesh   data creath,immed+5
     6FE2 8005     
0127 6FE4 444F             text 'DOES> '
     6FE6 4553     
     6FE8 3E20     
0128 6FEA 8320     does    data docol,align,compile,altcfa,dodoes,exit
     6FEC 70F2     
     6FEE 7262     
     6FF0 6FAE     
     6FF2 6FBA     
     6FF4 832C     
0129               ;]
0130               
0131               ;[ CONSTANT     16b --                        M,83
0132               ; A defining word executed in the form:
0133               ;       16b CONSTANT <name>
0134               ; Creates a dictionary entry for <name> so that when <name> is later executed,
0135               ; 16b will be left on the stack.
0136 6FF6 6FE0     consth  data doesh,8
     6FF8 0008     
0137 6FFA 434F             text 'CONSTANT'
     6FFC 4E53     
     6FFE 5441     
     7000 4E54     
0138 7002 8320     const   data docol
0139 7004 6F46             data header                     ; create and link dictionary entry
0140 7006 7262             data compile,docon              ; compile reference to docon
     7008 700E     
0141 700A 70D2             data comma                      ; compile in the value of constant as an
0142                                                       ; argument to docon
0143 700C 832C             data exit
0144               
0145               ; children of constant run this code...
0146 700E 0644  14 docon   dect stack                      ; make space on the data stack
0147 7010 C516  38         mov *r6,*stack                  ; push payload to the stack
0148 7012 045C  20         b *next
0149               ;]
0150               
0151               ;[ VARIABLE     --                            M,79
0152               ; A defining word executed in the form:
0153               ;       VARIABLE <name>
0154               ; A dictionary entry for <name> is created and two bytes are ALLOTted in its
0155               ; parameter field.
0156               ; This parameter field is to be used for contents of the variable.
0157               ; When <name> is later executed, the address of its parameter field is placed
0158               ; on the stack.
0159 7014 6FF6     varh    data consth,8
     7016 0008     
0160 7018 5641             text 'VARIABLE'
     701A 5249     
     701C 4142     
     701E 4C45     
0161 7020 8320     var     data docol,create,lit0,comma,exit
     7022 6F9E     
     7024 6082     
     7026 70D2     
     7028 832C     
0162               ;]
0163               
0164               ;[ VALUE ( n -- )
0165               ; A "value" is actually a variable, but with more friendly syntax. VALUEs work
0166               ; in conjunction with TO and +TO. (Perversely, they are implemented internally
0167               ; using constants!)
0168               ; A value can be initialised with a value at the time of creation:
0169               ; 10 VALUE TEN - creates a word that pushes 10 to the stack when executed.
0170               ; Note how the value was created and intialised at the same time. Using
0171               ; standard variables, we would have to do:
0172               ; VARIABLE TEN  10 TEN ! - two distinct steps.
0173               ; To get the value of the value, just execute it:
0174               ; 10 VALUE TEN  TEN . 10 ok
0175               ; Values, once created can have their values changed with the TO command:
0176               ; 100 VALUE DELAY (creates a VALUE called delay with the value of 100)
0177               ; 55 TO DELAY (changes the value of DELAY to 55)
0178               ; Using standard variables, we would have to do:
0179               ; VARIABLE DELAY
0180               ; 100 DELAY !
0181               ; 55 DELAY !
0182 702A 7014     valueh  data varh,5
     702C 0005     
0183 702E 5641             text 'VALUE '
     7030 4C55     
     7032 4520     
0184 7034 8320     value   data docol,const,exit
     7036 7002     
     7038 832C     
0185                       ; no coolness here, it's just a constant, the coolness is in TO & +TO
0186               ;]
0187               
0188               ;[ TO ( n -- )
0189               ; Allows the value of an already created VALUE to be changed:
0190               ; 100 VALUE SETPOINT (create a SETPOINT value with the value of 100)
0191               ; 65 TO SETPOINT (change SETPOINTs value to 65)
0192 703A 702A     toh     data valueh,immed+2
     703C 8002     
0193 703E 544F             text 'TO'
0194 7040 8320             data docol,toutil,zbrnch,tohx
     7042 7092     
     7044 65E8     
     7046 7050     
0195                       ; runs if in compile state. In compile state, a number will be on the
0196                       ; stack, so compile a reference to doto
0197 7048 7262             data compile,doto       ; compile reference to "do to"
     704A 705C     
0198 704C 70D2             data comma              ; compile body address
0199 704E 832C             data exit
0200               
0201                       ; runs in interpret state - write the value on the stack to the body
0202                       ; address....
0203 7050 6844     tohx    data store,exit
     7052 832C     
0204               
0205 7054 703A     dotoh   data toh,4
     7056 0004     
0206 7058 2854             text '(TO)'
     705A 4F29     
0207 705C 705E     doto    data $+2
0208 705E C033  30         mov *pc+,r0         ; get in-line body address
0209 7060 C434  42         mov *stack+,*r0     ; move tos to values' body
0210 7062 045C  20         b *next
0211               ;]
0212               
0213               ;[ +TO ( n -- )
0214               ; Similar to TO above, but adds the value on the stack to the value.
0215               ; 100 VALUE SETPOINT (create a value called SETPOINT with the value 100)
0216               ; 25 +TO SETPOINT (changes SETPOINTs value to 125)
0217 7064 7054     addtoh  data dotoh,immed+3
     7066 8003     
0218 7068 2B54             text '+TO '
     706A 4F20     
0219 706C 8320             data docol,ToUtil,zbrnch,addtox
     706E 7092     
     7070 65E8     
     7072 707C     
0220                       ; runs if in compile state. In compile state, a number will be on the
0221                       ; stack, so compile a reference to dopto ("do plus-to")
0222 7074 7262             data compile,dopto      ; compile reference to "do plus-to"
     7076 708A     
0223 7078 70D2             data comma              ; compile body address
0224 707A 832C             data exit
0225                       ; runs in interpret state - write the value on the stack to the body
0226                       ; address....
0227 707C 6852     addtox  data stadd,exit
     707E 832C     
0228               
0229 7080 7064     ptoh    data addtoh,5
     7082 0005     
0230 7084 282B             text '(+TO) '
     7086 544F     
     7088 2920     
0231 708A 708C     dopto   data $+2
0232 708C C033  30         mov *pc+,r0         ; get in-line body address
0233 708E A434  42         a *stack+,*r0       ; pop and add tos to value in the values' body
0234 7090 045C  20         b *next
0235               ;]
0236               
0237               ; common routine to get body and state. Used by TO and +TO save a few bytes by
0238               ; making it common, and no run time penalty since this bit of code executes at
0239               ; compile time.
0240               ; ( -- body state)
0241 7092 8320     ToUtil  data docol,getword,tobody,state_,fetch,exit
     7094 72BA     
     7096 6C14     
     7098 76BC     
     709A 6822     
     709C 832C     
0242               
0243               ;[ ALLOT        w --                          79
0244               ; Allocates w bytes in the dictionary.
0245               ; The address of the next available dictionary entry is updated accordingly.
0246 709E 7080     alloth  data ptoh,5
     70A0 0005     
0247 70A2 414C             text 'ALLOT '
     70A4 4C4F     
     70A6 5420     
0248 70A8 70AA     allot   data $+2
0249 70AA 06A0  28         bl @bank1
     70AC 8332     
0250 70AE 6DA8             data _allot         ; see 1-09-Compilation.a99
0251               ;]
0252               
0253               ;[ LIT ( -- n )
0254               ; places the literal number on the datastack
0255 70B0 709E     lith    data alloth,3
     70B2 0003     
0256 70B4 4C49             text 'LIT '
     70B6 5420     
0257 70B8 8368     lit     data _lit           ; runs from 16-bit ram
0258               ;]
0259               
0260               ;[ LITERAL      -- 16b                        C,I,79
0261               ; 16b --   (compiling)
0262               ; Typically used in the form:
0263               ;       [ 16b ] LITERAL
0264               ; Compiles a system dependent operation so that when later executed,
0265               ; 16b will be left on the stack.
0266 70BA 70B0     literh  data lith,immed+7
     70BC 8007     
0267 70BE 4C49             text 'LITERAL '
     70C0 5445     
     70C2 5241     
     70C4 4C20     
0268 70C6 8320     litral  data docol
0269 70C8 60AA             data clc                    ; compile lit and value from stack
0270 70CA 832C             data exit
0271               ;]
0272               
0273               ;[ ,            16b --                        79            "comma"
0274               ; ALLOT space for 16b then store 16b at HERE 2- .
0275 70CC 70BA     commah  data literh,1
     70CE 0001     
0276 70D0 2C20             text ', '
0277 70D2 70D4     comma   data $+2
0278 70D4 06A0  28         bl @bank1
     70D6 8332     
0279 70D8 6D4C             data _comma         ; see 1-09-Compilation.a99
0280               ;]
0281               
0282               ;[ C, (COMMA) ( value -- )
0283               ; appends an 8 bit value, from the least significant byte of TOS to HERE.
0284               ; Here is incremented by ONE BYTE, not one WORD.
0285               ; For safety, use ALIGN to align HERE to a word boundary afterwards.
0286 70DA 70CC     ccommh  data commah,2
     70DC 0002     
0287 70DE 432C             text 'C,'
0288 70E0 70E2     ccomma  data $+2
0289 70E2 06A0  28         bl @bank1
     70E4 8332     
0290 70E6 6D6A             data _comab         ; see 1-09-Compilation.a99
0291               ;]
0292               
0293               ;[ ALIGN ( -- )
0294               ; Aligns HERE to an even word boundary by rounding up if required
0295               ; Call it after using C!
0296 70E8 70DA     alignh  data ccommh,5
     70EA 0005     
0297 70EC 414C             text 'ALIGN '
     70EE 4947     
     70F0 4E20     
0298 70F2 70F4     align   data $+2
0299 70F4 06A0  28         bl @bank1
     70F6 8332     
0300 70F8 6D7A             data _align         ; see 1-09-Compilation.a99
0301               ;]
0302               
0303               ;[ [            --                            I,79   "left-bracket"
0304               ;                 --   (compiling)
0305               ; Sets interpret state.
0306               ; The text from the input stream is subsequently interpreted.
0307               ; For typical usage see LITERAL . See:  ]
0308 70FA 70E8     lbrakh  data alignh,immed+1
     70FC 8001     
0309 70FE 5B20             text '[ '
0310 7100 7102     lbrack  data $+2
0311 7102 04E0  34         clr @_state                 ; set state to 0
     7104 A04A     
0312 7106 045C  20         b *next
0313               ;]
0314               
0315               ;[ ]            --                            79    "right-bracket"
0316               ; Sets compilation state.
0317               ; The text from the input stream is subsequently compiled.
0318               ; For typical usage see LITERAL . See:  [
0319 7108 70FA     rbrakh  data lbrakh,1
     710A 0001     
0320 710C 5D20             text '] '
0321 710E 7110     rbrack  data $+2
0322 7110 0720  34         seto @_state                ; set state to non zero
     7112 A04A     
0323 7114 045C  20         b *next
0324               ;]
0325               
0326               ;[ :            -- sys                        M,79          "colon"
0327               ; A defining word executed in the form:
0328               ;       : <name> ... ;
0329               ; Create a word definition for <name> in the compilation vocabulary and set
0330               ; compilation state.
0331               ; The search order is changed so that the first vocabulary in the search order
0332               ; is changed so that the first vocabulary in the search order is replaced by the
0333               ; compilation vocabulary.
0334               ; The compilation vocabulary is unchanged.  The text from the input stream is
0335               ; subsequently compiled.
0336               ; <name> is called a "colon definition".
0337               ; The newly created word definition for <name> cannot be found in the dictionary
0338               ; until the corresponding ; or ; ;CODE is successfully processed.
0339               ; An error condition exists if a word is not found and cannot be converted to a
0340               ; number or if, during compilation from mass storage, the input stream is
0341               ; exhausted before encountering ; or ;CODE.
0342               ; sys is balanced with its corresponding ;
0343               ; See: "compilation"  "9.4 Compilation"
0344 7116 7108     colonh  data rbrakh,1
     7118 0001     
0345 711A 3A20             text ': '
0346 711C 8320     colon   data docol
0347                   ; reset error detection reference counts....
0348 711E 70B8             data lit,ifcnt,lit,sal-ifcnt,lit0,fill
     7120 A07E     
     7122 70B8     
     7124 000C     
     7126 6082     
     7128 6972     
0349                   ; begin compilation...
0350 712A 76FC             data in_,fetch              ; save >IN
     712C 6822     
0351 712E 6F46             data header                 ; create entry and link dictionary
0352 7130 76CE             data lates_,fetch,hideme    ; set *this* entry as hidden
     7132 6822     
     7134 721C     
0353 7136 76FC             data in_,store              ; restore >IN
     7138 6844     
0354 713A 72B2             data spword,find            ; see if word already exists.
     713C 6ADA     
0355                                                   ; FIND won't find *this* instance!
0356 713E 70B8             data lit,temp,store,drop    ; store result in temp. used later by ;
     7140 A072     
     7142 6844     
     7144 6170     
0357 7146 7262             data compile,docol          ; compile DOCOL
     7148 8320     
0358 714A 710E             data rbrack                 ; switch on compile mode
0359 714C 832C             data exit
0360               
0361               ;]
0362               
0363               ;[ CODE: ( -- )
0364               ; Defines a machine code word.
0365 714E 7116     codeh   data colonh,5
     7150 0005     
0366 7152 434F             text 'CODE: '
     7154 4445     
     7156 3A20     
0367 7158 8320             data docol
0368 715A 6F46             data header
0369 715C 77FE             data ghere,plus2,comma
     715E 62C0     
     7160 70D2     
0370 7162 609A             data litm1,lit,coding,store
     7164 70B8     
     7166 A06A     
     7168 6844     
0371 716A 832C             data exit
0372               ;]
0373               
0374               ;[ ;CODE ( -- )
0375               ; ends a machine code definition
0376 716C 714E     ecodeh  data codeh,immed+5
     716E 8005     
0377 7170 3B43             text ';CODE '
     7172 4F44     
     7174 4520     
0378 7176 8320     ecode   data docol
0379 7178 70B8             data lit,>045c,comma,lit,coding,store0
     717A 045C     
     717C 70D2     
     717E 70B8     
     7180 A06A     
     7182 6884     
0380 7184 832C             data exit
0381               ;]
0382               
0383               ;[ ;            --                            C,I,79   "semi-colon"
0384               ;           sys --   (compiling)
0385               ; Stops compilation of a colon definition, allows the <name> of this colon
0386               ; definition to be found in the dictionary, sets interpret state and compiles
0387               ; EXIT (or a system dependent word which performs an equivalent function).
0388               ; sys is balanced with its corresponding : .
0389               ; See:  EXIT  :  "stack, return"  "9.4 Compilation"
0390 7186 716C     semih   data ecodeh,immed+1
     7188 8001     
0391 718A 3B20             text '; '
0392 718C 8320     semi    data docol
0393 718E 7262             data compile,exit           ; compile EXIT
     7190 832C     
0394 7192 76CE             data lates_,fetch,hideme    ; un-hide the word
     7194 6822     
     7196 721C     
0395               
0396                       ; flag to indicate no unbalanced errors detected...
0397 7198 6082             data lit0
0398               
0399                       ; check IF...THEN reference counts, error if count>0...
0400 719A 70B8             data lit,ifcnt,fetch,zbrnch,doerr
     719C A07E     
     719E 6822     
     71A0 65E8     
     71A2 71AA     
0401 71A4 7200             data isserr
0402 71A6 60B4             data toterm,iferr
     71A8 7542     
0403               
0404                   ; check DO...LOOP reference counts, error if count>0...
0405 71AA 70B8     doerr   data lit,docnt,fetch,zbrnch,caserr
     71AC A080     
     71AE 6822     
     71B0 65E8     
     71B2 71BA     
0406 71B4 7200             data isserr
0407 71B6 60B4             data toterm,doertx
     71B8 754A     
0408               
0409                   ; check CASE...ENDCASE reference counts, error if count>0
0410 71BA 70B8     caserr  data lit,cascnt,fetch,zbrnch,oferr
     71BC A084     
     71BE 6822     
     71C0 65E8     
     71C2 71CA     
0411 71C4 7200             data isserr
0412 71C6 60B4             data toterm,castxt
     71C8 7554     
0413               
0414                   ; check OF...ENDOF reference counts, error if count>0
0415 71CA 70B8     oferr   data lit,ofcnt,fetch,zbrnch,begerr
     71CC A086     
     71CE 6822     
     71D0 65E8     
     71D2 71DA     
0416 71D4 7200             data isserr
0417 71D6 60B4             data toterm,oftxt
     71D8 7561     
0418               
0419                   ; check BEGIN/UNTIL/REPEAT reference counts, error if count>0
0420 71DA 70B8     begerr  data lit,begcnt,fetch,zbrnch,allfin
     71DC A088     
     71DE 6822     
     71E0 65E8     
     71E2 71EA     
0421 71E4 7200             data isserr
0422 71E6 60B4             data toterm,begtxt
     71E8 756A     
0423               
0424                   ; abort if one of the above error conditions exist
0425 71EA 65E8     allfin  data zbrnch,semi2 ; test unbalanced error flag
     71EC 71F0     
0426 71EE 7460             data ab0rt
0427               
0428                   ; issue warning if this word is a re-definition...
0429 71F0 70B8     semi2   data lit,temp,fetch,zbrnch,semi3  ; skip if not a redefinition
     71F2 A072     
     71F4 6822     
     71F6 65E8     
     71F8 71FC     
0430 71FA 74AE             data rdferr                       ; else issue warning if enabled
0431                   ; end of colon definition, reset compile state...
0432 71FC 7100     semi3   data lbrack                       ; go into interpret mode
0433 71FE 832C             data exit
0434               
0435 7200 8320     isserr  data docol,cr,error,toterm,intxt,colnam,unbal
     7202 6E8C     
     7204 751C     
     7206 60B4     
     7208 7599     
     720A 74C4     
     720C 74A6     
0436 720E 62AC             data plus1 ; set unbalanced error detect to non-zero value
0437 7210 832C             data exit
0438               ;]
0439               
0440               ;[ HIDDEN ( dictionary_address -- )
0441               ; toggles the hidden attribute on the dictionary entry
0442               ; normally you would hide a word after defining it with: LATEST @ HIDDEN
0443 7212 7186     hidh    data semih,6
     7214 0006     
0444 7216 4849             text 'HIDDEN'
     7218 4444     
     721A 454E     
0445 721C 721E     hideme  data $+2
0446 721E 06A0  28         bl @bank1
     7220 8332     
0447 7222 6D8A             data _hide
0448               ;]
0449               
0450               ;[ IMMEDIATE    --                            79
0451               ; Marks the most recently created dictionary entry as a word which will be
0452               ; executed when encountered during compilation rather than compiled.
0453 7224 7212     immh    data hidh,9
     7226 0009     
0454 7228 494D             text 'IMMEDIATE '
     722A 4D45     
     722C 4449     
     722E 4154     
     7230 4520     
0455 7232 7234     imm     data $+2
0456 7234 06A0  28         bl @bank1
     7236 8332     
0457 7238 6D98             data _imm
0458               ;]
0459               
0460               ;[ [']          -- addr                       C,I,M,83    "bracket-tick"
0461               ;                 --   (compiling)
0462               ; Used in the form:
0463               ;       ['] <name>
0464               ; Compiles the compilation address addr of <name> as a literal.
0465               ; When the colon definition is later executed addr is left on the stack.
0466               ; An error condition exists if <name> is not found in the currently active
0467               ; search order.  See:  LITERAL
0468 723A 7224     tickh   data immh,immed+3
     723C 8003     
0469 723E 5B27             text '[''] '
     7240 5D20     
0470 7242 8320     tick    data docol,getword,litral,exit
     7244 72BA     
     7246 70C6     
     7248 832C     
0471               
0472               ;]
0473               
0474               ;[ '            -- addr                       M,83           "tick"
0475               ; Used in the form:
0476               ;       ' <name>
0477               ; addr is the compilation address of <name>.
0478               ; An error condition exists if <name> is not found in the currently active
0479               ; search order.
0480 724A 723A     tick2h  data tickh,1
     724C 0001     
0481 724E 2720             text ''' '
0482 7250 8320     tick2   data docol,getword,exit
     7252 72BA     
     7254 832C     
0483               ;]
0484               
0485               ;[ COMPILE      --                            C,83
0486               ; Typically used in the form:
0487               ;       : <name> ... COMPILE <namex> ... ;
0488               ; When <name> is executed, the compilation address compiled for <namex> is
0489               ; compiled and not executed.
0490               ; <name> is typically immediate and <namex> is typically not immediate.
0491               ; See:  "compilation"
0492 7256 724A     compih  data tick2h,7
     7258 0007     
0493 725A 434F             text 'COMPILE '
     725C 4D50     
     725E 494C     
     7260 4520     
0494 7262 7264     compile data $+2
0495                       ; note: the following line of code MUST be executed from bank 0.
0496                       ; It cannot execute in bank 1 because all the Forth CFAs are in bank 0.
0497 7264 C073  30         mov *pc+,r1                 ; get cfa of next word in thread
0498 7266 06A0  28         bl @bank1                   ; do the rest in bank 1
     7268 8332     
0499 726A 6DB2             data _compil                ; see 1-09-Compilation.a99
0500               ;]
0501               
0502               ;[ [COMPILE]    --                            C,I,M,79    "bracket-compile"
0503               ;                 --   (compiling)
0504               ; Used in the form:
0505               ;       [COMPILE] <name>
0506               ; Forces compilation of the following word <name>.
0507               ; This allows compilation of an immediate word when it would otherwise have been
0508               ; executed.
0509 726C 7256     icomph  data compih,immed+9
     726E 8009     
0510 7270 5B43             text '[COMPILE] '
     7272 4F4D     
     7274 5049     
     7276 4C45     
     7278 5D20     
0511 727A 8320     icomp   data docol
0512 727C 72B2             data spword                 ; get a word from TIB
0513 727E 6ADA             data find,drop              ; find it in the dictionary
     7280 6170     
0514 7282 70D2             data comma                  ; compile the CFA to HERE
0515 7284 832C             data exit
0516               ;]
0517               
0518               ;[ RECURSE ( -- )
0519               ; RECURSE makes a recursive call to the current word that is being compiled.
0520               ; Normally while a word is being compiled, it is marked HIDDEN so that
0521               ; references to the same word within are calls to the previous definition of
0522               ; the word. However we still have access to the word which we are currently
0523               ; compiling through the LATEST pointer so we can use that to compile a
0524               ; recursive call.
0525 7286 726C     recrsh  data icomph,immed+7
     7288 8007     
0526 728A 5245             text 'RECURSE '
     728C 4355     
     728E 5253     
     7290 4520     
0527 7292 8320     recurs  data docol
0528 7294 76CE             data lates_,fetch           ; get LATEST on stack
     7296 6822     
0529 7298 6BF4             data cfa                    ; convert to CFA
0530 729A 70D2             data comma                  ; compile it
0531 729C 832C             data exit
0532               ;]
0533               
0534               ;[ EXECUTE      addr --                       79
0535               ; The word definition indicated by addr is executed.
0536               ; An error condition exists if addr is not a compilation address
0537 729E 7286     exeh    data recrsh,7
     72A0 0007     
0538 72A2 4558             text 'EXECUTE '
     72A4 4543     
     72A6 5554     
     72A8 4520     
0539 72AA 72AC     execut  data $+2
0540 72AC C1B4  30         mov *stack+,r6              ; pop addr to r6
0541 72AE C1F6  30         mov *r6+,r7                 ; get cfa
0542 72B0 0457  20         b *r7                       ; execute it
0543               ;]
0544               
0545               ; little utility word to get a word using a space as a delimiter.
0546               ; Saves a few bytes as it is used in multiple places.
0547 72B2 8320     spword  data docol,bl_,word,exit
     72B4 6ACA     
     72B6 6AA4     
     72B8 832C     
0548               
0549               
0550               ; another utility word
0551               ; gets a word from the input stream, finds it in the dictionary.
0552               ; aborts if the word is not found in the dictionary.
0553 72BA 8320     getword data docol
0554 72BC 76FC             data in_,fetch,rspush
     72BE 6822     
     72C0 6282     
0555 72C2 72B2             data spword,find,zbrnch,finderr
     72C4 6ADA     
     72C6 65E8     
     72C8 72D0     
0556 72CA 629E             data rspop,drop
     72CC 6170     
0557 72CE 832C             data exit
0558               
0559 72D0 629E     finderr data rspop,in_,store
     72D2 76FC     
     72D4 6844     
0560 72D6 72B2             data spword,type
     72D8 6C96     
0561 72DA 60B4             data toterm,notick
     72DC 72E4     
0562 72DE 74C4             data colnam
0563 72E0 7460             data ab0rt
0564 72E2 832C             data exit
0565 72E4 0A       notick  byte 10
0566 72E5   20             text ' not found'
     72E6 6E6F     
     72E8 7420     
     72EA 666F     
     72EC 756E     
     72EE 64       
                   < build.asm
0022                   copy "./bank0/0-11-Interpreter.asm"
     **** ****     > ./bank0/0-11-Interpreter.asm
0001               ;  ______         _   _       _____       _                            _
0002               ; |  ____|       | | | |     |_   _|     | |                          | |
0003               ; | |__ ___  _ __| |_| |__     | |  _ __ | |_  ___ _ __ _ __  _ __ ___| |_  ___ _ __
0004               ; |  __/ _ \| '__| __| '_ \    | | | '_ \| __|/ _ \ '__| '_ \| '__/ _ \ __|/ _ \ '__|
0005               ; | | | (_) | |  | |_| | | |  _| |_| | | | |_|  __/ |  | |_) | | |  __/ |_|  __/ |
0006               ; |_|  \___/|_|   \__|_| |_| |_____|_| |_|\__|\___|_|  | .__/|_|  \___|\__|\___|_|
0007               ; The interpreter/compiler                             | |
0008               ;                                                      |_|
0009               
0010               ;[ INTERPRET ( -- )
0011 72F0 729E     inth    data exeh,9                 ; points to execute in Compilation.a99
     72F2 0009     
0012 72F4 494E             text 'INTERPRET '
     72F6 5445     
     72F8 5250     
     72FA 5245     
     72FC 5420     
0013 72FE 8320     interp  data docol
0014 7300 70B8             data lit,intvec,fetch,execut ; get the vector for INTERPRET and call it
     7302 A000     
     7304 6822     
     7306 72AA     
0015 7308 832C             data exit
0016               
0017               ; standard, un-vectored INTERPRET
0018               ; (an alternative interpreter can be installed by patching address INTVEC
0019               ; defined in 0-22.system.a99)
0020 730A 8320     intgo   data docol
0021 730C 72B2     intlp   data spword                 ; (addr len) get a word from TIB
0022 730E 6184             data dup                    ; (addr len len)
0023 7310 65E8             data zbrnch,ok              ; (addr len) if len is zero no identifiable
     7312 7362     
0024                                                   ; word was found, or TIB is empty
0025                   ; check the word identified by WORD, see if it's in the dictionary
0026 7314 75E0             data dup2                   ; (addr len addr len)
0027 7316 6ADA             data find                   ; (addr len cfa flag) see if the word is in
0028                                                   ; dictionary (flag=0 if not found)
0029 7318 6184             data dup                    ; (addr len cfa flag flag)
0030 731A 65E8             data zbrnch,chknum          ; (addr len cfa flag) branch if not found
     731C 734C     
0031               
0032                   ; the word was found in the dictionary.
0033                   ; check STATE to see what to do with it.
0034                       ; (addr len cfa flag)
0035 731E 70B8             data lit,_state,fetch       ; (addr len cfa flag state)
     7320 A04A     
     7322 6822     
0036 7324 65E8             data zbrnch,state0          ; (addr len cfa flag) jump if interpreting
     7326 7338     
0037               
0038                   ; we're in compile mode (state=1)
0039                   ; compile the word, UNLESS the word is immediate
0040 7328 62AC             data plus1                  ; (addr len cfa flag) flag=0 if not
0041                                                   ; immediate
0042 732A 65E8             data zbrnch,nimm            ; (addr len cfa) jump if not immediate
     732C 7344     
0043               
0044                   ; it's immediate - execute it
0045                       ; (addr len cfa)
0046 732E 61D0             data nip,nip                ; clean up stack
     7330 61D0     
0047 7332 72AA             data execut                 ; execute the word
0048 7334 65D6             data branch,intlp           ; repeat
     7336 730C     
0049               
0050                   ; we're interpreting. clean up stack and execute
0051                       ; (addr len cfa flag)
0052 7338 6170     state0  data drop,nip,nip           ; (cfa)
     733A 61D0     
     733C 61D0     
0053 733E 72AA             data execut                 ; (--)
0054 7340 65D6             data branch,intlp           ; repeat
     7342 730C     
0055                   ; word is not immediate - compile it
0056                       ; (addr len cfa)
0057 7344 70D2     nimm    data comma                  ; (addr len)
0058 7346 75D2             data drop2                  ; (--)
0059 7348 65D6             data branch,intlp           ; repeat
     734A 730C     
0060               
0061                   ; no word found in dictionary, check to see if it's a number
0062                   ; on entry: (addr len cfa flag)
0063 734C 75D2     chknum  data drop2                  ; (addr len)
0064 734E 75E0             data dup2                   ; (addr len addr len)
0065 7350 6B78             data number                 ; (addr len number ucc )
0066 7352 65E8             data zbrnch,clean           ; (addr len number ) if ucc=0 then number is
     7354 7366     
0067                                                   ; on the stack
0068                                                   ; clean up stack & check rest of tib
0069               
0070                   ; it's not a number or a word so we don't know what it is, error
0071 7356 6170     ierr    data drop                   ; (addr len) drop double number
0072 7358 751C             data error                  ; type ERROR: to the screen
0073 735A 6C96             data type                   ; echo name of word
0074 735C 749A             data nferr                  ; issue not found error
0075 735E 6E8C             data cr,ab0rt
     7360 7460     
0076               
0077                   ; WORD didn't find anything...
0078                   ; on entry (addr len)
0079 7362 75D2     ok      data drop2                  ; (--) clean up addr & len
0080 7364 832C     okx     data exit
0081               
0082                       ; (addr len number )
0083                       ; at this point the number is on the top of the stack.
0084                       ; It may consist of one OR two words, depends if NUMBER returned a
0085                       ; double or not.
0086                       ; location isdbl shall be non zero if a double was returned
0087               
0088 7366 70B8     clean   data lit,isdbl,fetch        ; double on the stack?
     7368 A054     
     736A 6822     
0089 736C 65E8             data zbrnch,nodbl           ; jump if not
     736E 737C     
0090 7370 618E             data rot,drop,rot,drop      ; clean up and leave 32 bit number on stack
     7372 6170     
     7374 618E     
     7376 6170     
0091 7378 65D6             data branch,clean1
     737A 738C     
0092 737C 61D0     nodbl   data nip,nip                ; clean up and leave 16 bit number on stack
     737E 61D0     
0093               
0094               ; check for CODE: here...
0095 7380 70B8             data lit,coding,fetch,zbrnch,nocode,comma
     7382 A06A     
     7384 6822     
     7386 65E8     
     7388 738C     
     738A 70D2     
0096               
0097               
0098               nocode
0099 738C 70B8     clean1  data lit,_state,fetch       ; ( number state ) get state
     738E A04A     
     7390 6822     
0100 7392 65E8             data zbrnch,intlp           ; ( number ) if not compiling just leave on
     7394 730C     
0101                                                   ; the stack
0102 7396 70B8             data lit,isdbl,fetch,zbrnch,csing ; jump if not compiling a double
     7398 A054     
     739A 6822     
     739C 65E8     
     739E 73A4     
0103 73A0 617A             data swap,clc               ; compile high word of double
     73A2 60AA     
0104 73A4 60AA     csing   data clc                    ; ( ) compile a single or low word of double
0105               
0106 73A6 65D6     intout  data branch,intlp
     73A8 730C     
0107               
0108 73AA 70B8     badblk  data lit,doboot,fetch
     73AC A050     
     73AE 6822     
0109 73B0 65E8             data zbrnch,badbk1
     73B2 73B6     
0110 73B4 7526             data nobootm                ; display no boot message and abort
0111 73B6 6E8C     badbk1  data cr,toterm,blkmsg
     73B8 60B4     
     73BA 75BD     
0112 73BC 7786             data ioerr1,hexdot
     73BE 7870     
0113 73C0 7460     noboot  data ab0rt
0114               ;]
0115               
0116               ;[ STK? ( -- )
0117               ; checks stack for underflow, aborts if underflow, else does nothing
0118 73C2 72F0     stkufh  data inth,4
     73C4 0004     
0119 73C6 5354             text 'STK?'
     73C8 4B3F     
0120 73CA 8320     stkuf   data docol,depth,ltz,zbrnch,stkx
     73CC 623E     
     73CE 64E2     
     73D0 65E8     
     73D2 73DE     
0121 73D4 751C             data error,toterm,stktxt,cr,ab0rt
     73D6 60B4     
     73D8 759E     
     73DA 6E8C     
     73DC 7460     
0122 73DE 832C     stkx    data exit
0123               ;]
0124               
0125               ;[ FORGET       --                            M,83
0126               ; Used in the form:
0127               ;       FORGET <name>
0128               ; If <name> is found in the compilation vocabulary, delete <name> from the
0129               ; dictionary and all words added to the dictionary after <name> regardless of
0130               ; their vocabulary.
0131 73E0 73C2     forgth  data stkufh,6
     73E2 0006     
0132 73E4 464F             text 'FORGET'
     73E6 5247     
     73E8 4554     
0133 73EA 8320     forget  data docol,spword,find,zbrnch,notfnd    ; find word cfa in dictionary
     73EC 72B2     
     73EE 6ADA     
     73F0 65E8     
     73F2 7420     
0134 73F4 6C20             data dfa,dup                            ; get dictionary entry address
     73F6 6184     
0135 73F8 6822             data fetch,lates_,store                 ; update latest
     73FA 76CE     
     73FC 6844     
0136 73FE 76DC             data here_,store                        ; update H
     7400 6844     
0137 7402 70F2             data align          ; force update of appropriate hi or low mem pointer
0138 7404 77FE     forg1   data ghere                              ; save HERE
0139 7406 7740             data ffaih,fetch,here_,store,align      ; force update of FFAIHM
     7408 6822     
     740A 76DC     
     740C 6844     
     740E 70F2     
0140 7410 7756             data ffaml,fetch,here_,store,align      ; force update of FFAILM
     7412 6822     
     7414 76DC     
     7416 6844     
     7418 70F2     
0141 741A 76DC             data here_,store                        ; restore here
     741C 6844     
0142 741E 832C             data exit
0143 7420 6170     notfnd  data drop,exit                          ; take no action if not found
     7422 832C     
0144               ;]
0145               
0146               ;[ ABORT"       flag --                       C,I,83  "abort-quote"
0147               ;                       --   (compiling)
0148               ; Used in the form:
0149               ;       flag ABORT" ccc"
0150               ; When later executed, if flag is true the characters ccc, delimited by "
0151               ; (close-quote), are displayed and then a system dependent error abort sequence,
0152               ; including the function of ABORT , is performed.
0153               ; If flag is false, the flag is dropped and execution continues.
0154               ; The blank following ABORT" is not part of ccc.
0155 7424 73E0     aborth  data forgth,immed+6
     7426 8006     
0156 7428 4142     abttxt  text 'ABORT"'
     742A 4F52     
     742C 5422     
0157 742E 8320     abort   data docol,string,compile,rot,compile,zbrnch,ghere,lit,4,add,comma
     7430 78F0     
     7432 7262     
     7434 618E     
     7436 7262     
     7438 65E8     
     743A 77FE     
     743C 70B8     
     743E 0004     
     7440 6310     
     7442 70D2     
0158 7444 7262             data compile,abort_,compile,drop2,exit
     7446 744E     
     7448 7262     
     744A 75D2     
     744C 832C     
0159 744E 8320     abort_  data docol,type,cr,ab0rt
     7450 6C96     
     7452 6E8C     
     7454 7460     
0160               ;]
0161               
0162               ;[ ABORT                                      79
0163               ; Clears the data stack and performs the function of QUIT.
0164               ; No message is displayed.
0165 7456 7424     ab0rth  data aborth,5
     7458 0005     
0166 745A 4142             text 'ABORT '
     745C 4F52     
     745E 5420     
0167 7460 8320     ab0rt   data docol
0168 7462 6E8C             data cr,s0_,sps,lbrack,clsall
     7464 77A4     
     7466 7698     
     7468 7100     
     746A 7492     
0169 746C 7B50             data blk,store0             ; reset block to 0 in case we're loading
     746E 6884     
0170 7470 70B8             data lit,lstblk,store0
     7472 A1B6     
     7474 6884     
0171 7476 70B8             data lit,tib,tib_,store     ; reset address of terminal input buffer
     7478 3420     
     747A 772E     
     747C 6844     
0172 747E 76FC             data in_,store0             ; set >IN to 0
     7480 6884     
0173 7482 70B8             data lit,80,cpl,store       ; set 80 characters per line
     7484 0050     
     7486 7658     
     7488 6844     
0174 748A 70B8             data lit,source,store0      ; reset EVALUATE source
     748C A05A     
     748E 6884     
0175 7490 6126             data quit                   ; call quit
0176               
0177 7492 7494     clsall  data $+2
0178 7494 06A0  28         bl @bank1                   ; close all open files
     7496 8332     
0179 7498 7BBE             data _clall                 ; see 1-14-File-IO.a99
0180               ;]
0181               
0182               ;[ VTYPE ( vdp_addr len -- )
0183               ; types a string stored in vdp to the screen
0184               ; vtypeh  data ab0rth,5
0185               ;         text 'VTYPE '
0186               ; vtype   data docol,dup,nrot,pad,swap,fvmbr,pad,swap,type,exit
0187               ;]
                   < build.asm
0023                   copy "./bank0/0-12-Errors.asm"
     **** ****     > ./bank0/0-12-Errors.asm
0001               ;  ______                       __  __
0002               ; |  ____|                     |  \/  |
0003               ; | |__   _ __ _ __ ___  _ __  | \  / | ___ ___ ___  __ _  __ _  ___ ___
0004               ; |  __| | '__| '__/ _ \| '__| | |\/| |/ _ | __/ __|/ _` |/ _` |/ _ | __|
0005               ; | |____| |  | | | (_) | |    | |  | |  __|__ \__ \ (_| | (_| |  __|__ \
0006               ; |______|_|  |_|  \___/|_|    |_|  |_|\___|___/___/\__,_|\__, |\___|___/
0007               ; Error reporting routines                                 __/ |
0008               ;                                                         |___/
0009               
0010               
0011                   ; word not found error, used by INTERPRET
0012 749A 8320     nferr   data docol,toterm,nftxt            ; echo 'not found'
     749C 60B4     
     749E 758E     
0013 74A0 608A             data lit1,colnam    ; report name of colon definition if in a colon
     74A2 74C4     
0014                                           ; definition
0015 74A4 832C             data exit
0016               
0017               
0018                   ; type the word 'Unbalanced ' to the terminal... used by ;
0019 74A6 8320     unbal   data docol,toterm,baltxt,exit
     74A8 60B4     
     74AA 7582     
     74AC 832C     
0020               
0021               
0022                   ; warning message. issued when a word is re-defined. used by ;
0023 74AE 8320     rdferr  data docol,warn,fetch,zbrnch,rdfer1
     74B0 771E     
     74B2 6822     
     74B4 65E8     
     74B6 74C2     
0024 74B8 6E8C             data cr,toterm,rdftxt,lit0,colnam  ; issue warning
     74BA 60B4     
     74BC 7570     
     74BE 6082     
     74C0 74C4     
0025 74C2 832C     rdfer1  data exit
0026               
0027               
0028               
0029               
0030                   ; if we are in a colon definition (state!=0) then echo the name of the
0031                   ; colon definition (via LATEST), else skip.
0032 74C4 8320     colnam  data docol
0033 74C6 70B8             data lit,_state,fetch,zbrnch,errxit
     74C8 A04A     
     74CA 6822     
     74CC 65E8     
     74CE 74F4     
0034 74D0 65E8             data zbrnch,colnm1
     74D2 74D8     
0035 74D4 60B4             data toterm,intxt
     74D6 7599     
0036 74D8 70B8     colnm1  data lit,latest,fetch       ; get latest
     74DA A046     
     74DC 6822     
0037 74DE 62C0             data plus2                  ; move to length word
0038 74E0 6184             data dup,fetch              ; copy address, and fetch length
     74E2 6822     
0039 74E4 70B8             data lit,>f,and             ; get length only
     74E6 000F     
     74E8 67C4     
0040 74EA 617A             data swap,plus2             ; compute address of word text
     74EC 62C0     
0041 74EE 617A             data swap,type,space1       ; type the name to the terminal
     74F0 6C96     
     74F2 6D32     
0042               
0043               errxit  ; reports block number if loading...
0044 74F4 7B50             data blk,fetch,zbrnch,repxit
     74F6 6822     
     74F8 65E8     
     74FA 751A     
0045 74FC 60B4             data toterm,blctxt,lit,lstblk,fetch,udot
     74FE 75A9     
     7500 70B8     
     7502 A1B6     
     7504 6822     
     7506 781C     
0046 7508 6E8C             data cr,toterm,linnum,in_,fetch,lit,64,sdiv,dot
     750A 60B4     
     750C 75B4     
     750E 76FC     
     7510 6822     
     7512 70B8     
     7514 0040     
     7516 63B8     
     7518 782C     
0047 751A 832C     repxit  data exit
0048               
0049               
0050                   ; writes "ERROR:" used by all error routines
0051 751C 8320     error   data docol,cr
     751E 6E8C     
0052 7520 60B4             data toterm,errtxt        ; write ERROR:
     7522 757B     
0053 7524 832C             data exit
0054               
0055 7526 8320     nobootm data docol,cr,lit,pabfil,lit,pabnln,chrftc,type
     7528 6E8C     
     752A 70B8     
     752C A18C     
     752E 70B8     
     7530 A18B     
     7532 6860     
     7534 6C96     
0056 7536 60B4             data toterm,nftxt,lit,doboot,store0,ab0rt
     7538 758E     
     753A 70B8     
     753C A050     
     753E 6884     
     7540 7460     
0057               
0058               
0059                   ; text for the various error types trapped by ;...
0060 7542 07       iferr   byte 7
0061 7543   49             text 'IF/THEN'
     7544 462F     
     7546 5448     
     7548 454E     
0062               
0063 754A 09       doertx  byte 9
0064 754B   46             text 'FOR or DO'
     754C 4F52     
     754E 206F     
     7550 7220     
     7552 444F     
0065               
0066 7554 0C       castxt  byte 12
0067 7555   43             text 'CASE/ENDCASE'
     7556 4153     
     7558 452F     
     755A 454E     
     755C 4443     
     755E 4153     
     7560 45       
0068               
0069 7561   08     oftxt   byte 8
0070 7562 4F46             text 'OF/ENDOF'
     7564 2F45     
     7566 4E44     
     7568 4F46     
0071               
0072 756A 05       begtxt  byte 5
0073 756B   42             text 'BEGIN'
     756C 4547     
     756E 494E     
0074               
0075               
0076                   ; general error text...
0077 7570 0A       rdftxt  byte 10
0078 7571   52             text 'Redefined '
     7572 6564     
     7574 6566     
     7576 696E     
     7578 6564     
     757A 20       
0079               
0080 757B   06     errtxt  byte 6
0081 757C A5B2             byte 69+96,82+96,82+96,79+96,82+96,58+96 ; ERROR: in inverse video
     757E B2AF     
     7580 B29A     
0082               
0083 7582 0B       baltxt  byte 11
0084 7583   55             text 'Unbalanced '
     7584 6E62     
     7586 616C     
     7588 616E     
     758A 6365     
     758C 6420     
0085               
0086 758E 0A       nftxt   byte 10
0087 758F   20             text ' not found'
     7590 6E6F     
     7592 7420     
     7594 666F     
     7596 756E     
     7598 64       
0088               
0089 7599   04     intxt   byte 4
0090 759A 2069             text ' in '
     759C 6E20     
0091               
0092 759E 0A       stktxt  byte 10
0093 759F   55             text 'Underflow!'
     75A0 6E64     
     75A2 6572     
     75A4 666C     
     75A6 6F77     
     75A8 21       
0094               
0095 75A9   0A     blctxt  byte 10
0096 75AA 2069             text ' in block '
     75AC 6E20     
     75AE 626C     
     75B0 6F63     
     75B2 6B20     
0097               
0098 75B4 08       linnum  byte 8
0099 75B5   6F             text 'on line '
     75B6 6E20     
     75B8 6C69     
     75BA 6E65     
     75BC 20       
0100               
0101 75BD   0A     blkmsg  byte 10
0102 75BE 494F             text 'IO error #'
     75C0 2065     
     75C2 7272     
     75C4 6F72     
     75C6 2023     
0103               
                   < build.asm
0024                   copy "./bank0/0-13-Double.asm"
     **** ****     > ./bank0/0-13-Double.asm
0001               ;  ____ ___         _     _ _    __          __            _
0002               ; |___ \__ \       | |   (_) |   \ \        / /           | |
0003               ;   __) | ) |______| |__  _| |_   \ \  /\  / /___  _ __ __| |___
0004               ;  |__ < / /|______| '_ \| | __|   \ \/  \/ // _ \| '__/ _` / __|
0005               ;  ___) / /_       | |_) | | |_     \  /\  /| (_) | | | (_| \__ \
0006               ; |____/____|      |_.__/|_|\__|     \/  \/  \___/|_|  \__,_|___/
0007               
0008               ; ########################################
0009               ; Double Number Extension Word Set
0010               ; Words to provide 32 bit math facilities
0011               ; ########################################
0012               ; Note: To save memory, these words may be removed completely and added to a
0013               ; support file on disk.
0014               
0015               ;[ 2DROP ( d -- )
0016 75C8 7456     drop2h  data ab0rth,5
     75CA 0005     
0017 75CC 3244             text '2DROP '
     75CE 524F     
     75D0 5020     
0018 75D2 75D4     drop2   data $+2
0019 75D4 8D34  42         c *stack+,*stack+       ; pop 2 words off the stack (cool, eh?)
0020 75D6 045C  20         b *next
0021               ;]
0022               
0023               ;[ 2DUP ( d -- d d )
0024 75D8 75C8     dup2h   data drop2h,4
     75DA 0004     
0025 75DC 3244             text '2DUP'
     75DE 5550     
0026 75E0 75E2     dup2    data $+2
0027 75E2 06A0  28         bl @bank1
     75E4 8332     
0028 75E6 6B6C             data _dup2              ; see 1-07-Double.a99
0029               ;]
0030               
0031               ; 2SWAP ( a b c d -- c d a b )
                   < build.asm
0025                   copy "./bank0/0-14-Variables.asm"
     **** ****     > ./bank0/0-14-Variables.asm
0001               
0002               ; __      __         _       _     _
0003               ; \ \    / /        (_)     | |   | |
0004               ;  \ \  / /__ _ _ __ _  __ _| |__ | | ___ ___
0005               ;   \ \/ // _` | '__| |/ _` | '_ \| |/ _ | __|
0006               ;    \  /| (_| | |  | | (_| | |_) | |  __|__ \
0007               ;     \/  \__,_|_|  |_|\__,_|_.__/|_|\___|___/
0008               
0009               ;[ UNSIGNED ( -- address ) (variable)
0010               ; places the address of the signed number variable on the stack
0011               ; this variable is used by the number to string routine to determine if a number should be
0012               ; treated as signed or unsigned when converting into a string (normally for displaying).
0013               ; If >0, then numbers will be converted as unsigned. This variable is set by U. and .
0014               ; but can also be useful in user programs.
0015 75E8 75D8     usignh  data dup2h,8
     75EA 0008     
0016 75EC 554E             text 'UNSIGNED'
     75EE 5349     
     75F0 474E     
     75F2 4544     
0017 75F4 75F6     usignd  data $+2
0018 75F6 0206  20         li r6,dotsin
     75F8 A05C     
0019 75FA 1029  14         jmp span1
0020               ;]
0021               
0022               ;[ KDEL ( -- address )
0023               ; places the address of the keyboard auto-repeat delay
0024               ; used mainly for the geneve, which is a lot faster and needs a longer
0025               ; initial delay and repeat delay.
0026               ; The value stored in KDEL has the following format:
0027               ; 0xiiss
0028               ; Where ii is the initial delay (before auto-repeat starts) divided by 2.
0029               ; At power up, this value is 237 decimal.
0030               ; ss is the short delay (when auto-repeat is active). At power-up this value
0031               ; is 30 decimal. Maximum value is 255.
0032 75FC 75E8     kdelh   data usignh,4
     75FE 0004     
0033 7600 4B44             text 'KDEL'
     7602 454C     
0034 7604 7606     kdel_   data $+2
0035 7606 0206  20         li r6,kdel
     7608 A00A     
0036 760A 1021  14         jmp span1
0037               ;]
0038               
0039               ;[ #BUF ( -- address ) (variable)
0040               ; number of disk buffers - minimum is one
0041 760C 75FC     nbufh   data kdelh,4
     760E 0004     
0042 7610 2342             text '#BUF'
     7612 5546     
0043 7614 7616     nbuf    data $+2
0044 7616 0206  20         li r6,totblk
     7618 A1B2     
0045 761A 1019  14         jmp span1
0046               ;]
0047               
0048               ;[ SSCROLL ( -- address ) (variable)
0049               ; places address of NOSCROLL variable on the stack
0050               ; used to determine if the command line environment
0051 761C 760C     noscrh  data nbufh,7
     761E 0007     
0052 7620 5353             text 'SSCROLL '
     7622 4352     
     7624 4F4C     
     7626 4C20     
0053 7628 762A     noscr   data $+2
0054 762A 0206  20         li r6,noscrl
     762C A028     
0055 762E 100F  14         jmp span1
0056               ;]
0057               
0058               ;[ CSEN ( -- address ) (variable)
0059               ; places address of CASE variable on the stack
0060               ; When CSEN>0 the system is case sensitive
0061 7630 761C     sensh   data noscrh,4
     7632 0004     
0062 7634 4353             text 'CSEN'
     7636 454E     
0063 7638 763A     sens    data $+2
0064 763A 0206  20         li r6,cassen
     763C A058     
0065 763E 1007  14         jmp span1
0066               ;]
0067               
0068               ;[ SPAN         -- addr                       U,83   "number-t-i-b"
0069               ; The address of a variable containing the number of bytes placed into the text input buffer by EXPECT.
0070 7640 7630     htibh   data sensh,4
     7642 0004     
0071 7644 5350             text 'SPAN'
     7646 414E     
0072 7648 764A     span    data $+2
0073 764A 0206  20         li r6,_span
     764C A04E     
0074 764E 1007  14 span1   jmp !                          ; dovar is out of range, so take a small hop...
0075               ;]
0076               
0077               ;[ #TIB ( -- address ) (variable)
0078               ; returns a pointer to the size of the text input buffer
0079 7650 7640     cplh    data HTIBH,4
     7652 0004     
0080 7654 2354             text '#TIB'
     7656 4942     
0081 7658 765A     cpl     data $+2
0082 765A 0206  20         li r6,tibsiz
     765C A04C     
0083 765E 1073  14 !       jmp dovar
0084               ;]
0085               
0086               ;[ WRAP ( -- address ) (variable)
0087               ; places address of WRAP variable on the stack
0088               ; used to determine if the SCROLL command does wrap-around or not
0089 7660 7650     wraph   data cplh,4
     7662 0004     
0090 7664 5752             text 'WRAP'
     7666 4150     
0091 7668 766A     wrap_   data $+2
0092 766A 0206  20         li r6,wrap
     766C A032     
0093 766E 106B  14         jmp dovar
0094               ;]
0095               
0096               ;[ ZEROS ( -- address ) (variable)
0097               ; places address of LZI variable on the stack
0098               ; used to set if leading zeros are displyed when displaying numbers
0099 7670 7660     zerosh  data wraph,5
     7672 0005     
0100 7674 5A45             text 'ZEROS '
     7676 524F     
     7678 5320     
0101 767A 767C     zeros   data $+2
0102 767C 0206  20         li r6,lzi
     767E A064     
0103 7680 1062  14         jmp dovar
0104               ;]
0105               
0106               ;[ SP@ ( -- address ) (constant)
0107               ; places current address of stack pointer on the stack
0108 7682 7670     spfh    data zerosh,3
     7684 0003     
0109 7686 5350             text 'SP@ '
     7688 4020     
0110 768A 768C     spf     data $+2
0111 768C C184  18         mov stack,r6                ; address of stack pointer in r6
0112 768E 105B  14         jmp dovar
0113               ;]
0114               
0115               ;[ SP! ( address -- ) (function)
0116               ; set stack pointer address - use with caution!
0117 7690 7682     spsh    data spfh,3
     7692 0003     
0118 7694 5350             text 'SP! '
     7696 2120     
0119 7698 769A     sps     data $+2
0120 769A C114  26         mov *stack,stack            ; set stack pointer
0121 769C C804  38         mov stack,@s0               ; set S0
     769E A020     
0122 76A0 0644  14 spsx    dect stack                  ; adjust for pre-increment
0123 76A2 045C  20         b *next
0124               ;]
0125               
0126               ;[ RP@ ( -- address ) (variable)
0127               ; places current address of return stack pointer on the stack
0128 76A4 7690     rpfh    data spsh,3
     76A6 0003     
0129 76A8 5250             text 'RP@'
     76AA 40       
0130 76AC 76AE     rpf     data $+2
0131 76AE C185  18         mov rstack,r6               ; address of return stack pointer in r6
0132 76B0 104A  14         jmp dovar
0133               ;]
0134               
0135               ;[ STATE        -- addr                       U,79
0136               ; The address of a variable containing the compilation state. A non-zero content indicates
0137               ; compilation is occurring, but the value itself is system dependent.  A Standard Program
0138               ; may not modify this variable.
0139 76B2 76A4     stateh  data rpfh,5
     76B4 0005     
0140 76B6 5354             text 'STATE '
     76B8 4154     
     76BA 4520     
0141 76BC 76BE     state_  data $+2
0142 76BE 0206  20         li r6,_state
     76C0 A04A     
0143 76C2 1041  14         jmp dovar
0144               ;]
0145               
0146               ;[ LATEST ( -- address ) (variable)
0147               ; returns the *address* of LATEST on the stack
0148 76C4 76B2     latesh  data stateh,6
     76C6 0006     
0149 76C8 4C41             text 'LATEST'
     76CA 5445     
     76CC 5354     
0150 76CE 76D0     lates_  data $+2
0151 76D0 0206  20         li r6,latest
     76D2 A046     
0152 76D4 1038  14         jmp dovar
0153               ;]
0154               
0155               ;[ H ( -- address ) (variable)
0156               ; returns the *address* of HERE on the stack - note lowercase
0157               ; see the constant, HERE
0158 76D6 76C4     hereh   data latesh,1
     76D8 0001     
0159 76DA 4820             text 'H '
0160 76DC 76DE     here_   data $+2
0161 76DE 0206  20         li r6,here
     76E0 A048     
0162 76E2 1031  14         jmp dovar
0163               ;]
0164               
0165               ;[ BASE         -- addr                       U,83
0166               ; The address of a variable containing the current numeric conversion radix.
0167               ; {{2..36}}
0168 76E4 76D6     baseh   data hereh,4
     76E6 0004     
0169 76E8 4241             text 'BASE'
     76EA 5345     
0170 76EC 76EE     base_   data $+2
0171 76EE 0206  20         li r6,base
     76F0 A05E     
0172 76F2 1029  14         jmp dovar
0173               ;]
0174               
0175               ;[ >IN          -- addr                       U,79          "to-in"
0176               ; The address of a variable which contains the present character offset within
0177               ; the input stream {{0..the number of characters in the input stream}}.
0178               ; See:  WORD
0179 76F4 76E4     inh     data baseh,3
     76F6 0003     
0180 76F8 3E49             text '>IN '
     76FA 4E20     
0181 76FC 76FE     in_     data $+2
0182 76FE 0206  20         li r6,in
     7700 A044     
0183 7702 1021  14         jmp dovar
0184               ;]
0185               
0186               ;[ KMODE ( -- address ) (variable)
0187               ; returns the address of keydev, the keyscan mode
0188 7704 76F4     kmodh   data inh,5
     7706 0005     
0189 7708 4B4D             text 'KMODE '
     770A 4F44     
     770C 4520     
0190 770E 7710     kmode   data $+2
0191 7710 0206  20         li r6,keydev
     7712 A024     
0192 7714 1018  14         jmp dovar
0193               ;]
0194               
0195               ;[ WARN ( -- address ) (variable)
0196               ; returns the address of keydev, the keyscan mode
0197 7716 7704     warnh   data kmodh,4
     7718 0004     
0198 771A 5741             text 'WARN'
     771C 524E     
0199 771E 7720     warn    data $+2
0200 7720 0206  20         li r6,_warn
     7722 A068     
0201 7724 1010  14         jmp dovar
0202               ;]
0203               
0204               ;[ TIB          -- addr                       83            "t-i-b"
0205               ; The address of the text input buffer.
0206               ; This buffer is used to hold characters when the input stream is coming from
0207               ; the current input device.  The minimum capacity of TIB is 80 characters.
0208               ; Note: TIB is a VDP address, unless SOURCE=-1, in which case it is interpreted
0209               ; as a CPU address.
0210 7726 7716     tibh    data warnh,3
     7728 0003     
0211 772A 5449             text 'TIB '
     772C 4220     
0212 772E 7730     tib_    data $+2
0213 7730 0206  20         li r6,tibadr
     7732 A1D0     
0214 7734 1008  14         jmp dovar
0215               ;]
0216               
0217               ;[ FFAIHM ( -- address )
0218               ; returns the first free address in high memory
0219 7736 7726     ffahh   data tibh,6
     7738 0006     
0220 773A 4646             text 'FFAIHM'
     773C 4149     
     773E 484D     
0221 7740 7742     ffaih   data $+2
0222 7742 0206  20         li r6,ffaihm
     7744 A01E     
0223                       ; fall down into dovar...
0224               ;]
0225               
0226               ; DOVAR: common routine used by variables and constants to push their data onto
0227               ; the stack. NOTE: this code is also used by code in Variables.a99
0228               ; This code is placed here so that it falls within the 256 byte JMP limit of
0229               ; both Constants.a99 and Variables.a99 - sneaky ;-)
0230 7746 0644  14 dovar   dect stack              ; new stack entry
0231 7748 C506  30         mov r6,*stack           ; move value to data stack
0232 774A 045C  20         b *next
0233               
0234               ;[ FFAILM ( -- address )
0235               ; returns the first free address in low memory
0236 774C 7736     ffalh   data ffahh,6
     774E 0006     
0237 7750 4646             text 'FFAILM'
     7752 4149     
     7754 4C4D     
0238 7756 7758     ffaml   data $+2
0239 7758 0206  20         li r6,ffailm
     775A A01C     
0240 775C 10F4  14         jmp dovar
0241               ;]
0242               
0243               
0244               ;   _____                 _               _
0245               ;  / ____|               | |             | |
0246               ; | |      ___  _ __  ___| |_  __ _ _ __ | |_ ___
0247               ; | |     / _ \| '_ \/ __| __|/ _` | '_ \| __/ __|
0248               ; | |____| (_) | | | \__ \ |_| (_| | | | | |_\__ \
0249               ;  \_____|\___/|_| |_|___/\__|\__,_|_| |_|\__|___/
0250               
0251               ;[ PAD          -- addr                       83
0252               ; The lower address of a scratch area used to hold data for intermediate
0253               ; processing.
0254               ; The address or contents of PAD may change and the data lost if the address of
0255               ; the next available dictionary location is changed.
0256               ; The minimum capacity of PAD is 84 characters.
0257 775E 774C     padh    data ffalh,3
     7760 0003     
0258 7762 5041             text 'PAD '
     7764 4420     
0259 7766 7768     pad     data $+2
0260 7768 C1A0  34         mov @ffaihm,r6              ; get first free address in HIGH memory
     776A A01E     
0261 776C 0286  22         ci r6,>ffa8                 ; compare to end of low memory-86 bytes
     776E FFA8     
0262 7770 1102  14         jlt padx                    ; if less than then ok, just exit
0263                       ; otherwise, we're close to end of high memory, so...
0264 7772 C1A0  34         mov @ffailm,r6              ; offer an address in low memory
     7774 A01C     
0265 7776 0226  22 padx    ai r6,80                    ; add a margin
     7778 0050     
0266 777A 10E5  14         jmp dovar
0267               ;]
0268               
0269               ;[ IOERR ( -- io_error ) (constant)
0270               ; places last IO error code on the stack
0271 777C 775E     ioerrh  data padh,5
     777E 0005     
0272 7780 494F             text 'IOERR '
     7782 4552     
     7784 5220     
0273 7786 7788     ioerr1  data $+2
0274 7788 C1A0  34         mov @errnum,r6
     778A A03A     
0275 778C 10DC  14         jmp dovar
0276               ;]
0277               
0278               ;[ XMAX ( -- xmax ) (constant)
0279               ; places the horizontal screen size (32, 40 or 80) on the stack
0280 778E 777C     xmaxh   data ioerrh,4
     7790 0004     
0281 7792 584D             text 'XMAX'
     7794 4158     
0282 7796 7798     gxmax   data $+2
0283 7798 C1A0  34         mov @xmax,r6
     779A A02E     
0284 779C 10D4  14         jmp dovar
0285               ;]
0286               
0287               ;[ S0 ( -- address ) (constant)
0288               ; *BEGINNING* address of data stack on data stack, used to reset the data stack
0289 779E 778E     s0h     data xmaxh,2
     77A0 0002     
0290 77A2 5330             text 'S0'
0291 77A4 77A6     s0_     data $+2
0292 77A6 C1A0  34         mov @S0,r6                  ; S0 defined in system.a99
     77A8 A020     
0293 77AA 10CD  14         jmp dovar
0294               ;]
0295               
0296               ;[ HEX ( -- ) (function)
0297               ; sets the number base to 16 decimal
0298 77AC 779E     hexh    data s0h,3
     77AE 0003     
0299 77B0 4845             text 'HEX '
     77B2 5820     
0300 77B4 77B6     hex     data $+2
0301 77B6 0200  20         li r0,16
     77B8 0010     
0302 77BA C800  38         mov r0,@base
     77BC A05E     
0303 77BE 045C  20         b *next
0304               ;]
0305               
0306               ;[ DECIMAL ( -- ) (function)
0307               ; sets the number base to 10 decimal
0308 77C0 77AC     dech    data hexh,7
     77C2 0007     
0309 77C4 4445             text 'DECIMAL '
     77C6 4349     
     77C8 4D41     
     77CA 4C20     
0310 77CC 77CE     deci    data $+2
0311 77CE 0200  20         li r0,10
     77D0 000A     
0312 77D2 C800  38         mov r0,@base
     77D4 A05E     
0313 77D6 045C  20         b *next
0314               ;]
0315               
0316               ;[ TRUE ( -- flag ) (constant)
0317               ; places TRUE (>FFFF) on the stack
0318 77D8 77C0     trueh   data dech,4
     77DA 0004     
0319 77DC 5452             text 'TRUE'
     77DE 5545     
0320 77E0 77E2     true    data $+2
0321 77E2 0706  14         seto r6
0322 77E4 10B0  14         jmp dovar
0323               ;]
0324               
0325               ;[ FALSE ( -- flag ) (constant)
0326               ; places FALSE (0) on the stack
0327 77E6 77D8     falseh  data trueh,5
     77E8 0005     
0328 77EA 4641             text 'FALSE '
     77EC 4C53     
     77EE 4520     
0329 77F0 77F2     false   data $+2
0330 77F2 04C6  14         clr r6
0331 77F4 10A8  14         jmp dovar
0332               ;]
0333               
0334               ;[ HERE ( -- addr ) (constant)
0335               ; places the current compilation address on the stack
0336               ; see the variable here (lower case) which allows the
0337               ; current compilation address to be changed
0338 77F6 77E6     hhereh  data falseh,4
     77F8 0004     
0339 77FA 4845             text 'HERE'
     77FC 5245     
0340 77FE 7800     ghere   data $+2
0341 7800 C1A0  34         mov @here,r6
     7802 A048     
0342 7804 10A0  14         jmp dovar
0343               ;]
0344               
0345               ;[ RND ( limit -- n)
0346               ; pushes a pseudo random number between 0 and limit-1 (rnd MOD limit)
0347               ; For the full range (0-65535) use a limit of 0
0348 7806 77F6     rndh    data hhereh,3
     7808 0003     
0349 780A 524E             text 'RND '
     780C 4420     
0350 780E 7810     rnd     data $+2
0351 7810 06A0  28         bl @bank1
     7812 8332     
0352 7814 6DBE             data _rnd
0353               ;]
                   < build.asm
0026                   copy "./bank0/0-15-Strings.asm"
     **** ****     > ./bank0/0-15-Strings.asm
0001               ;   _____ _        _              __          __            _
0002               ;  / ____| |      (_)             \ \        / /           | |
0003               ; | (___ | |_ _ __ _ _ __   __ _   \ \  /\  / /___  _ __ __| |___
0004               ;  \___ \| __| '__| | '_ \ / _` |   \ \/  \/ // _ \| '__/ _` / __|
0005               ;  ____) | |_| |  | | | | | (_| |    \  /\  /| (_) | | | (_| \__ \
0006               ; |_____/ \__|_|  |_|_| |_|\__, |     \/  \/  \___/|_|  \__,_|___/
0007               ;                           __/ |
0008               ;                          |___/
0009               ; string related words
0010               
0011               ;[ U.           u --                          M,79          "u-dot"
0012               ; u is displayed as an unsigned number in a free-field format.
0013 7816 7806     udoth   data rndh,2
     7818 0002     
0014 781A 552E             text 'U.'
0015 781C 8320     udot    data docol,usign,type,space1,exit
     781E 78A4     
     7820 6C96     
     7822 6D32     
     7824 832C     
0016               ;]
0017               
0018               ;[ .            n --                          M,79            "dot"
0019               ; The absolute value of n is displayed in a free field format with a leading
0020               ; minus sign if n is negative.
0021 7826 7816     doth    data udoth,1
     7828 0001     
0022 782A 2E20             text '. '
0023 782C 8320     dot     data docol,sign
     782E 789C     
0024 7830 6C96     dot1    data type,space1,exit
     7832 6D32     
     7834 832C     
0025               ;]
0026               
0027               ;[ U.R ( num width -- )
0028 7836 7826     udotrh  data doth,3
     7838 0003     
0029 783A 552E             text 'U.R '
     783C 5220     
0030 783E 8320     udotr   data docol
0031 7840 617A             data swap           ; width num
0032 7842 78A4             data usign          ; width addr len
0033 7844 785C             data setw           ; addr len
0034 7846 65D6             data branch,dot1
     7848 7830     
0035               ;]
0036               
0037               ;[ .R ( num width --)
0038 784A 7836     dotrh   data udotrh,2
     784C 0002     
0039 784E 2E52             text '.R'
0040 7850 8320     dotr    data docol
0041 7852 617A             data swap           ; width num
0042 7854 789C             data sign           ; width addr len
0043 7856 785C             data setw           ; addr len
0044 7858 65D6             data branch,dot1
     785A 7830     
0045               ;]
0046               
0047               ;[ subroutines used by . U. .R and U.R
0048 785C 8320     setw    data docol,rot,swap,tuck,sub,spces,exit
     785E 618E     
     7860 617A     
     7862 61DE     
     7864 6318     
     7866 6D4C     
     7868 832C     
0049               ;]
0050               
0051               ;[ $. ( num -- )
0052               ; prints a number as an unsigned hex value
0053 786A 784A     hdoth   data dotrh,2
     786C 0002     
0054 786E 242E             text '$.'
0055 7870 8320     hexdot  data docol
0056 7872 76EC             data base_,fetch,swap
     7874 6822     
     7876 617A     
0057 7878 77B4             data hex
0058 787A 78A4             data usign,type
     787C 6C96     
0059 787E 6D32             data space1
0060 7880 76EC             data base_,store,exit
     7882 6844     
     7884 832C     
0061               ;]
0062               
0063               ;[ N>S ( num -- addr len )
0064               ; Takes a number off the stack and converts it to a signed string equivalent,
0065               ; with respect to the current number base.
0066               ; The variable UNSIGNED is checked, and if true, the strings generated shall be
0067               ; the unsigned equivalents of the number on the stack, otherwise the string
0068               ; shall be the signed equivalent of the number of the stack.
0069               ;
0070               ; sign and usign below are entry points into N>S for . and U. respectively to
0071               ; force N>S to produce an appropriately signed string.
0072 7886 786A     ntsh    data hdoth,3
     7888 0003     
0073 788A 4E3E             text 'N>S '
     788C 5320     
0074 788E 7890     nts     data $+2
0075 7890 C820  54         mov @dotsin,@dosign     ; set/reset signed/unsigned mode according to
     7892 A05C     
     7894 A066     
0076                                               ; the Forth variable UNSIGNED
0077 7896 06A0  28 nts1    bl @bank1
     7898 8332     
0078 789A 6E66             data _nts               ; see 1-10-Strings.a99
0079                   ; entry points for . and U. :
0080 789C 789E     sign    data $+2
0081 789E 04E0  34         clr @dosign
     78A0 A066     
0082 78A2 10F9  14         jmp nts1
0083 78A4 78A6     usign   data $+2
0084 78A6 0720  34         seto @dosign
     78A8 A066     
0085 78AA 10F5  14         jmp nts1
0086               ;]
0087               
0088               ;[ CHAR ( -- ascii )
0089               ; puts the ASCII code of the first character of the following word on the stack
0090               ; For example CHAR A puts 65 on the stack.
0091 78AC 7886     charh   data ntsh,immed+4
     78AE 8004     
0092 78B0 4348             text 'CHAR'
     78B2 4152     
0093 78B4 8320     char    data docol,spword,drop,chrftc,exit
     78B6 72B2     
     78B8 6170     
     78BA 6860     
     78BC 832C     
0094               ;]
0095               
0096               ;[ ASCII ( ascii -- )
0097               ; In interpretation state:
0098               ;    pushes the ascii value of the character immediately following
0099               ;    ASCII to the stack.
0100               ; In compilation state:
0101               ;    compiles the ascii value of the character immediately following
0102               ;    ASCII as a literal
0103 78BE 78AC     asciih  data charh,immed+5
     78C0 8005     
0104 78C2 4153             text 'ASCII '
     78C4 4349     
     78C6 4920     
0105 78C8 8320     ascii   data docol,char,state_,fetch,zbrnch,asciix
     78CA 78B4     
     78CC 76BC     
     78CE 6822     
     78D0 65E8     
     78D2 78D6     
0106 78D4 60AA             data clc        ; compile lit ,
0107 78D6 832C     asciix  data exit
0108               ;]
0109               
0110               ;[ COUNT        addr1 -- addr2 +n             79
0111               ; addr2 is addr1+1 and +n is the length of the counted string at addr1.
0112               ; The byte at addr1 contains the byte count +n.
0113               ; Range of +n is {0.255}  See:  "string, counted"
0114 78D8 78BE     counth  data asciih,5
     78DA 0005     
0115 78DC 434F             text 'COUNT '
     78DE 554E     
     78E0 5420     
0116 78E2 78E4     count   data $+2
0117 78E4 06A0  28         bl @bank1
     78E6 8332     
0118 78E8 6DDC             data _count                 ; see 1-10-Strings.a99
0119               ;]
0120               
0121               ;[ S" Compile time:( -- ) Immediate:( -- address length )
0122               ; When Compiling:
0123               ; compiles: (S")<length><string>
0124               ; e.g S" HELLO" compiles (S") 5 H E L L O
0125               ; Note the 0 padding byte for odd length strings.
0126               ; The length is a BYTE. At the end of string compilation, HERE is aligned to an
0127               ; even address.
0128               ; At run time, (S") pushes the address of the beginning of the string
0129               ;(address of length byte+1) and the length to the stack.
0130               ;
0131               ; When Interpreting:
0132               ; Compiles the string to the address PAD, and pushes the address and
0133               ; length to the stack.
0134 78EA 78D8     strngh  data counth,immed+2
     78EC 8002     
0135 78EE 5322             text 'S"'
0136 78F0 8320     string  data docol,lit,34,word,pad,strng1,exit
     78F2 70B8     
     78F4 0022     
     78F6 6AA4     
     78F8 7766     
     78FA 78FE     
     78FC 832C     
0137 78FE 7900     strng1  data $+2
0138 7900 06A0  28         bl @bank1
     7902 8332     
0139 7904 6E08             data _strin                 ; see 1-10-Strings.a99
0140               
0141               ; (S") ( -- addr len )
0142               ; internal string. S" compiles (S") into a word
0143               ; At run time, (S") pushes the address and length of the string following it
0144               ; to the stack.
0145 7906 78EA     strh    data strngh,4
     7908 0004     
0146 790A 2853             text '(S")'
     790C 2229     
0147 790E 7910     str     data $+2
0148 7910 06A0  28         bl @bank1
     7912 8332     
0149 7914 6E4C             data _str                   ; see 1-10-Strings.a99
0150               ;]
0151               
0152               ;[ -TRAILING    addr +n1 -- addr +n2          79    "dash-trailing"
0153               ; The character count +n1 of a text string beginning at addr is adjusted to
0154               ; exclude trailing spaces.
0155               ; If +n1 is zero, then +n2 is also zero.
0156               ; If the entire string consists of spaces, then +n2 is zero.
0157 7916 7906     trailh  data strh,9
     7918 0009     
0158 791A 2D54             text '-TRAILING '
     791C 5241     
     791E 494C     
     7920 494E     
     7922 4720     
0159 7924 7926     trail   data $+2
0160 7926 06A0  28         bl @bank1
     7928 8332     
0161 792A 6DEA             data _trail                 ; see 1-10-Strings.a99
0162               ;]
0163               
0164               ;[ ."           --                            C,I,83    "dot-quote"
0165               ;                 --   (compiling)
0166               ; Used in the form:
0167               ;       ." ccc"
0168               ; Later execution will display the characters ccc up to but not including the
0169               ; delimiting " (close-quote).  The blank following ." is not part of ccc.
0170 792C 7916     tstrh   data trailh,immed+2
     792E 8002     
0171 7930 2E22             text '."'
0172 7932 8320     typstr  data docol
0173 7934 78F0             data string,state_,fetch,zbrnch,typst1,compile
     7936 76BC     
     7938 6822     
     793A 65E8     
     793C 7940     
     793E 7262     
0174 7940 6C96     typst1  data type,exit
     7942 832C     
                   < build.asm
0027                   copy "./bank0/0-16-Graphics.asm"
     **** ****     > ./bank0/0-16-Graphics.asm
0001               ;   _____                 _     _           __          __            _
0002               ;  / ____|               | |   (_)          \ \        / /           | |
0003               ; | |  __ _ __ __ _ _ __ | |__  _  ___ ___   \ \  /\  / /___  _ __ __| |___
0004               ; | | |_ | '__/ _` | '_ \| '_ \| |/ __/ __|   \ \/  \/ // _ \| '__/ _` / __|
0005               ; | |__| | | | (_| | |_) | | | | | (__\__ \    \  /\  /| (_) | | | (_| \__ \
0006               ;  \_____|_|  \__,_| .__/|_| |_|_|\___|___/     \/  \/  \___/|_|  \__,_|___/
0007               ;                  | |
0008               ;                  |_|
0009               ; graphics related commands
0010               ; the guts of these commands is in bank1 in 1-03-Graphics.a99
0011               
0012               ;[ GMODE ( graphics_mode -- )
0013 7944 792C     gmodeh  data tstrh,5
     7946 0005     
0014 7948 474D             text 'GMODE '
     794A 4F44     
     794C 4520     
0015 794E 7950     gmode   data $+2
0016 7950 06A0  28         bl @bank1
     7952 8332     
0017 7954 618C             data _gmode                 ; see 1-03-Graphics.a99
0018               ;]
0019               
0020               ;[ HCHAR ( y x ascii count -- )
0021 7956 7944     hcharh  data gmodeh,5
     7958 0005     
0022 795A 4843             text 'HCHAR '
     795C 4841     
     795E 5220     
0023 7960 7962     hchar   data $+2
0024 7962 06A0  28         bl @bank1
     7964 8332     
0025 7966 624A             data _hchar                 ; see 1-03-Graphics.a99
0026               ;]
0027               
0028               ;[ VCHAR ( y x ascii count -- )
0029 7968 7956     vcharh  data hcharh,5
     796A 0005     
0030 796C 5643             text 'VCHAR '
     796E 4841     
     7970 5220     
0031 7972 7974     vchar   data $+2
0032 7974 06A0  28         bl @bank1
     7976 8332     
0033 7978 6256             data _vchar                 ; see 1-03-Graphics.a99
0034               ;]
0035               
0036               ;[ GCHAR ( y x -- ascii )
0037 797A 7968     gcharh  data vcharh,5
     797C 0005     
0038 797E 4743             text 'GCHAR '
     7980 4841     
     7982 5220     
0039 7984 7986     gchar   data $+2
0040 7986 06A0  28         bl @bank1
     7988 8332     
0041 798A 627A             data _gchar                 ; see 1-03-Graphics.a99
0042               ;]
0043               
0044               ;[ DCHAR ( W1..Wx  word_count ascii -- )
0045               ; loads words from the stack into VDP memory at the ASCII
0046               ; code specified. Equivalent to CALL CHAR in BASIC.
0047 798C 797A     dcharh  data gcharh,5
     798E 0005     
0048 7990 4443             text 'DCHAR '
     7992 4841     
     7994 5220     
0049 7996 7998     dchar   data $+2
0050 7998 06A0  28         bl @bank1
     799A 8332     
0051 799C 6292             data _dchar                 ; see 1-03-Graphics.a99
0052               ;]
0053               
0054               ;[ SPRITE ( sprite y x ascii color -- )
0055               ; sprite attribute list begins at 6*80h=300h
0056 799E 798C     sprith  data dcharh,6
     79A0 0006     
0057 79A2 5350             text 'SPRITE'
     79A4 5249     
     79A6 5445     
0058 79A8 79AA     sprite  data $+2
0059 79AA 06A0  28         bl @bank1
     79AC 8332     
0060 79AE 62AE             data _sprit                 ; see 1-03-Graphics.a99
0061               ;]
0062               
0063               ;[ MAGNIFY ( x -- )
0064               ; sets sprite magnification:
0065               ; only the least significant bits are used:
0066               ; bit 7: 1=magnified (0=not magnified)
0067               ; bit 6: 1=double size (4 character)
0068               ; Remember: TI number their bits backwards! Idiots!
0069 79B0 799E     magfyh  data sprith,7
     79B2 0007     
0070 79B4 4D41             text 'MAGNIFY '
     79B6 474E     
     79B8 4946     
     79BA 5920     
0071 79BC 79BE     magfy   data $+2
0072 79BE 06A0  28         bl @bank1
     79C0 8332     
0073 79C2 632C             data _magfy                 ; see 1-03-Graphics.a99
0074               ;]
0075               
0076               ;[ SPRCOL ( sprite colour -- )
0077               ; sets the colour of a sprite
0078 79C4 79B0     sprclh  data magfyh,6
     79C6 0006     
0079 79C8 5350             text 'SPRCOL'
     79CA 5243     
     79CC 4F4C     
0080 79CE 79D0     sprcol  data $+2
0081 79D0 06A0  28         bl @bank1
     79D2 8332     
0082 79D4 6356             data _spcol                 ; see 1-03-Graphics.a99
0083               ;]
0084               
0085               ;[ SPRLOC ( sprite y x -- )
0086               ; sets the location of a sprite
0087 79D6 79C4     sprlch  data sprclh,6
     79D8 0006     
0088 79DA 5350             text 'SPRLOC'
     79DC 524C     
     79DE 4F43     
0089 79E0 79E2     sprloc  data $+2
0090 79E2 06A0  28         bl @bank1
     79E4 8332     
0091 79E6 6374             data _sploc                 ; see 1-03-Graphics.a99
0092               ;]
0093               
0094               ;[ SPRLOC? ( sprite -- y x )
0095               ; gets the location of a sprite
0096 79E8 79D6     locsph  data sprlch,7
     79EA 0007     
0097 79EC 5350             text 'SPRLOC? '
     79EE 524C     
     79F0 4F43     
     79F2 3F20     
0098 79F4 79F6     locspr  data $+2
0099 79F6 06A0  28         bl @bank1
     79F8 8332     
0100 79FA 639C             data _spget                 ; see 1-03-Graphics.a99
0101               ;]
0102               
0103               ;[ SPRPAT ( sprite ascii -- )
0104               ; sets the pattern of a sprite
0105 79FC 79E8     sppath  data locsph,6
     79FE 0006     
0106 7A00 5350             text 'SPRPAT'
     7A02 5250     
     7A04 4154     
0107 7A06 7A08     sprpat  data $+2
0108 7A08 06A0  28         bl @bank1
     7A0A 8332     
0109 7A0C 63BE             data _sppat                 ; see 1-03-Graphics.a99
0110               ;]
0111               
0112               ;[ SPRVEC ( sprite y x -- )
0113               ; sets the Y and X movement vectors for sprite movement with SPRMOV
0114 7A0E 79FC     smlsth  data sppath,6
     7A10 0006     
0115 7A12 5350             text 'SPRVEC'
     7A14 5256     
     7A16 4543     
0116 7A18 7A1A     smlst   data $+2
0117 7A1A 06A0  28         bl @bank1
     7A1C 8332     
0118 7A1E 63DC             data _smlst                 ; see 1-03-Graphics.a99
0119               ;]
0120               
0121               ;[ SPRMOV ( start_sprite number_of_sprites -- )
0122               ; moves sprites according to the entries in SMLIST, starting from start_sprite
0123               ; and continuing for number_of_sprites
0124 7A20 7A0E     sprmvh  data smlsth,6
     7A22 0006     
0125 7A24 5350             text 'SPRMOV'
     7A26 524D     
     7A28 4F56     
0126 7A2A 7A2C     sprmov  data $+2
0127 7A2C 06A0  28         bl @bank1
     7A2E 8332     
0128 7A30 63F2             data _spmov                 ; see 1-03-Graphics.a99
0129               ;]
0130               
0131               ;[ COINC ( tolerance spr1 spr2 -- flag )
0132               ; check for coincidence between sprite spr1 and spr2. If both the horizontal
0133               ; and vertical difference between the two sprites is < tolerance then the
0134               ; sprites are considered to be in coincidence with each other and flag shall be
0135               ; true, otherwise it shall be false.
0136 7A32 7A20     coinch  data sprmvh,5
     7A34 0005     
0137 7A36 434F             text 'COINC '
     7A38 494E     
     7A3A 4320     
0138 7A3C 7A3E     coinc   data $+2
0139 7A3E 06A0  28         bl @bank1
     7A40 8332     
0140 7A42 62E0             data _coinc                 ; see 1-03-Graphics.a99
0141               ;]
0142               
0143               ;[ COLOR ( char_set foreground background -- )
0144               ; sets the color sets in 32 column mode
0145 7A44 7A32     colorh  data coinch,5
     7A46 0005     
0146 7A48 434F             text 'COLOR '
     7A4A 4C4F     
     7A4C 5220     
0147 7A4E 7A50     color   data $+2
0148 7A50 06A0  28         bl @bank1
     7A52 8332     
0149 7A54 642C             data _color                 ; see 1-03-Graphics.a99
0150               ;]
0151               
0152               ;[ SCREEN ( colour -- )
0153               ; sets the screen colour
0154 7A56 7A44     scrnh   data colorh,6
     7A58 0006     
0155 7A5A 5343             text 'SCREEN'
     7A5C 5245     
     7A5E 454E     
0156 7A60 7A62     screen  data $+2
0157 7A62 06A0  28         bl @bank1
     7A64 8332     
0158 7A66 6446             data _scren                 ; see 1-03-Graphics.a99
0159               ;]
0160               
0161               ;[ SCROLL ( direction -- )
0162               ; scrolls the panel defined by PANEL in the direction specified
0163               ; 0=left 1=right 2=up 3=down
0164 7A68 7A56     scrolh  data scrnh,6
     7A6A 0006     
0165 7A6C 5343             text 'SCROLL'
     7A6E 524F     
     7A70 4C4C     
0166 7A72 7A74     scroll  data $+2
0167 7A74 06A0  28         bl @bank1
     7A76 8332     
0168 7A78 6458             data _scrol                 ; see 1-03-Graphics.a99
0169               ;]
0170               
0171               ;[ PANEL ( x y xl yl -- )
0172               ; defines a screen area to be scrolled by SCROLL
0173 7A7A 7A68     panelh  data scrolh,5
     7A7C 0005     
0174 7A7E 5041             text 'PANEL '
     7A80 4E45     
     7A82 4C20     
0175 7A84 7A86     panel   data $+2
0176 7A86 06A0  28         bl @bank1
     7A88 8332     
0177 7A8A 65BA             data _panel                 ; see 1-03-Graphics.a99
0178               ;]
                   < build.asm
0028                   copy "./bank0/0-17-Speech.asm"
     **** ****     > ./bank0/0-17-Speech.asm
0001               ;   _____                      _      __          __            _
0002               ;  / ____|                    | |     \ \        / /           | |
0003               ; | (___  _ __   ___  ___  ___| |__    \ \  /\  / /___  _ __ __| |___
0004               ;  \___ \| '_ \ / _ \/ _ \/ __| '_ \    \ \/  \/ // _ \| '__/ _` / __|
0005               ;  ____) | |_) |  __/  __/ (__| | | |    \  /\  /| (_) | | | (_| \__ \
0006               ; |_____/| .__/ \___|\___|\___|_| |_|     \/  \/  \___/|_|  \__,_|___/
0007               ;        | |
0008               ;        |_|
0009               
0010               ; these routines are just dictionary entry stubs.
0011               ; see 1-04-Speech.a99 for the actual implementation.
0012               
0013               ;[ TALKING? ( -- flag )
0014               ; returns >0 if the speech synth is busy, else returns 0
0015 7A8C 7A7A     spkngh  data panelh,8
     7A8E 0008     
0016 7A90 5441             text 'TALKING?'
     7A92 4C4B     
     7A94 494E     
     7A96 473F     
0017 7A98 7A9A     spkng   data $+2
0018 7A9A 06A0  28         bl @bank1
     7A9C 8332     
0019 7A9E 668E             data _spkng             ; see 1-05-Speech.a99
0020               ;]
0021               
0022               ;[ SAY ( addr cnt -- )
0023               ; says words from the speech synth's ROM. Use with DATA
0024               ; the addresses of the built in words are in ED/AS manual page 422
0025 7AA0 7A8C     sayh    data spkngh,3
     7AA2 0003     
0026 7AA4 5341             text 'SAY '
     7AA6 5920     
0027 7AA8 7AAA     say     data $+2
0028 7AAA 06A0  28         bl @bank1
     7AAC 8332     
0029 7AAE 66B0             data _say             ; see 1-05-Speech.a99
0030               ;]
0031               
0032               ;[ STREAM ( addr cnt -- )
0033               ; streams raw speech data to the speech synth. Use with DATA
0034 7AB0 7AA0     strmh   data sayh,6
     7AB2 0006     
0035 7AB4 5354             text 'STREAM'
     7AB6 5245     
     7AB8 414D     
0036 7ABA 7ABC     strm    data $+2
0037 7ABC 06A0  28         bl @bank1
     7ABE 8332     
0038 7AC0 66CA             data _strem             ; see 1-05-Speech.a99
0039               ;]
0040               
0041               ;[ DATA
0042               ; Compiling: DATA ( -- )  Executing: DATA ( -- addr count )
0043               ; E.g.
0044               ; When compiling:
0045               ;  DATA 5 9 8 7 6 5
0046               ;  Compiles 5 values (9 8 7 6 & 5) to memory
0047               ; At runtime:
0048               ;  When DATA is encountered, will push the start address (the address of 9)
0049               ;  to the stack, and the count (5). Execution will continue at the word
0050               ; immediately following the data list.
0051 7AC2 7AB0     datah   data strmh,immed+4
     7AC4 8004     
0052 7AC6 4441             text 'DATA'
     7AC8 5441     
0053 7ACA 8320             data docol
0054 7ACC 7262             data compile,rtdata     ; compile data run-time code
     7ACE 7AF8     
0055 7AD0 72B2             data spword,number,drop ; get number of data items from input stream
     7AD2 6B78     
     7AD4 6170     
0056 7AD6 6184             data dup,comma          ; and append to definition
     7AD8 70D2     
0057               
0058 7ADA 6082             data lit0,do,data2      ; for each data item
     7ADC 66E8     
     7ADE 7AEC     
0059 7AE0 72B2     data1   data spword,number,drop ; get number from input stream
     7AE2 6B78     
     7AE4 6170     
0060 7AE6 70D2             data comma              ; append directly to memory
0061 7AE8 6730             data loop,data1
     7AEA 7AE0     
0062 7AEC 832C     data2   data exit
0063               
0064               ; (DATA) - run-time code for DATA
0065 7AEE 7AC2     rtdath  data datah,6
     7AF0 0006     
0066 7AF2 2844             text '(DATA)'
     7AF4 4154     
     7AF6 4129     
0067 7AF8 7AFA     rtdata  data $+2
0068 7AFA 06A0  28         bl @bank1
     7AFC 8332     
0069 7AFE 6738             data _data              ; see 1-05-Speech.a99
0070               ;]
                   < build.asm
0029                   copy "./bank0/0-18-Blocks.asm"
     **** ****     > ./bank0/0-18-Blocks.asm
0001               ;  ____  _            _      _____     ______   __          __            _
0002               ; |  _ \| |          | |    |_   _|   / / __ \  \ \        / /           | |
0003               ; | |_) | | ___   ___| | __   | |    / / |  | |  \ \  /\  / /___  _ __ __| |___
0004               ; |  _ <| |/ _ \ / __| |/ /   | |   / /| |  | |   \ \/  \/ // _ \| '__/ _` / __|
0005               ; | |_) | | (_) | (__|   <   _| |_ / / | |__| |    \  /\  /| (_) | | | (_| \__ \
0006               ; |____/|_|\___/ \___|_|\_\ |_____/_/   \____/      \/  \/  \___/|_|  \__,_|___/
0007               ; block file system words & subroutines
0008               
0009               ; Notes:
0010               ;  Since File IO on the TI takes place in VDP RAM, the block system is
0011               ;  implemented using VDP ram to hold the blocks. In other words, blocks live
0012               ;  in VDP RAM, *not* CPU ram. Might as well use VDP for something and it has
0013               ;  the added benefit of leaving *lots* more CPU ram available for Forth code.
0014               ;
0015               ;  The 'system' is designed to support up to six blocks in VDP ram at once.
0016               ;  I.e. there are six 1K buffers in VDP, each buffer can hold any block.
0017               ;  The buffers are allocated in sequential order until they are used. When no
0018               ;  more buffers are available, a previously used buffer is used, it's contents
0019               ;  are overwritten. However, *if* the contents of a block have been changed
0020               ;  (i.e. they are more up-to-date than the copy on the disk) the block is
0021               ;  automatically flushed back to disk before being re-used.
0022               ;
0023               ;  The VDP addresses of the block buffers are defined in 1-15-Initialise.a99
0024               ;
0025               
0026               ;[ USE ( addr len -- )
0027               ; Tells the system which block file to use for block IO
0028               ; e.g. S" DSK1.BLOCKS" USE
0029               ; Simply sets the filename and length in the blockIO PAB
0030 7B00 7AEE     useh    data rtdath,3
     7B02 0003     
0031 7B04 5553             text 'USE '
     7B06 4520     
0032 7B08 8320     use     data docol,mtbuf,use1,exit
     7B0A 7CAA     
     7B0C 7B10     
     7B0E 832C     
0033 7B10 7B12     use1    data $+2
0034 7B12 06A0  28         bl @bank1
     7B14 8332     
0035 7B16 674C             data _use               ; see 1-06-Blocks.a99
0036               ;]
0037               
0038               ;[ WHERE ( -- block# )
0039               ; returns the block number of word that has been loaded into memory with LOAD
0040               ; eg: WHERE FOO
0041               ; can only be used from the command line
0042               ; returns 0 if not found, or if the word is in ROM
0043 7B18 7B00     whereh  data useh,immed+5
     7B1A 8005     
0044 7B1C 5748             text 'WHERE '
     7B1E 4552     
     7B20 4520     
0045 7B22 8320     where   data docol,spword,find,zbrnch,where1
     7B24 72B2     
     7B26 6ADA     
     7B28 65E8     
     7B2A 7B42     
0046 7B2C 6C20             data dfa,plus2,fetch,lit,4,rsft,lit,>3ff,and,plus1,exit
     7B2E 62C0     
     7B30 6822     
     7B32 70B8     
     7B34 0004     
     7B36 6810     
     7B38 70B8     
     7B3A 03FF     
     7B3C 67C4     
     7B3E 62AC     
     7B40 832C     
0047 7B42 6170     where1  data drop,lit0,exit
     7B44 6082     
     7B46 832C     
0048               ;]
0049               
0050               ;[ BLK          -- addr                       U,79          "b-l-k"
0051               ; The address of a variable containing the number of the mass storage block
0052               ; being interpreted as the input stream.
0053               ; If the value of BLK is zero the input stream is taken from the text input
0054               ; buffer.  {{0..the number of blocks available -1}}
0055               ; See:  TIB  "input stream"
0056 7B48 7B18     blkh    data whereh,3
     7B4A 0003     
0057 7B4C 424C             text 'BLK '
     7B4E 4B20     
0058 7B50 7B52     blk     data $+2
0059 7B52 0206  20         li r6,blknum            ; address of block variable in ram
     7B54 A1B4     
0060 7B56 0460  28         b @dovar                ; push it
     7B58 7746     
0061               ;]
0062               
0063               ;[ --> ( -- )
0064               ; loads the next block
0065 7B5A 7B48     nblkh   data blkh,immed+3
     7B5C 8003     
0066 7B5E 2D2D             text '--> '
     7B60 3E20     
0067 7B62 8320     nblk    data docol
0068 7B64 7B50             data blk,fetch,plus1,blk,store,in_,store0
     7B66 6822     
     7B68 62AC     
     7B6A 7B50     
     7B6C 6844     
     7B6E 76FC     
     7B70 6884     
0069 7B72 832C             data exit
0070               ;]
0071               
0072               ;[ THRU ( start end -- )
0073               ; loads blocks start thru end inclusive by calling LOAD for each block.
0074 7B74 7B5A     thruh   data nblkh,4
     7B76 0004     
0075 7B78 5448             text 'THRU'
     7B7A 5255     
0076 7B7C 8320     thru    data docol,plus1,swap
     7B7E 62AC     
     7B80 617A     
0077 7B82 66E8             data do,xthru
     7B84 7B8E     
0078 7B86 678C     thrulp  data    geti,load
     7B88 7C10     
0079 7B8A 6730             data loop,thrulp
     7B8C 7B86     
0080 7B8E 832C     xthru   data exit
0081               ; : THRU ( start-block end-block -- ) 1+ SWAP DO I LOAD LOOP ;
0082               ;]
0083               
0084               ;[ BLOCK        u -- vdpaddr                  M,83
0085               ; addr is the address of the assigned buffer of the first byte of block u.
0086               ; If the block occupying that buffer is not block u and has been UPDATEed it is
0087               ; transferred to mass storage before assigning the buffer.
0088               ; If block u is not already in memory, it is transferred from mass storage into
0089               ; an assigned block buffer.  A block may not be assigned to more than one
0090               ; buffer.
0091               ; If u is not an available block number, an error condition exists.
0092               ; Only data within the last buffer referenced by BLOCK or BUFFER is valid.
0093               ; The contents of a block buffer must not be changed unless the change may be
0094               ; transferred to mass storage.BLOCK ( block# -- addr )
0095               ;
0096               ; Brings a block into a buffer, if not already in memory
0097               ;  1) If already in memory, the block is not re-loaded from device
0098               ;  2) If not in memory:
0099               ;  3)  Scans for a free buffer
0100               ;  4)  If no free buffer:
0101               ;  5)   flush all buffers back to device
0102               ;  6)   Repeat from 3
0103               ;  7) If free buffer:
0104               ;  9)  Load block from device into free buffer
0105               ; 10)  Return address of buffer
0106               ; 11) If disk error, or block not found etc, return 0
0107 7B90 7B74     blockh  data thruh,5
     7B92 0005     
0108 7B94 424C             text 'BLOCK '
     7B96 4F43     
     7B98 4B20     
0109 7B9A 8320     block   data docol,lit,blkvec,fetch,execut,exit
     7B9C 70B8     
     7B9E A002     
     7BA0 6822     
     7BA2 72AA     
     7BA4 832C     
0110 7BA6 7BA8     block2  data $+2
0111 7BA8 06A0  28         bl @bank1
     7BAA 8332     
0112 7BAC 6780             data _block             ; see 1-06-Blocks.a99
0113               ;]
0114               
0115               ;[ LIST ( block# -- )
0116               ; lists a blocks' contents to the screen without loading it
0117 7BAE 7B90     listh   data blockh,4
     7BB0 0004     
0118 7BB2 4C49             text 'LIST'
     7BB4 5354     
0119 7BB6 8320     list_   data docol,fblock,dup,zbrnch,lstxit
     7BB8 7C4A     
     7BBA 6184     
     7BBC 65E8     
     7BBE 7BF8     
0120 7BC0 70B8             data lit,16,lit0
     7BC2 0010     
     7BC4 6082     
0121 7BC6 66E8             data do,lstxit
     7BC8 7BF8     
0122 7BCA 6E8C     list1   data cr,geti,lit,2,dotr
     7BCC 678C     
     7BCE 70B8     
     7BD0 0002     
     7BD2 7850     
0123 7BD4 70B8             data    lit,3,emit,dup,ghere,lit,64,fvmbr,ghere
     7BD6 0003     
     7BD8 6D92     
     7BDA 6184     
     7BDC 77FE     
     7BDE 70B8     
     7BE0 0040     
     7BE2 6904     
     7BE4 77FE     
0124 7BE6 70B8             data    lit,64,trail,type,lit,64,add
     7BE8 0040     
     7BEA 7924     
     7BEC 6C96     
     7BEE 70B8     
     7BF0 0040     
     7BF2 6310     
0125 7BF4 6730             data loop,list1
     7BF6 7BCA     
0126 7BF8 6170     lstxit  data drop,cr,blk,store0
     7BFA 6E8C     
     7BFC 7B50     
     7BFE 6884     
0127 7C00 70B8             data lit,lstblk,store0,exit
     7C02 A1B6     
     7C04 6884     
     7C06 832C     
0128               ;]
0129               
0130               ;[ LOAD ( block# -- )
0131               ; interprets a block
0132 7C08 7BAE     loadh   data listh,4
     7C0A 0004     
0133 7C0C 4C4F             text 'LOAD'
     7C0E 4144     
0134 7C10 8320     load    data docol
0135 7C12 76FC             data in_,fetch,rspush
     7C14 6822     
     7C16 6282     
0136 7C18 7B50             data blk,fetch,rspush
     7C1A 6822     
     7C1C 6282     
0137 7C1E 7648             data span,fetch,rspush
     7C20 6822     
     7C22 6282     
0138 7C24 70B8             data lit,1024,span,store
     7C26 0400     
     7C28 7648     
     7C2A 6844     
0139 7C2C 76FC             data in_,store0
     7C2E 6884     
0140 7C30 7B50             data blk,store
     7C32 6844     
0141 7C34 72FE             data interp
0142 7C36 629E             data rspop,span,store
     7C38 7648     
     7C3A 6844     
0143 7C3C 629E             data rspop,blk,store
     7C3E 7B50     
     7C40 6844     
0144 7C42 629E             data rspop,in_,store
     7C44 76FC     
     7C46 6844     
0145 7C48 832C             data exit
0146               ;]
0147               
0148               fblock  ; ( blk# --)
0149                       ; fetch block and strip off dirty bit
0150 7C4A 8320             data docol,block,lit,>7fff,and,exit
     7C4C 7B9A     
     7C4E 70B8     
     7C50 7FFF     
     7C52 67C4     
     7C54 832C     
0151               
0152               ;[ CLOAD ( blk -- )
0153               ; Conditionally loads a block if the referenced word (passed in the TIB) is
0154               ; not found.
0155               ; e.g. 69 CLOAD SAMS? will load block 69 if the word SAMS? is not found.
0156               ; If the word *is* found then no further action is taken.
0157 7C56 7C08     cloadh  data loadh,immed+5
     7C58 8005     
0158 7C5A 434C             text 'CLOAD '
     7C5C 4F41     
     7C5E 4420     
0159 7C60 8320     cload   data docol,spword,find,nip
     7C62 72B2     
     7C64 6ADA     
     7C66 61D0     
0160 7C68 65E8             data zbrnch,cload1
     7C6A 7C70     
0161 7C6C 6170             data drop,exit
     7C6E 832C     
0162 7C70 7C10     cload1  data load,exit
     7C72 832C     
0163               ;]
0164               
0165               ;[ UPDATE       --                            79
0166               ; The currently valid block buffer is marked as modified.
0167               ; Blocks marked as modified will subsequently be automatically transferred to
0168               ; mass storage should its memory buffer be needed for storage of a different
0169               ; block or upon execution of FLUSH.
0170 7C74 7C56     updath  data cloadh,6
     7C76 0006     
0171 7C78 5550             text 'UPDATE'
     7C7A 4441     
     7C7C 5445     
0172 7C7E 7C80     update  data $+2
0173 7C80 06A0  28         bl @bank1
     7C82 8332     
0174 7C84 68A2             data _updat             ; see 1-06-Blocks.a99
0175               ;]
0176               
0177               ;[ FLUSH        --                            M,83
0178               ; Flushes all modified buffers to the storage device then unassigns all block
0179               ; buffers.
0180 7C86 7C74     flushh  data updath,5
     7C88 0005     
0181 7C8A 464C             text 'FLUSH '
     7C8C 5553     
     7C8E 4820     
0182 7C90 7C92     flush   data $+2
0183 7C92 06A0  28         bl @bank1
     7C94 8332     
0184 7C96 6810             data _flush             ; see 1-06-Blocks.a99
0185               ;]
0186               
0187               ;[ EMPTY-BUFFERS ( -- )
0188               ; immediately sets all buffers to unsaasigned.
0189               ; DOES NOT flush dirty buffers to disk
0190 7C98 7C86     mtbufh  data flushh,13
     7C9A 000D     
0191 7C9C 454D             text 'EMPTY-BUFFERS '
     7C9E 5054     
     7CA0 592D     
     7CA2 4255     
     7CA4 4646     
     7CA6 4552     
     7CA8 5320     
0192 7CAA 7CAC     mtbuf   data $+2
0193 7CAC 06A0  28         bl @bank1
     7CAE 8332     
0194 7CB0 68B6             data _mtbuf             ; see 1-06-Blocks.a99
0195               ;]
0196               
0197               ;[ CLEAN ( buffer -- )
0198               ; forces a buffers' status to clean
0199 7CB2 7C98     cleanh  data mtbufh,5
     7CB4 0005     
0200 7CB6 434C             text 'CLEAN '
     7CB8 4541     
     7CBA 4E20     
0201 7CBC 7CBE     bclean  data $+2
0202 7CBE 06A0  28         bl @bank1
     7CC0 8332     
0203 7CC2 68D2             data _clean             ; see 1-06-Blocks.a99
0204               ;]
0205               
0206               ;[ DIRTY ( buffer -- )
0207               ; forces a buffers' status to dirty
0208 7CC4 7CB2     dirtyh  data cleanh,5
     7CC6 0005     
0209 7CC8 4449             text 'DIRTY '
     7CCA 5254     
     7CCC 5920     
0210 7CCE 7CD0     dirty   data $+2
0211 7CD0 06A0  28         bl @bank1
     7CD2 8332     
0212 7CD4 68DE             data _dirty             ; see 1-06-Blocks.a99
0213               ;]
0214               
0215               ;[ DIRTY? ( buffer -- flag )
0216               ; interrogates a buffers' status, returning true if the buffer is dirty, else
0217               ; returning false
0218 7CD6 7CC4     dirtih  data dirtyh,6
     7CD8 0006     
0219 7CDA 4449             text 'DIRTY?'
     7CDC 5254     
     7CDE 593F     
0220 7CE0 7CE2     dirtyq  data $+2
0221 7CE2 06A0  28         bl @bank1
     7CE4 8332     
0222 7CE6 68EA             data _qdirt             ; see 1-06-Blocks.a99
0223               ;]
0224               
0225               ;[ BLK? ( buffer -- block vdp_address )
0226               ; For a given buffer, returns the actual block stored in that buffer
0227               ; and the vdp address of that buffer
0228 7CE8 7CD6     blkqh   data dirtih,4
     7CEA 0004     
0229 7CEC 424C             text 'BLK?'
     7CEE 4B3F     
0230 7CF0 7CF2     blkq    data $+2
0231 7CF2 06A0  28         bl @bank1
     7CF4 8332     
0232 7CF6 6900             data _blkq             ; see 1-06-Blocks.a99
0233               ;]
0234               
0235               ;[ BUF? ( block -- buffer vdp_address )
0236               ; For a given block, return the buffer number, and the vdp address of the buffer
0237               ; returns 0 0 if the block is not in memory
0238 7CF8 7CE8     bufh    data blkqh,4
     7CFA 0004     
0239 7CFC 4255             text 'BUF?'
     7CFE 463F     
0240 7D00 7D02     buf     data $+2
0241 7D02 06A0  28         bl @bank1
     7D04 8332     
0242 7D06 6914             data _buf             ; see 1-06-Blocks.a99
0243               ;]
0244               
0245               ;[ SETBLK ( buffer block -- )
0246               ; For a given buffer, changes the block that it is associated with.
0247               ; Allows blocks to copied to other blocks, using FLUSH.
0248               ; Blocks can also be copied to a different block file by changing the blocks
0249               ; file (with USE) before using FLUSH.
0250 7D08 7CF8     setblh  data bufh,6
     7D0A 0006     
0251 7D0C 5345             text 'SETBLK'
     7D0E 5442     
     7D10 4C4B     
0252 7D12 7D14     setblk  data $+2
0253 7D14 06A0  28         bl @bank1
     7D16 8332     
0254 7D18 6942             data _setbk             ; see 1-06-Blocks.a99
0255               ;]
0256               
0257               ;[ MKBLK ( block_count -- )
0258               ; makes a block file on disk.
0259               ; E.G. 80 MKBLOCK DSK1.BLOCKS
0260               ; The above creates an 80K file on disk 1 called BLOCKS.
0261               ; use IOERR to check success.
0262               ; IOERR contains 0 for success or the disk error code
0263 7D1A 7D08     mkblkh  data setblh,immed+5
     7D1C 8005     
0264 7D1E 4D4B             text 'MKBLK '
     7D20 424C     
     7D22 4B20     
0265 7D24 8320     mkblk   data docol
0266 7D26 72B2             data spword                     ; get the filename
0267 7D28 7D2C             data mkblkc,exit                ; branch to bank 1
     7D2A 832C     
0268 7D2C 7D2E     mkblkc  data $+2
0269 7D2E 06A0  28         bl @bank1
     7D30 8332     
0270 7D32 6952             data _mkblk                     ; see 1-06-Blocks.a99
0271               ;]
0272               
0273               ; WriteHeader ( vdp_addr -- vdp_addr+8)
0274               ; : WRITE-HEADER ( vdp_addr -- vdp_addr+8)
0275               ;     $994A VW!  LATEST @ VW!  HERE VW!  3 PICK VW! ;
0276 7D34 8320     whead   data docol
0277 7D36 70B8             data lit,>994a,vdpww,lates_,fetch,vdpww,ghere,vdpww,lit,3,pick,vdpww
     7D38 994A     
     7D3A 7D50     
     7D3C 76CE     
     7D3E 6822     
     7D40 7D50     
     7D42 77FE     
     7D44 7D50     
     7D46 70B8     
     7D48 0003     
     7D4A 6210     
     7D4C 7D50     
0278 7D4E 832C             data exit
0279               
0280 7D50 8320     vdpww   data docol ; V2! ( addr val -- addr+2 )
0281 7D52 621E             data swpb_,swap,dup,nrot,dup2,vdpstr,plus1,swap,swpb_,swap,vdpstr,plus2
     7D54 617A     
     7D56 6184     
     7D58 61AA     
     7D5A 75E0     
     7D5C 68B2     
     7D5E 62AC     
     7D60 617A     
     7D62 621E     
     7D64 617A     
     7D66 68B2     
     7D68 62C0     
0282 7D6A 832C             data exit
0283               
0284               
0285               ; BSAVE ( start_address  start_block -- first_free_block)
0286               ; : BSAVE ( addr block - next_free_block)
0287               ;   OVER HERE SWAP -
0288               ;   BEGIN DUP 1008 > WHILE
0289               ;       OVER GBASD
0290               ;       WRITE-HEADER
0291               ;       3 PICK 1008 VMBW
0292               ;       1008 - ROT 1008 + -ROT SWAP 1+ SWAP
0293               ;   REPEAT
0294               ;   SWAP DUP GBASD WRITE-HEADER 3 PICK 3 PICK VMBW
0295               ;   1+ NIP NIP FLUSH ;
0296 7D6C 7D1A     bsaveh  data mkblkh,5
     7D6E 0005     
0297 7D70 4253             text 'BSAVE '
     7D72 4156     
     7D74 4520     
0298 7D76 8320     bsave   data docol
0299 7D78 61C6             data over,ghere,swap,sub
     7D7A 77FE     
     7D7C 617A     
     7D7E 6318     
0300 7D80 6184     bsave1  data dup,lit,1008,gt,zbrnch,bsave2
     7D82 70B8     
     7D84 03F0     
     7D86 647A     
     7D88 65E8     
     7D8A 7DBA     
0301 7D8C 61C6             data over,block,update
     7D8E 7B9A     
     7D90 7C7E     
0302 7D92 7D34             data whead
0303 7D94 70B8             data lit,3,pick,lit,1008,fvmbw
     7D96 0003     
     7D98 6210     
     7D9A 70B8     
     7D9C 03F0     
     7D9E 6914     
0304 7DA0 70B8             data lit,1008,sub,rot,lit,1008,add,nrot,swap,plus1,swap
     7DA2 03F0     
     7DA4 6318     
     7DA6 618E     
     7DA8 70B8     
     7DAA 03F0     
     7DAC 6310     
     7DAE 61AA     
     7DB0 617A     
     7DB2 62AC     
     7DB4 617A     
0305 7DB6 65D6             data branch,bsave1
     7DB8 7D80     
0306 7DBA 617A     bsave2  data swap,dup,block,update,whead,lit,3,pick,lit,3,pick,fvmbw
     7DBC 6184     
     7DBE 7B9A     
     7DC0 7C7E     
     7DC2 7D34     
     7DC4 70B8     
     7DC6 0003     
     7DC8 6210     
     7DCA 70B8     
     7DCC 0003     
     7DCE 6210     
     7DD0 6914     
0307 7DD2 62AC             data plus1,nip,nip,flush
     7DD4 61D0     
     7DD6 61D0     
     7DD8 7C90     
0308 7DDA 832C             data exit
0309               
0310               
0311               ; BLOAD ( start_block -- )
0312               ; : BLOAD ( block -- next_free_block)
0313               ;   BEGIN DUP BLOCK DUP VW@ $994A = WHILE
0314               ;     2+ DUP VW@ LATEST !  2+ DUP VW@ H !  2+ DUP VW@ SWAP 2+ SWAP
0315               ;     1008 VMBR 1+
0316               ;   REPEAT DROP ;
0317 7DDC 7D6C     bloadh  data bsaveh,5
     7DDE 0005     
0318 7DE0 424C             text 'BLOAD '
     7DE2 4F41     
     7DE4 4420     
0319 7DE6 8320             data docol
0320 7DE8 6184     bload1  data dup,fblock,dup,vdprw,lit,>994a,eq,zbrnch,bload2
     7DEA 7C4A     
     7DEC 6184     
     7DEE 68DA     
     7DF0 70B8     
     7DF2 994A     
     7DF4 646C     
     7DF6 65E8     
     7DF8 7E26     
0321 7DFA 62C0             data plus2,dup,vdprw,lates_,store
     7DFC 6184     
     7DFE 68DA     
     7E00 76CE     
     7E02 6844     
0322 7E04 62C0             data plus2,dup,vdprw,here_,store
     7E06 6184     
     7E08 68DA     
     7E0A 76DC     
     7E0C 6844     
0323 7E0E 62C0             data plus2,dup,vdprw,swap,plus2,swap
     7E10 6184     
     7E12 68DA     
     7E14 617A     
     7E16 62C0     
     7E18 617A     
0324 7E1A 70B8             data lit,1008,fvmbr,plus1
     7E1C 03F0     
     7E1E 6904     
     7E20 62AC     
0325 7E22 65D6             data branch,bload1
     7E24 7DE8     
0326 7E26 6170     bload2  data drop
0327 7E28 7E2C             data memptr         ; adjust ffaihm & ffailm as appropriate
0328 7E2A 832C             data exit
0329 7E2C 7E2E     memptr  data $+2
0330 7E2E C020  34         mov @here,r0
     7E30 A048     
0331 7E32 06A0  28         bl @bank1
     7E34 8332     
0332 7E36 6D56             data mpadj          ; see 1-09-Compilation.a99
0333 7E38 045C  20         b *next
                   < build.asm
0030                   copy "./bank0/0-19-File-IO.asm"
     **** ****     > ./bank0/0-19-File-IO.asm
0001               ;  ______ _ _         _____     ______
0002               ; |  ____(_) |       |_   _|   / / __ \
0003               ; | |__   _| | ___     | |    / / |  | |
0004               ; |  __| | | |/ _ \    | |   / /| |  | |
0005               ; | |    | | |  __/   _| |_ / / | |__| |
0006               ; |_|    |_|_|\___|  |_____/_/   \____/
0007               ; File IO implementation
0008               
0009               ;[ FILE ( s_addr  s_len  buf_addr -- )
0010               ; Builds a PAB in the buffer whose address is passed as buf_addr using the data
0011               ; in the string represented by s_addr and s_len.
0012               ; For example:
0013               ;     FBUF: PRINTER
0014               ;     S" PIO.CR DV80O" PRINTER FILE
0015               ; The above builds a PAB in the buffer called PRINTER which references the PIO
0016               ; device. Subsequent file IO words that wish to send data to the PIO shall use
0017               ; the buffer name to reference it:
0018               ; e.g.
0019               ;     PRINTER #OPEN DROP ( open PIO and drop success/fail flag)
0020               ;     S" HELLO WORLD" PRINTER #PUT DROP
0021               ;     ( write HELLO WORLD to the PIO and drop success/fail flag)
0022               ;
0023               ; Internally, FILE builds a PAB in the buffer which will be used by #OPEN and
0024               ; all file IO words.
0025               ; Word 0 of the reserved memory is used to point to the actual PAB in VDP
0026               ; memory.
0027               ; Enough space should be reserved (with ALLOT) in the buffer to hold the PAB
0028               ; and the filename.
0029               ;
0030               ; The string which specifies the file name and file characteristics is defined
0031               ; as below.
0032               ; The filename *must* come first followed by a space character.
0033               ; After that, the file options can be specified in any order.
0034               ;
0035               ; File Options:
0036               ;  F=Fixed    - Fixed record type
0037               ;  V=Variable    - Variable record type
0038               ;
0039               ;  D=Display    - Display data type
0040               ;  L=InternaL    - Internal data type
0041               ;
0042               ;  U=Update    - Update file mode
0043               ;  O=Output    - Output file mode
0044               ;  I=Input    - Inoput file mode
0045               ;  A=Append    - Append file mode
0046               ;
0047               ;  S=Sequential - Sequential file type
0048               ;  R=Relative    - Relative file type
0049               ;
0050               ; Note that Internal type files require L - this is because I is used to
0051               ; specify INPUT
0052 7E3A 7DDC     fileh   data bloadh,4
     7E3C 0004     
0053 7E3E 4649             text 'FILE'
     7E40 4C45     
0054 7E42 7E44     file1   data $+2
0055 7E44 06A0  28         bl @bank1
     7E46 8332     
0056 7E48 792C             data _file              ; see 1-14-File-IO.a99
0057               ;]
0058               
0059               ;[ FBUF: ( -- )
0060               ; builds a buffer with the name given for use with File IO.
0061               ; The buffer is used to hold the PAB during construction by FILE.
0062               ; e.g. FBUF: MYFILE
0063               ; creates a 42 byte buffer for holding a PAB.
0064               ; MYFILE becomes a word in the dictionary which, when executed, returns the
0065               ; address of the start of the buffer.
0066               ; The buffer is supplied as an input to the file IO words. E.g.
0067               ;   FBUF: DV80 ( create a 42 byte buffer called DV80)
0068               ;   S" DSK1.TEST DV80SO" DV80 FILE
0069               ;   DV80 #OPEN DROP
0070               ;   S" HELLO WORLD" DV80 #PUT DROP
0071               ;   DV80 #CLOSE
0072               ;
0073 7E4A 7E3A     fbufh   data fileh,immed+5
     7E4C 8005     
0074 7E4E 4642             text 'FBUF: '
     7E50 5546     
     7E52 3A20     
0075 7E54 8320     fbuf    data docol
0076 7E56 6F9E             data create         ; create dictionary entry
0077 7E58 70B8             data lit,42,allot   ; reserve 42 bytes
     7E5A 002A     
     7E5C 70A8     
0078 7E5E 832C             data exit
0079               ;]
0080               
0081               ;[ #OPEN ( buf_addr -- t|f )
0082               ; Opens a file with the file name and attributes specified in the buffer
0083               ; starting at file_addr.
0084               ; The buffer (actually a PAB) is set-up with FILE.
0085               ; E.g. FBUF: SERIAL
0086               ;      S" RS232.BA=9600 DV80SO" SERIAL FILE
0087               ;      SERIAL #OPEN
0088               ; The above shall attempt to open the serial port for output as a Display
0089               ; Variable 80 type file.
0090               ;
0091               ; #OPEN leaves a FALSE on the stack if the file was opened sucessfully.
0092               ; If the file could not be opened then it leaves a TRUE on the stack.
0093               ; This allows easy trapping with ABORT" as shown below:
0094               ;   SERIAL #OPEN ABORT" Could not open serial port"
0095               ;
0096               ; In the event of a file error, IOERR can be read to get the DSR error code.
0097               ; If IOERR returns -1 (>FFFF) then this means that no free file IO slots were
0098               ; found. A maximum of 3 open files is supported (2 if block files are also to
0099               ; be used).
0100               ; Note that block files are immediately closed after they are accessed for
0101               ; either reading or writing, so 3 generic file io streams are available
0102               ; when no blocks files are being used.
0103 7E60 7E4A     fopenh  data fbufh,5
     7E62 0005     
0104 7E64 234F             text '#OPEN '
     7E66 5045     
     7E68 4E20     
0105 7E6A 7E6C     fopen1  data $+2
0106 7E6C 06A0  28         bl @bank1
     7E6E 8332     
0107 7E70 79DC             data _fopen              ; see 1-14-File-IO.a99
0108               ;]
0109               
0110               ;[ #CLOSE ( fid -- )
0111               ; closes a file
0112               ; Where a file is opened thus: MYFILE #OPEN
0113               ; the following will close the same file: MYFILE #CLOSE
0114 7E72 7E60     fclosh  data fopenh,6
     7E74 0006     
0115 7E76 2343             text '#CLOSE'
     7E78 4C4F     
     7E7A 5345     
0116 7E7C 7E7E     fclose  data $+2
0117 7E7E 06A0  28         bl @bank1
     7E80 8332     
0118 7E82 7A42             data _fclos              ; see 1-14-File-IO.a99
0119               ;]
0120               
0121               ;[ #GET ( buff_addr fid -- t|f )
0122               ; reads a line of input from the file specified by fid.
0123               ; The address of an appropriately sized buffer must be supplied.
0124               ; If the read is successful, the buffer is filled with the data read from the
0125               ; input device, with the first byte being the length count of the data
0126               ; immediately following it.
0127               ; This can be converted into an address/length pair with COUNT.
0128               ; Returns:
0129               ;  False if successful
0130               ;  True if not successful
0131               ; This allows trapping with ABORT" as follows:
0132               ; MYFILE #GET ABORT" Could not read from the file"
0133               ; If the read fails, IOERR is set to the error code, otherwise it is zero'd
0134 7E84 7E72     fgeth   data fclosh,4
     7E86 0004     
0135 7E88 2347             text '#GET'
     7E8A 4554     
0136 7E8C 7E8E     fget    data $+2
0137 7E8E 06A0  28         bl @bank1
     7E90 8332     
0138 7E92 7A66             data _fget              ; see 1-14-File-IO.a99
0139               ;]
0140               
0141               ;[ #PUT ( buff_addr len fid - t|f )
0142               ; Places a string from buffer_addr with length len to the file represented by
0143               ; fid.
0144               ; Returns false if successful, else returns true.
0145               ; This can be trapped with ABORT"
0146 7E94 7E84     fputh   data fgeth,4
     7E96 0004     
0147 7E98 2350             text '#PUT'
     7E9A 5554     
0148 7E9C 7E9E     fput    data $+2
0149 7E9E 06A0  28         bl @bank1
     7EA0 8332     
0150 7EA2 7AA2             data _fput              ; see 1-14-File-IO.a99
0151               ;]
0152               
0153               ;[ #REC ( record# fid -- )
0154               ; Sets the record number for reading or writing for relative files
0155 7EA4 7E94     frech   data fputh,4
     7EA6 0004     
0156 7EA8 2352             text '#REC'
     7EAA 4543     
0157 7EAC 7EAE     frec    data $+2
0158 7EAE 06A0  28         bl @bank1
     7EB0 8332     
0159 7EB2 7B14             data _frec              ; see 1-14-File-IO.a99
0160               ;]
0161               
0162               ;[ #5LOAD ( "filename" loadAddr -- )
0163 7EB4 7EA4     load5h  data frech,6
     7EB6 0006     
0164 7EB8 4C4F             text 'LOAD#5'
     7EBA 4144     
     7EBC 2335     
0165 7EBE 8320     load5   data docol
0166 7EC0 70B8             data lit,8192,swap
     7EC2 2000     
     7EC4 617A     
0167 7EC6 70B8             data lit,>0500
     7EC8 0500     
0168 7ECA 7EE2             data opt5
0169 7ECC 832C             data exit
0170               ;]
0171               
0172               ;[ #5SAVE ( "filename" size saveAddr -- )
0173 7ECE 7EB4     save5h  data load5h,6
     7ED0 0006     
0174 7ED2 5341             text 'SAVE#5'
     7ED4 5645     
     7ED6 2335     
0175 7ED8 8320             data docol
0176 7EDA 70B8             data lit,>0600
     7EDC 0600     
0177 7EDE 7EE2             data opt5
0178 7EE0 832C             data exit
0179               
0180 7EE2 7EE4     opt5    data $+2
0181 7EE4 06A0  28         bl @bank1           ; addr len size loadAddr opcode
     7EE6 8332     
0182 7EE8 7B4C             data _opt5
0183               ;]
0184               
0185               ;[ #EOF? ( fid -- t|f )
0186               ; returns true if currently positioned at the end of the file referenced by fid
0187 7EEA 7ECE     feofh   data save5h,5
     7EEC 0005     
0188 7EEE 2345             text '#EOF? '
     7EF0 4F46     
     7EF2 3F20     
0189 7EF4 7EF6     feof    data $+2
0190 7EF6 06A0  28         bl @bank1
     7EF8 8332     
0191 7EFA 7B2E             data _feof              ; see 1-14-File-IO.a99
0192               ;]
                   < build.asm
0031                   copy "./bank0/0-20-Sound.asm"
     **** ****     > ./bank0/0-20-Sound.asm
0001               ;          _____                       _  __          __           _
0002               ;         / ____|                     | | \ \        / /          | |
0003               ;        | (___   ___  _   _ _ __   __| |  \ \  /\  / /__  _ __ __| |___
0004               ;         \___ \ / _ \| | | | '_ \ / _` |   \ \/  \/ / _ \| '__/ _` / __|
0005               ;         ____) | (_) | |_| | | | | (_| |    \  /\  / (_) | | | (_| \__ \
0006               ;        |_____/ \___/ \__,_|_| |_|\__,_|     \/  \/ \___/|_|  \__,_|___/
0007               
0008               
0009               ;[ SOUND ( pitch vol ch# -- )
0010 7EFC 7EEA     soundh  data feofh,5
     7EFE 0005     
0011 7F00 534F             text 'SOUND '
     7F02 554E     
     7F04 4420     
0012 7F06 7F08     sound   data $+2
0013 7F08 06A0  28         bl @bank1
     7F0A 8332     
0014 7F0C 7BEC             data sound1     ; see 1-15-Sound.a99
0015               ;]
                   < build.asm
0032                   copy "./bank0/0-21-Editor.asm"
     **** ****     > ./bank0/0-21-Editor.asm
0001               ;  ______     _ _ _               __          __            _
0002               ; |  ____|   | (_) |              \ \        / /           | |
0003               ; | |__    __| |_| |_  ___  _ __   \ \  /\  / /___  _ __ __| |___
0004               ; |  __|  / _` | | __|/ _ \| '__|   \ \/  \/ // _ \| '__/ _` / __|
0005               ; | |____| (_| | | |_| (_) | |       \  /\  /| (_) | | | (_| \__ \
0006               ; |______|\__,_|_|\__|\___/|_|        \/  \/  \___/|_|  \__,_|___/
0007               ; block editor
0008               
0009               lastwd    ; this is the last word in the built-in dictionary
0010               
0011               ;[ EDIT ( block# -- )
0012               ; loads 'block' and invokes the editor
0013               ; on exit from the editor, location TEMP is checked. If not 0, it loads
0014               ; the block number in TEMP.
0015 7F0E 7EFC     edith   data soundh,4
     7F10 0004     
0016 7F12 4544             text 'EDIT'
     7F14 4954     
0017 7F16 8320     edit    data docol
0018 7F18 61FA             data qdup,zbrnch,edit1      ; just exit if block#=0
     7F1A 65E8     
     7F1C 7F58     
0019               
0020                   ; if we happen to be in 32 column mode then switch to 40 column mode
0021 7F1E 7796             data gxmax                  ; get xmax
0022 7F20 70B8             data lit,32,eq              ; is it equal to 32?
     7F22 0020     
     7F24 646C     
0023 7F26 65E8             data zbrnch,edit0           ; just continue if not
     7F28 7F2E     
0024 7F2A 6082             data lit0,gmode             ; otherwise set 40 column mode as default
     7F2C 794E     
0025               
0026 7F2E 6184     edit0   data dup,block,swap         ; get block, block# to tos
     7F30 7B9A     
     7F32 617A     
0027 7F34 6D70             data cls                    ; clear screen
0028 7F36 70B8             data lit,6,lit0,gotoxy      ; set cursor position for block number
     7F38 0006     
     7F3A 6082     
     7F3C 6C82     
0029 7F3E 782C             data dot                    ; display block number
0030 7F40 7F5C             data edit3                  ; invoke editor
0031               
0032                   ; at this point, we have returned from the editor.
0033                   ; Check if the editor has requested another block...
0034                       ;data cls
0035 7F42 70B8             data lit,lstblk,store0
     7F44 A1B6     
     7F46 6884     
0036 7F48 70B8             data lit,temp2,fetch,qdup   ; get value in temp
     7F4A A074     
     7F4C 6822     
     7F4E 61FA     
0037 7F50 65E8             data zbrnch,edit1           ; if 0 just exit
     7F52 7F58     
0038 7F54 65D6             data branch,edit0           ; otherwise, load next block
     7F56 7F2E     
0039               
0040 7F58 6D70     edit1   data cls,exit
     7F5A 832C     
0041               
0042 7F5C 7F5E     edit3   data $+2
0043 7F5E 06A0  28         bl @bank1
     7F60 8332     
0044 7F62 6F1C             data _edit                  ; see 1-11-Editor.a99
0045               ;]
                   < build.asm
0033                   copy "./bank0/0-22-VDP.asm"
     **** ****     > ./bank0/0-22-VDP.asm
0001               ; __      _______  _____    _    _ _   _ _ _ _   _
0002               ; \ \    / /  __ \|  __ \  | |  | | | (_) (_) | (_)
0003               ;  \ \  / /| |  | | |__) | | |  | | |_ _| |_| |_ _  ___ ___
0004               ;   \ \/ / | |  | |  ___/  | |  | | __| | | | __| |/ _ | __|
0005               ;    \  /  | |__| | |      | |__| | |_| | | | |_| |  __|__ \
0006               ;     \/   |_____/|_|       \____/ \__|_|_|_|\__|_|\___|___/
0007               ; VDP access utility routines
0008               
0009               ;[ VDP addresses:
0010      83D7     vblnk	equ >83D7	; vertical blank counter
0011      8800     vdpr	equ >8800	; vdp read register
0012      8C00     vdpw	equ >8C00	; vdp write register
0013      8C02     vdpa	equ >8C02	; vdp address register
0014      8802     vdpst   equ >8802   ; vdp status register
0015               ;]
0016               
0017               ; bit1	data >4000	; used for re-setting bit 1
0018               ; note: bit1 is now defined in LFREE in 0-07-Memory.a99
0019               
0020               ;[ vdp single byte read
0021               ; inputs: r0=address in vdp to read, r1(msb), the byte read from vdp
0022               ; side effects: none
0023 7F64 C820  54 vsbr	mov @bank0,@retbnk	    ; return to bank 0 if interrupt should trigger
     7F66 6068     
     7F68 A070     
0024 7F6A 0300  22         limi 2                  ; briefly enable interrupts
     7F6C 0002     
0025 7F6E 0300  22         limi 0                  ; and switch 'em off again
     7F70 0000     
0026 7F72 06C0  14         swpb r0                 ; get low byte of address
0027 7F74 D800  30 		movb r0,@vdpa           ; write it to vdp address register
     7F76 8C02     
0028 7F78 06C0  14 		swpb r0                 ; get high byte
0029 7F7A D800  30 		movb r0,@vdpa           ; write
     7F7C 8C02     
     **** ****     > NOP
0001 7F7E 1000  14        jmp $+2
                   < 0-22-VDP.asm
0031 7F80 D060  30 		movb @vdpr,r1           ; write payload
     7F82 8800     
     **** ****     > RT
0001 7F84 045B  20        b * r11
                   < 0-22-VDP.asm
0033               ;]
0034               
0035               ;[ vdp multiple byte read
0036               ; inputs: r0=vdp source address, r1=cpu ram destination address
0037               ; r2=number of bytes to read
0038               ; side effects: r1 & r2 changed
0039 7F86 06C0  14 vmbr	swpb r0                 ; get low byte of address
0040 7F88 D800  30 		movb r0,@vdpa           ; write it
     7F8A 8C02     
0041 7F8C 06C0  14 		swpb r0                 ; get high byte of address
0042 7F8E D800  30 		movb r0,@vdpa           ; write it
     7F90 8C02     
0043 7F92 020F  20 		li r15,vdpr             ; cache vdp write register address in r15
     7F94 8800     
0044 7F96 DC5F  40 vmbr1	movb *r15,*r1+          ; fast write to vdp register
0045 7F98 0602  14 		dec r2                  ; finished?
0046 7F9A 16FD  14 		jne vmbr1               ; loop if not
     **** ****     > RT
0001 7F9C 045B  20        b * r11
                   < 0-22-VDP.asm
0048               ;]
0049               
0050               ;[ vdp single byte write
0051               ; inputs: r0=address in vdp to write to, r1(msb)=the byte to write
0052               ; side effects: none
0053 7F9E C820  54 vsbw	mov @bank0,@retbnk	    ; return to bank 0 if interrupt should trigger
     7FA0 6068     
     7FA2 A070     
0054 7FA4 0300  22 		limi 2                  ; briefly enable interrupts
     7FA6 0002     
0055 7FA8 0300  22 		limi 0                  ; but too long, we're British you know
     7FAA 0000     
0056 7FAC 0260  22 vsbw0	ori r0,>4000            ; tell VDP processor "hey, this is a *write*"
     7FAE 4000     
0057 7FB0 06C0  14 		swpb r0                 ; get low byte of address
0058 7FB2 D800  30 		movb r0,@vdpa           ; write it to vdp address register
     7FB4 8C02     
0059 7FB6 06C0  14 		swpb r0                 ; get high byte of address
0060 7FB8 D800  30 		movb r0,@vdpa           ; write it
     7FBA 8C02     
0061 7FBC D801  30 		movb r1,@vdpw           ; write payload
     7FBE 8C00     
0062 7FC0 2820  36 		xor @bit1,r0            ; reset bit 1
     7FC2 6960     
     **** ****     > RT
0001 7FC4 045B  20        b * r11
                   < 0-22-VDP.asm
0064               ;]
0065               
0066               ;[ vdp multiple byte write
0067               ; r0=destination in vdp, r1=source address in cpu ram, r2=number of bytes
0068               ; side effects: r1 & r2 changed
0069 7FC6 C820  54 vmbw	mov @bank0,@retbnk	    ; return to bank 0 if interrupt should trigger
     7FC8 6068     
     7FCA A070     
0070 7FCC 0300  22 		limi 2                  ; briefly enable interrupts
     7FCE 0002     
0071 7FD0 0300  22 		limi 0                  ; this is getting boring now
     7FD2 0000     
0072 7FD4 0260  22 vmbw0	ori r0,>4000            ; if you can't figure this out by now
     7FD6 4000     
0073 7FD8 06C0  14 		swpb r0                 ; then try the Commodore 64
0074 7FDA D800  30 		movb r0,@vdpa           ; it's a much inferior machine
     7FDC 8C02     
0075 7FDE 06C0  14 		swpb r0                 ; with the worlds worst processor
0076 7FE0 D800  30 		movb r0,@vdpa           ; though Chuck Peddle is extremely cool
     7FE2 8C02     
0077 7FE4 020F  20 		li r15,vdpw             ; and you have to hand it to Jack Tramiel too.
     7FE6 8C00     
0078 7FE8 D7F1  40 vmbw1	movb *r1+,*r15          ; Anyway the C64 has much simpler hardware
0079 7FEA 0602  14 		dec r2                  ; and a super simple (i.e. super sucky) CPU
0080 7FEC 16FD  14 		jne vmbw1               ; but hey, it *does* have 64K of ram, the lucky
0081 7FEE 2820  36 		xor @bit1,r0            ; old git.
     7FF0 6960     
     **** ****     > RT
0001 7FF2 045B  20        b * r11
                   < 0-22-VDP.asm
0083               ;]
                   < build.asm
0034                   copy "./bank0/0-23-System.asm"
     **** ****     > ./bank0/0-23-System.asm
0001               ;  ____         __  __                                _
0002               ; |  _ \       / _|/ _|                              | |
0003               ; | |_) |_   _| |_| |_ ___ _ __ ___    __ _ _ __   __| |
0004               ; |  _ <| | | |  _|  _/ _ \ '__/ __|  / _` | '_ \ / _` |
0005               ; | |_) | |_| | | | ||  __/ |  \__ \ | (_| | | | | (_| |
0006               ; |____/ \__,_|_| |_| \___|_|  |___/  \__,_|_| |_|\__,_|
0007               ;     __      __         _       _     _
0008               ;     \ \    / /        (_)     | |   | |
0009               ;      \ \  / /__ _ _ __ _  __ _| |__ | | ___ ___
0010               ;       \ \/ // _` | '__| |/ _` | '_ \| |/ _ | __|
0011               ;        \  /| (_| | |  | | (_| | |_) | |  __|__ \
0012               ;         \/  \__,_|_|  |_|\__,_|_.__/|_|\___|___/
0013               
0014      7FF4     endB0   equ $       ; end of bank 0 marker
0015               
0016                       dorg >a000
0017                       ; note: during initialisation, GPLLNK uses >A000 to >A01F as workspace
0018                       ; to load the upper case characters from console GROM. After this,
0019                       ; the space is re-used.
0020               
0021               ;[ Vectors - the locations of these vectors MUST NOT change between builds
0022 A000          intvec  bss 2       ; vector for INTERPRET       >a000
0023 A002          blkvec  bss 2       ; vector for BLOCK           >a002
0024 A004          numvec  bss 2       ; vector for NUMBER          >a004
0025 A006          fndvec  bss 2       ; vector for FIND            >a006
0026 A008          usrisr  bss 2       ; vector for user isr        >a008
0027 A00A          kdel    bss 2       ; keyboard auto-repeat delay >a00a
0028 A00C          dsrvec  bss 2       ; pointer to DSRLNK vector in bank 1    >a00c
0029 A00E          gplvec  bss 2       ; pointer to GPLLNK vector in bank 1    >a00e
0030 A010          padvec  bss 2       ; pointer to scratchpad restore code in bank 1. >a010
0031                   ; Assembly language vector for returning to TF from external assembly code
0032                   ; that runs in a different workspace.
0033                   ; External assembly code (for example, code written with the TF assembler)
0034                   ; that changes workspace can simply perform a BLWP @>A012 to restore TF's
0035                   ; workspace and jump to NEXT in the inner interpreter, which will restore
0036                   ; normal Forth execution perfectly.
0037 A012          wp      bss 2       ; >a012 - workspace pointer.
0038                                   ; software can actually change TF's workspace while running.
0039                                   ; a copy of the desired workspace address MUST be written
0040                                   ; here so that KEY can restore the correct workspace address
0041                                   ; after its call into the TI ROM.
0042               
0043 A014          pnext   bss 2       ; >a014 pointer to next
0044 A016          pdocon  bss 2       ; >a016 pointer to DOCON's executable code
0045 A018          pcreate bss 2       ; >a018 pointer to CREATE's executable code
0046 A01A          optvec  bss 2       ; vector for installable optimiser
0047                   ; new vectors MUST be added here
0048               ;]
0049               
0050               ;[ memory space pointers
0051 A01C          ffailm  bss 2       ; >a01a first free address in low memory pointer
0052 A01E          ffaihm  bss 2       ; >a01c first free address in hi memory pointer
0053               ;]
0054               
0055               ;[ stack pointers
0056 A020          s0      bss 2       ; reserved for FORTH variable S0 - holds the address of the
0057                                   ; start of the data stack (r4)
0058               
0059 A022          rs0     bss 2       ; address of start of return stack (r5)
0060               ;]
0061               
0062               ;[ screen, keyboard and file I/O
0063 A024          keydev  bss 2       ; keyboard device to use for KSCAN routine in console ROM
0064 A026          cursrd  bss 2       ; cursor delay used in KEY and the editor
0065 A028          noscrl  bss 2       ; suppress screen scrolling. 0=suppress
0066 A02A          scrX    bss 2       ; x co-ordinate of next character to be displayed on screen
0067 A02C          scrY    bss 2       ; y co-ordinate of next character to be displayed on screen
0068 A02E          xmax    bss 2       ; screen width - 32, 40  or 80
0069 A030          ymax    bss 2       ; screen height - always 24
0070 A032          wrap    bss 2       ; used to determine if wrap-around is used by SCROLL
0071 A034          panxy   bss 2       ; starting screen address (top left) of panel
0072 A036          panr    bss 2       ; number of rows in panel
0073 A038          panc    bss 2       ; number of columns in panel
0074 A03A          errnum  bss 2       ; holds io error number of last error
0075               ;]
0076               
0077               ;[ speech synthesis
0078 A03C          spcnt   bss 2       ; number of bytes remaining in speech buffer
0079 A03E          spadr   bss 2       ; address of next byte in speech buffer
0080 A040          spcsvc  bss 2       ; speech service: address of the speech service which should
0081                                   ; be called by the ISR is placed here. (either the routine
0082                                   ; to stream raw speech data, or the routine to feed speech
0083                                   ; ROM addresses).
0084               
0085 A042          synyes  bss 2       ; 0=speech synth not fitted. >FFFF=speech synth detected
0086               ;]
0087               
0088               ;[ parsing/compilation
0089 A044          in      bss 2       ; holds the current index into the terminal input buffer
0090                                   ; (TIB) - used by variable >IN
0091               
0092 A046          latest  bss 2       ; reserved for FORTH variable LATEST, which points to the
0093                                   ; most recently defined word in the dictionary.
0094               
0095 A048          here    bss 2       ; points to the next free byte of memory. When compiling,
0096                                   ; compiled words go HERE.
0097               
0098 A04A          _state  bss 2       ; is the interpreter interpreting (0) or compiling a word
0099                                   ; (!=0).
0100               
0101 A04C          tibsiz  bss 2       ; characters per line: 80 on command line, 64 in blocks
0102 A04E          _span   bss 2       ; the number of characters received by EXPECT.
0103                                   ; See variable #TIB.
0104               
0105 A050          doboot  bss 2       ; "we're booting" flag (>0=booting)
0106 A052          sdelim  bss 2       ; stores the end of string marker (normally ") for S".
0107                                   ; the word .( sets it temporarily to a ) character.
0108               
0109 A054          isdbl   bss 2       ; flag to indicate if NUMBER pushed a double (>0=yes)
0110 A056          dpl     bss 2       ; decimal point location. set by NUMBER (doubles only)
0111 A058          cassen  bss 2       ; if 0 dictionary searches are case sensitive
0112 A05A          source  bss 2       ; source-id. -1=string (via evaluate).
0113                                   ; 0=user input (keyboard/block).
0114               
0115 A05C          dotsin  bss 2       ; flag for .S to use signed or unsigned numbers
0116 A05E          base    bss 2       ; the current base for printing and reading numbers
0117 A060          lbase   bss 2       ; last number base, used by Number to String routine
0118 A062          expcnt  bss 2       ; exponent count, used by Number to String routine
0119 A064          lzi     bss 2       ; leading zero indicator, used by N>S routine to determine
0120                                   ; if leading 0's are ignored.
0121               
0122 A066          dosign  bss 2       ; flag for NTS routine. If >0, then NTS will treat numbers
0123                                   ; as unsigned, set by U. and .
0124               
0125 A068          _warn   bss 2       ; redefinition warnings are suppressed if _warn=0
0126 A06A          coding  bss 2       ; !0 if CODE: compiling is active
0127 A06C          patch   bss 2       ; holds the CFA of latest word created with CREATE in case
0128                                   ; DOES> needs to patch it
0129               ;]
0130               
0131               ;[ misc
0132 A06E          vdpr1   bss 2       ; copy of vdp register 1 (stored at 83d4)
0133 A070          retbnk  bss 2       ; holds bank number to return to as a memory address
0134                                   ; (>6000 or >6002)
0135 A072          temp    bss 2       ; for temporary storage
0136 A074          temp2   bss 2       ; for temporary storage
0137 A076          temp3   bss 2       ; for temporary storage
0138 A078          seed    bss 2       ; seed for random number generation
0139 A07A          sumode  bss 2       ; graphics mode selected from cartridge menu screen
0140               ;]
0141               
0142               ;[ editor variables - only used by the built in editor
0143 A07C          epage   bss 2   ; holds block editor page
0144               ; note: These variables use the same addresses as the compiler reference
0145               ; counters (below). This is safe to do, as the compiler is never in use when
0146               ; the editor is in use, and vice versa. Hence it makes sense to use the same
0147               ; addresses and save some valuable user RAM in low-memory. I'm nice like that.
0148      A07E     csrx    equ $       ; cursor x for editor
0149      A080     csry    equ $+2     ; cursor y for editor
0150      A082     csrflg  equ $+4     ; cursor blink flag for editor
0151      A084     autorp  equ $+6     ; keyboard auto repeat counter
0152      A086     autorl  equ $+8     ; keyboard auto repeat re-load value
0153      A088     edblk   equ $+10    ; block number of the block currently being edited
0154               ;]
0155               
0156               ;[ reference counters for compiler security
0157               ; see the words : and ; in 0-10-Compilation.a99
0158 A07E          ifcnt   bss 2       ; incremented by IF, decremented by THEN
0159 A080          docnt   bss 2       ; incremented by DO, decremented by LOOP & +LOOP
0160 A082          forcnt  bss 2       ; incremented by FOR, decremented by NEXT
0161 A084          cascnt  bss 2       ; incremented by CASE, decremented by ENDCASE
0162 A086          ofcnt   bss 2       ; incremented by OF, decremented by ENDOF
0163 A088          begcnt  bss 2       ; incremented by BEGIN, decremented by UNTIL, REPEAT & AGAIN
0164               ;]
0165               
0166               ;[ sprite buffers
0167 A08A          sal     bss 128     ; sprite attribute list
0168 A10A          smlist  bss 64      ; sprite movement list
0169               ;]
0170               
0171               ;[ Persistable data for file IO
0172 A14A          sav8a   bss 2       ; save data following blwp @dsrlnk (8 or >a)
0173 A14C          savcru  bss 2       ; cru address of the peripheral
0174 A14E          savent  bss 2       ; entry address of dsr or subprogram
0175 A150          savlen  bss 2       ; device or subprogram name length
0176 A152          savpab  bss 2       ; pointer to device or subprogram in the pab
0177 A154          savver  bss 2       ; version # of dsr
0178 A156          flgptr  bss 2       ; pointer to flag in pab (byte 1 in pab)
0179 A158          dsrlws  bss 10      ; data 0,0,0,0,0	; dsrlnk workspace
0180 A162          dstype  bss 22      ; data 0,0,0,0,0,0,0,0,0,0,0
0181 A178          haa     bss 2       ; used to store AA pattern for DSR ROM detection
0182 A17A          namsto  bss 8       ; dsrlnk 8 bytes device name buffer
0183               ;]
0184               
0185               ;[ scratch pab - used for block IO
0186 A182 00       pabopc  byte 0      ; opcode: open, read, etc
0187 A183   00     pabflg  byte 0      ; error code & file type
0188 A184 0000     pabbuf  data 0      ; vdp address of data
0189 A186 00       pablrl  byte 0      ; logical record length
0190 A187   00     pabcc   byte 0      ; output character count
0191 A188 0000     pabrec  data 0      ; record number
0192 A18A 00       pabsco  byte 0      ; screen offset for char
0193 A18B   00     pabnln  byte 0      ; name length
0194 A18C          pabfil  bss 32      ; file name starts here
0195                       even
0196               ;]
0197               
0198               ;[ set up the pab pointers:
0199      8356     namptr  equ >8356   ; address of pointer to name length in PABs
0200      1800     f1pab   equ >1800   ; vdp address of 40 byte PAB buffer for file 1
0201      1828     f1buf   equ >1828   ; vdp address of 256 byte record buffer for file 1
0202      1928     f2pab   equ >1928   ; vdp address of 40 byte PAB buffer for file 2
0203      1950     f2buf   equ >1950   ; vdp address of 256 byte record buffer for file 2
0204      1A50     f3pab   equ >1a50   ; vdp address of 40 byte PAB buffer for file 3
0205      1A78     f3buf   equ >1a78   ; vdp address of 256 byte record buffer for file 3
0206      1B78     pabloc  equ >1b78   ; vdp address of block IO PAB
0207      1BA0     recbuf  equ >1ba0   ; vdp address of data buffer. 128 bytes to store 1 record
0208      1C20     bufadd  equ >1c20   ; vdp address of block buffer 0
0209               
0210 A1AC          falloc  bss 6       ; allocation table for file IO
0211               ; at run time, these 3 words are filled with addresses f1pab, f2pab & f3pab.
0212               ; The MSB is set when a file is in use (i.e. when opened with #OPEN).
0213               ; The MSB is reset when #CLOSE is executed, and thus the file 'slot' can be
0214               ; re-used.
0215               ;]
0216               
0217               ;[ block related data
0218                   ; see 0-18-Blocks.a99
0219      0006     blocks  equ 6       ; number of block buffers
0220 A1B2          totblk  bss 2       ; number of block buffers available
0221 A1B4          blknum  bss 2       ; holds the block currently being compiled by INTERPRET
0222 A1B6          lstblk  bss 2       ; holds the block currently being worked on
0223 A1B8          blk0    bss 2       ; block number of the block stored in buf0 (0=unassigned)
0224 A1BA                  bss 2       ; VDP address of block0 MSB=1=dirty block
0225 A1BC          blk1    bss 2       ; block number of the block stored in buf1 (0=unassigned)
0226 A1BE                  bss 2       ; VDP address of block1  MSB=1=dirty block
0227 A1C0          blk2    bss 2       ; block number of the block stored in buf2 (0=unassigned)
0228 A1C2                  bss 2       ; VDP address of block2  MSB=1=dirty block
0229 A1C4          blk3    bss 2       ; block number of the block stored in buf3 (0=unassigned)
0230 A1C6                  bss 2       ; VDP address of block3  MSB=1=dirty block
0231 A1C8          blk4    bss 2       ; block number of the block stored in buf4 (0=unassigned)
0232 A1CA                  bss 2       ; VDP address of block4  MSB=1=dirty block
0233 A1CC          blk5    bss 2       ; block number of the block stored in buf5 (0=unassigned)
0234 A1CE                  bss 2       ; VDP address of block5  MSB=1=dirty block
0235                                   ; note: the vdp addresses of the block buffers are defined in
0236                                   ; 1-15-Initialise.a99
0237               ;]
0238               
0239               ;[ stacks and buffers
0240                   ; don't change the order of these buffers!
0241 A1D0          tibadr  bss 2       ; address of the terminal input buffer
0242      3420     tib     equ >3420   ; vdp address of terminal input buffer
0243 A1D2          wrdbuf  bss 82
0244 A224          wrkbuf  bss 32      ; work buffer for Number to String routine (holds exponents)
0245 A244          strbuf  bss 18      ; string buffer for Number to String routine to construct
0246                                   ; a string in
0247               ;]
0248               
0249               ;[ data stack and return stack
0250 A256          stacks  bss 114         ; reserve space for data stack and return stack
0251      A28C     retstk  equ stacks+54   ; return stack grows to lower addresses
0252      A2C8     dstack  equ $           ; data stack grows to lower addresses
0253               ;]
0254               
0255               ;[ start of user memory... FORTH programs go here!
0256      A2C8     himem   equ $       ; first free address in hi memory
0257      A2C8     prgtop  equ himem   ; program space - user defined FORTH words start here
0258                                   ; at startup, HERE points to prgtop
0259               ;]
                   < build.asm
0035               
0036               ; bank 1 source files
0037                   copy "./bank1/1-00-Header.asm"
     **** ****     > ./bank1/1-00-Header.asm
0001               ;  _____            _           _____           _   _
0002               ; |_   _|_   _ _ __| |__   ___ |  ___|___  _ __| |_| |__
0003               ;   | | | | | | '__| '_ \ / _ \| |_  / _ \| '__| __| '_ \
0004               ;   | | | |_| | |  | |_) | (_) |  _|| (_) | |  | |_| | | |
0005               ;   |_|  \__,_|_|  |_.__/ \___/|_|   \___/|_|   \__|_| |_|
0006               ; ################################################
0007               ; TurboForth
0008               ; (C) Mark Wills 2010-2012
0009               ; Written in TMS9900 machine code for the TI-99/4A
0010               ; May the Forth be with you.
0011               ; ################################################
0012               ;  ____              _      _
0013               ; | __ )  __ _ _ __ | | __ / |
0014               ; |  _ \ / _` | '_ \| |/ / | |
0015               ; | |_) | (_| | | | |   <  | |
0016               ; |____/ \__,_|_| |_|_|\_\ |_|
0017               ;
0018               ; This is bank 1 - the secondary bank
0019               ; This bank consists of subroutines called by bank 0
0020               ;
0021               ; Cartridge header. Unfortunatley, we cannot know for sure that the
0022               ; correct bank will be selected at power-up, thus we need to duplicate
0023               ; the cartridge header here. This header is slightly different however,
0024               ; it copies a simple bootstrap routine to pad ram which selects bank 0
0025               ; and then jumps to the real bootstrap code in bank 0
0026               
0027                       aorg >6000                  ; cartridge rom
0028               
0029                   ; cartridge ROM header
0030               
0031 6000 AA               byte >aa                    ; standard header
0032 6001   0C             byte >0c                    ; version number
0033 6002 01               byte >01                    ; number of programs
0034 6003   00             byte >00                    ; not used
0035 6004 0000             data >0000                  ; pointer to power-up list
0036 6006 600C             data menu                   ; pointer to program list
0037 6008 0000             data 0                      ; pointer to DSRL list
0038 600A 0000             data 0                      ; pointer to subprogram list
0039               
0040 600C 6026             data menu40                 ; pointer to next menu item
0041 600E 605A             data start80                ; code entry point
0042 6010 14               byte 20                     ; length of text
0043 6011   54             text 'TURBOFORTH 80 COLUMN'
     6012 5552     
     6014 424F     
     6016 464F     
     6018 5254     
     601A 4820     
     601C 3830     
     601E 2043     
     6020 4F4C     
     6022 554D     
     6024 4E       
0044                       even
0045 6026 0000             data 0                      ; no more menu entries
0046 6028 6050             data start40                ; code entry point (see below)
0047 602A 11               byte 17                     ; length of text
0048 602B   54             text 'TURBOFORTH V1.2.3 (c) 2016 Mark Wills'
     602C 5552     
     602E 424F     
     6030 464F     
     6032 5254     
     6034 4820     
     6036 5631     
     6038 2E32     
     603A 2E33     
     603C 2028     
     603E 6329     
     6040 2032     
     6042 3031     
     6044 3620     
     6046 4D61     
     6048 726B     
     604A 2057     
     604C 696C     
     604E 6C73     
0049                       even
0050               
0051               ; 40 column mode entry point
0052 6050 02E0  18         lwpi wkspc
     6052 8300     
0053 6054 04E0  34         clr @sumode
     6056 A07A     
0054 6058 1009  14         jmp startB1
0055               
0056               ; 80 column mode entry point
0057 605A 02E0  18         lwpi wkspc
     605C 8300     
0058 605E 0200  20         li r0,2
     6060 0002     
0059 6062 C800  38         mov r0,@sumode
     6064 A07A     
0060 6066 1002  14         jmp startB1
0061               
0062               ; codes for bank 0 and bank 1 - used by the interrupt handler to determine
0063               ; which bank to return to after processing an interrupt.
0064               ; Set by the VDP routines (see 0-21-VDP.a99).
0065               ; DO NOT MOVE THESE! Identical definitions are made in bank 0, and they MUST
0066               ; be at identical addresses!
0067 6068 6002             data >6002                  ; code to select bank 0
0068 606A 6000             data >6000                  ; code to select bank 1
0069               
0070               
0071 606C 0300  22 startB1 limi 0                      ; no interrupts - we're British
     606E 0000     
0072 6070 04E0  34         clr @>6000                  ; select bank1
     6072 6000     
0073 6074 0460  28         b @init                     ; init is defined in 1-15-Initialise.a99
     6076 7C32     
                   < build.asm
0038                   copy "./bank1/1-01-ISR.asm"
     **** ****     > ./bank1/1-01-ISR.asm
0001               ;  _____       _                              _
0002               ; |_   _|     | |                            | |
0003               ;   | |  _ __ | |_  ___ _ __ _ __ _   _ _ __ | |_
0004               ;   | | | '_ \| __|/ _ \ '__| '__| | | | '_ \| __|
0005               ;  _| |_| | | | |_|  __/ |  | |  | |_| | |_) | |_
0006               ; |_____|_| |_|\__|\___|_|  |_|   \__,_| .__/ \__|
0007               ;                                      | |
0008               ;                                      |_|
0009               ;  _____                       _        _
0010               ; |  __ \                     | |      | |
0011               ; | |  | | ___ ___ _ __   __ _| |_  ___| |__   ___ _ __
0012               ; | |  | |/ _ | __| '_ \ / _` | __|/ __| '_ \ / _ \ '__|
0013               ; | |__| |  __|__ \ |_) | (_| | |_| (__| | | |  __/ |
0014               ; |_____/ \___|___/ .__/ \__,_|\__|\___|_| |_|\___|_|
0015               ;                 | |
0016               ;                 |_|
0017               ; ISR despatcher - determines which ISR to call
0018               ; Speech is serviced every frame, sprites and music are serviced every alternate
0019               ; frame.
0020               
0021 6078 C28B  18 isrdes  mov r11,r10                 ; save return address to pad isr
0022               
0023               ; Speech Handling ISR
0024               ; Called every frame
0025               ; Checks to see if there is any speech to process, if not, just exits
0026               ; If there is, either calls ROMSPK to speak words from the speech ROM or calls
0027               ; STRSPK to send a raw byte stream to the synth, depending on the address loaded
0028               ; into SPCSVC.
0029               ;
0030               ; First service any speech that is waiting to be sent to the speech synth
0031               ; if no speech is outstanding then exit the isr completely...
0032 607A C020  34 speech  mov @spcsvc,r0              ; get speech service address in r0
     607C A040     
0033 607E 1301  14         jeq isrnxt                  ; if 0 then there is no speech to process so
0034 6080 0450  20         b *r0                       ; exit otherwise jump to the routine
0035               
0036               ; check user isr
0037 6082 C020  34 isrnxt  mov @usrisr,r0              ; get user interrupt service routine address
     6084 A008     
0038 6086 1301  14         jeq isrout                  ; if zero then quit isr processing
0039 6088 0690  24         bl *r0                      ; otherwise branch and link to user ISR
0040                                                   ; (user ISR code should execute an RT to
0041                                                   ; return here)
0042               
0043 608A 0460  24 isrout  b @isrxit                   ; return to Forth environment
     608C 8354     
0044               
0045               ; ------------------------------------------------------------------------------
0046               
0047      0008     refill  equ 8                       ; # of bytes to refill the synth fifo with
0048               ;[ 'stream-speak' routine to feed raw speech bytes to the speech synth
0049               strspk
0050                   ; if speech synth is already busy then just exit, we'll start up proper
0051                   ; when the synth is idle...
0052 608E 06A0  28         bl @spstat                  ; get speech synth status
     6090 8340     
0053 6092 C020  30         mov @spdata,r0              ; get the status from pad ram
     6094 834A     
0054 6096 0240  22         andi r0,>8000               ; check busy flag
     6098 8000     
0055 609A 162A  14         jne strxit                  ; exit if busy
0056                   ; speech unit is idle... fill fifo with 16 bytes of speech data...
0057 609C C020  34         mov @spadr,r0               ; address of speech data
     609E A03E     
0058 60A0 0202  20         li r2,16                    ; 16 bytes to fill the fifo
     60A2 0010     
0059 60A4 D830  48 strsp2  movb *r0+,@spchwt           ; write a byte to the speech synth
     60A6 9400     
0060 60A8 0602  14         dec r2                      ; decrement loop counter
0061 60AA 16FC  14         jne strsp2                  ; loop if not finished
0062 60AC 0201  20         li r1,-16                   ; reduce bytes remaining by 16
     60AE FFF0     
0063 60B0 A801  38         a r1,@spcnt                 ; store it
     60B2 A03C     
0064 60B4 C800  38         mov r0,@spadr               ; store address of data
     60B6 A03E     
0065 60B8 0200  20         li r0,strsp3                ; new entry point for the next interrupt
     60BA 60C2     
0066 60BC C800  38         mov r0,@spcsvc              ; load it
     60BE A040     
0067 60C0 1017  14         jmp strxit                  ; quit. we'll enter at STRSP3 on the next
0068                                                   ; interrupt
0069                   ; check fifo level. If fifo low, stream 8 bytes (or until data is exhausted)
0070                   ; to the fifo
0071 60C2 06A0  28 strsp3  bl @spstat                  ; get synth status
     60C4 8340     
0072 60C6 C020  30         mov @spdata,r0              ; move status from pad ram
     60C8 834A     
0073 60CA 0240  22         andi r0,>4000               ; check fifo low bit
     60CC 4000     
0074 60CE 1310  14         jeq strxit                  ; if not on, then exit - fifo doesn't need
0075                                                   ; filling
0076 60D0 C020  34         mov @spadr,r0               ; buffer address
     60D2 A03E     
0077 60D4 C060  34         mov @spcnt,r1               ; bytes remaining
     60D6 A03C     
0078 60D8 0202  20         li r2,refill                ; 'refill' bytes to stream
     60DA 0008     
0079 60DC D830  48 strnb   movb *r0+,@spchwt           ; send a byte to the fifo
     60DE 9400     
0080 60E0 0601  14         dec r1                      ; decrement bytes remaining count
0081 60E2 1307  14         jeq strcu                   ; if all data exhausted then clean up
0082 60E4 0602  14         dec r2                      ; decrement counter
0083 60E6 16FA  14         jne strnb                   ; do next byte if not finished
0084 60E8 C800  38         mov r0,@spadr               ; store address
     60EA A03E     
0085 60EC C801  38         mov r1,@spcnt               ; store count
     60EE A03C     
0086 60F0 10C8  14 strxit  jmp isrnxt                  ; go check user isr
0087                   ; we've streamed all the data, clean up and exit
0088 60F2 04E0  34 strcu   clr @spcsvc                 ; clear speech service pointer - we're done
     60F4 A040     
0089 60F6 04E0  34         clr @spcnt                  ; there's no bytes left to stream
     60F8 A03C     
0090 60FA 10C3  14         jmp isrnxt                  ; go check user isr
0091               ;]
0092               
0093               ;[ 'rom-speak' routine to feed rom addresses to the speech synth
0094               romspk  ; check speech synth, exit if synth is busy...
0095 60FC 06A0  28         bl @spstat                  ; get status from speech synth into
     60FE 8340     
0096                                                   ; scratch-pad ram
0097 6100 C020  30         mov @spdata,r0              ; get the data from speech synth
     6102 834A     
0098 6104 0240  22         andi r0,>8000               ; speech synth busy?
     6106 8000     
0099 6108 1613  14         jne romspx                  ; exit if busy
0100                   ; speech synth isn't busy... send a word of data...
0101 610A C060  34         mov @spadr,r1               ; get address of data word
     610C A03E     
0102 610E C031  30         mov *r1+,r0                 ; get the word in r0 for spaddr
0103 6110 C801  38         mov r1,@spadr               ; update buffer address
     6112 A03E     
0104                   ; convert the address to nybbles and send to the speech synth...
0105 6114 06A0  32         bl @spaddr                  ; load the address contained in r0
     6116 6714     
0106                   ; 42uS delay required before the 'talk' command can be issued to the speech
0107                   ; synth. see editor/assembler manual, section 22.1.1, page 349
0108 6118 0200  20         li r0,20
     611A 0014     
0109 611C 0600  14 dly42   dec r0                      ; spin the wheels...
0110 611E 16FE  14         jne dly42
0111                   ; send 'talk from rom' opcode to speech synth to make the synth actually
0112                   ; talk...
0113 6120 D820  54         movb @spkROM,@spchwt        ; send 'speak from rom op-code'
     6122 668C     
     6124 9400     
0114                                                   ; synth is now talking
0115                   ; do isr housekeeping...
0116 6126 0620  34         dec @spcnt                  ; decrement 'speech data remaining' counter
     6128 A03C     
0117 612A 1602  14         jne romspx                  ; if not zero then just exit
0118 612C 04E0  34         clr @spcsvc                 ; otherwise clear speech-service-routine
     612E A040     
0119                                                   ; pointer since there is no more data to
0120                                                   ; service.
0121 6130 0460  24 romspx  b @isrxit                   ; return to next stage of isr handler
     6132 8354     
0122                                                   ; (in 1-15-initialise.a99)
0123               ;]
0124               ; end of speech ISR
0125               ; -----------------------------------------------------------------------------
                   < build.asm
0039                   copy "./bank1/1-02-Console.asm"
     **** ****     > ./bank1/1-02-Console.asm
0001               ;   _____                       _       __          __            _
0002               ;  / ____|                     | |      \ \        / /           | |
0003               ; | |      ___  _ __  ___  ___ | | ___   \ \  /\  / /___  _ __ __| |___
0004               ; | |     / _ \| '_ \/ __|/ _ \| |/ _ \   \ \/  \/ // _ \| '__/ _` / __|
0005               ; | |____| (_) | | | \__ \ (_) | |  __/    \  /\  /| (_) | | | (_| \__ \
0006               ;  \_____|\___/|_| |_|___/\___/|_|\___|     \/  \/  \___/|_|  \__,_|___/
0007               ;  Console IO words
0008               
0009               ;[ PAGE ( -- ) see 0-09-Console.a99
0010 6134 C060  34 _cls    mov @xmax,r1                ; calculate the character count
     6136 A02E     
0011 6138 0200  20         li r0,24                    ; according to the...
     613A 0018     
0012 613C 3840  58         mpy r0,r1                   ; ...text mode
0013 613E 04C0  14         clr r0                      ; screen address
0014 6140 0201  20         li r1,>2000                 ; space character
     6142 2000     
0015 6144 06A0  32         bl @vsbwmi                  ; wipe screen
     6146 78B2     
0016 6148 04E0  34         clr @scrX                   ; zero x coordinate
     614A A02A     
0017 614C 04E0  34         clr @scrY                   ; zero y coordinate
     614E A02C     
0018 6150 0460  24         b @retB0
     6152 833A     
0019               ;]
0020               
0021               ;[ JOYST ( joystick# -- value )
0022               ; Scans the joystick returning the direction value
0023 6154 C054  26 _joyst  mov *stack,r1               ; get unit number
0024 6156 0221  22         ai r1,6                     ; use keyboard select 6 for #0, 7 for #1
     6158 0006     
0025 615A 06C1  14         swpb r1
0026 615C 020C  20         li r12,36
     615E 0024     
0027 6160 30C1  30         ldcr r1,3
0028 6162 020C  20         li r12,6
     6164 0006     
0029 6166 3541  46         stcr r1,5
0030 6168 06C1  14         swpb r1
0031 616A 0541  14         inv r1
0032 616C 0241  22         andi r1,>001f
     616E 001F     
0033 6170 C501  30         mov r1,*stack
0034 6172 020C  20         li r12,_next
     6174 8326     
0035 6176 C80C  30         mov r12,@>83d6              ; defeat auto screen blanking
     6178 83D6     
0036 617A C820  54         mov @bank1_,@retbnk         ; return to bank 1 if interuupts should fire
     617C 606A     
     617E A070     
0037 6180 0300  22         limi 2                      ; briefly enable interrupts
     6182 0002     
0038 6184 0300  22         limi 0                      ; and turn 'em off again
     6186 0000     
0039 6188 0460  24         b @retb0                    ; return to caller in bank 0
     618A 833A     
0040               ;]
0041               
0042               
                   < build.asm
0040                   copy "./bank1/1-03-Graphics.asm"
     **** ****     > ./bank1/1-03-Graphics.asm
0001               ;   _____                 _     _           __          __            _
0002               ;  / ____|               | |   (_)          \ \        / /           | |
0003               ; | |  __ _ __ __ _ _ __ | |__  _  ___ ___   \ \  /\  / /___  _ __ __| |___
0004               ; | | |_ | '__/ _` | '_ \| '_ \| |/ __/ __|   \ \/  \/ // _ \| '__/ _` / __|
0005               ; | |__| | | | (_| | |_) | | | | | (__\__ \    \  /\  /| (_) | | | (_| \__ \
0006               ;  \_____|_|  \__,_| .__/|_| |_|_|\___|___/     \/  \/  \___/|_|  \__,_|___/
0007               ;                  | |
0008               ;                  |_|
0009               ; graphics related commands
0010               
0011               ;[ GMODE ( gmode -- )
0012 618C C234  30 _gmode  mov *stack+,r8              ; pop gmode
0013 618E 0288  22         ci r8,0                     ; 40 column mode?
     6190 0000     
0014 6192 1306  14         jeq s40col                  ; jump if yes
0015 6194 0288  22         ci r8,1                     ; 32 column mode?
     6196 0001     
0016 6198 1306  14         jeq s32col                  ; jump if yes
0017 619A 0288  22         ci r8,2                     ; 80 column mode?
     619C 0002     
0018 619E 1306  14         jeq s80col                  ; jump if yes
0019                                                   ; otherwise illegal graphics mode selected,
0020                                                   ; so fall through to 40 column mode...
0021 61A0 0202  20 s40col  li r2,col40d                ; vdp register data for 40 column mode
     61A2 6224     
0022 61A4 1005  14         jmp ldvdpr                  ; go load the vdp registers
0023 61A6 0202  20 s32col  li r2,col32d                ; vdp register data for 32 column mode
     61A8 622E     
0024 61AA 1002  14         jmp ldvdpr                  ; go load the vdp registers
0025 61AC 0202  20 s80col  li r2,col80d                ; vdp register data for 80 column mode
     61AE 6238     
0026                   ; load the vdp registers
0027 61B0 C1C2  18 ldvdpr  mov r2,r7                   ; save address for later
0028 61B2 D072  28         movb *r2+,r1                ; number of registers to load
0029 61B4 0881  32         sra r1,8                    ; move the count to the low byte
0030 61B6 04C0  14         clr r0                      ; start with register 0
0031 61B8 D032  28 ldvdpl  movb *r2+,r0                ; get register data in r0 MSB
0032 61BA 06C0  14         swpb r0                     ; swap it over
0033 61BC 06A0  32         bl @_vwtr                   ; write the register
     61BE 78D0     
0034 61C0 06C0  14         swpb r0                     ; swap it back again
0035 61C2 0580  14         inc r0                      ; add 1 to register
0036 61C4 0601  14         dec r1                      ; finished?
0037 61C6 16F8  14         jne ldvdpl                  ; repeat if not
0038                   ; set XMAX...
0039 61C8 D012  26         movb *r2,r0                 ; get xmax
0040 61CA 0880  32         sra r0,8                    ; move to low byte
0041 61CC C800  38         mov r0,@xmax                ; set xmax
     61CE A02E     
0042 61D0 05C7  14         inct r7                     ; point to vdp r1 data
0043 61D2 D817  38         movb *r7,@>83d4             ; write vdp r1 to >83d4
     61D4 83D4     
0044 61D6 D817  46         movb *r7,@VDPR1             ; save copy
     61D8 A06E     
0045                   ; now clear the screen...
0046 61DA C060  34         mov @xmax,r1                ; calculate the character count
     61DC A02E     
0047 61DE 0200  20         li r0,24                    ; according to the...
     61E0 0018     
0048 61E2 3840  58         mpy r0,r1                   ; ...text mode
0049 61E4 04C0  14         clr r0                      ; screen address
0050 61E6 0201  20         li r1,>2000                 ; space character
     61E8 2000     
0051 61EA 06A0  32         bl @vsbwmi                  ; wipe screen
     61EC 78B2     
0052 61EE 04E0  34         clr @scrX                   ; zero x coordinate
     61F0 A02A     
0053 61F2 04E0  34         clr @scrY                   ; zero y coordinate
     61F4 A02C     
0054 61F6 0288  22         ci r8,1                     ; was 32 column mode selected?
     61F8 0001     
0055 61FA 1613  14         jne gmodex                  ; if not, then exit
0056                   ; load colour table for pattern mode...
0057 61FC 0200  20         li r0,>380                  ; color table
     61FE 0380     
0058 6200 0201  20         li r1,>f000                 ; white on transparent
     6202 F000     
0059 6204 0202  20         li r2,16                    ; count
     6206 0010     
0060 6208 06A0  32         bl @vsbwmi                  ; load colour table
     620A 78B2     
0061                   ; initialise sprite attribute list...
0062 620C 0200  20         li r0,>303                  ; address of colour byte
     620E 0303     
0063 6210 04C1  14         clr r1                      ; transparent colour
0064 6212 0202  20         li r2,32                    ; 32 sprites
     6214 0020     
0065 6216 06A0  32 dovdp2  bl @_vsbw0                  ; write to sprite
     6218 785E     
0066 621A 0220  22         ai r0,4                     ; move to next sprite
     621C 0004     
0067 621E 0602  14         dec r2                      ; decrement count
0068 6220 16FA  14         jne dovdp2                  ; repeat if not finished
0069 6222 1017  14 gmodex  jmp gexit
0070               col40d    ; register count and data
0071 6224 0800             byte 8,>00,>f0,>00,>0e,>01,>06,>00,>f4
     6226 F000     
     6228 0E01     
     622A 0600     
     622C F4       
0072 622D   28             byte 40    ; XMAX
0073               col32d    ; register count and data
0074 622E 0800             byte 8,>00,>e0,>00,>0e,>01,>06,>02,>f4
     6230 E000     
     6232 0E01     
     6234 0602     
     6236 F4       
0075 6237   20             byte 32 ; XMAX
0076               col80d    ; register count and data
0077 6238 0F04             byte 15,>04,>70,>03,>e8,>01,>06,>00,>f4,>88,>00,>00,>00,>94,>10,>00
     623A 7003     
     623C E801     
     623E 0600     
     6240 F488     
     6242 0000     
     6244 0094     
     6246 1000     
0078 6248 50               byte 80 ; XMAX
0079                       even
0080               ;]
0081               
0082               ;[ HCHAR ( y x ascii count -- )
0083 624A 06A0  32 _hchar  bl @get4                    ; get parameters from stack and calculate
     624C 65E0     
0084                                                   ; screen address
0085 624E 06A0  32         bl @_vsbwm                  ; write to screen
     6250 78A4     
0086 6252 0460  24 gexit   b @retB0
     6254 833A     
0087               ;]
0088               
0089               ;[ VCHAR ( y x ascii count -- )
0090 6256 06A0  32 _vchar  bl @get4                    ; get parameters from stack and calculate
     6258 65E0     
0091                                                   ; screen address
0092 625A 0206  20         li r6,24                    ; row count
     625C 0018     
0093 625E 39A0  74         mpy @xmax,r6                ; max visible address+1 (in r7)
     6260 A02E     
0094 6262 0607  14         dec r7                      ; correct max visible (we count from 0)
0095 6264 C1A0  34         mov @xmax,r6                ; get xmax in a register
     6266 A02E     
0096 6268 06A0  32 vchar1  bl @_vsbw                   ; write a character
     626A 7850     
0097 626C A006  18         a r6,r0                     ; move down one line
0098 626E 81C0  18         c r0,r7                     ; gone off end of screen?
0099 6270 1201  14         jle vchar2                  ; skip if not
0100 6272 6007  18         s r7,r0                     ; reduce address
0101 6274 0602  14 vchar2  dec r2                      ; decrement count
0102 6276 16F8  14         jne vchar1                  ; repeat if not finished
0103 6278 10EC  14         jmp gexit
0104               ;]
0105               
0106               ;[ GCHAR ( y x -- ascii )
0107 627A 06A0  32 _gchar  bl @get2                    ; get y & x from stack
     627C 65E8     
0108 627E 39A0  74         mpy @xmax,r6                ; compute y
     6280 A02E     
0109 6282 A007  18         a r7,r0                     ; compute screen address
0110 6284 04C1  14         clr r1                      ; use r1 for byte operations
0111 6286 06A0  32         bl @_vsbr                   ; read byte from vdp
     6288 7816     
0112 628A 06C1  14         swpb r1                     ; move byte to lsb
0113 628C 0644  14         dect stack                  ; make space on stack
0114 628E C501  30         mov r1,*stack               ; place on stack as 16 bit word
0115 6290 10E0  14         jmp gexit
0116               ;]
0117               
0118               ;[ DCHAR ( address count ascii -- )
0119               ; Equivalent to CALL CHAR in BASIC.
0120               ; Used to define a character.
0121               ; Moves count words from address to ascii address in VDP memory
0122 6292 06A0  32 _dchar  bl @sget3                   ; get 3 parameters
     6294 65D8     
0123 6296 C249  18         mov r9,r9                   ; if count=0 then...
0124 6298 13DC  14         jeq gexit                   ; ...just exit
0125 629A C008  18         mov r8,r0                   ; ascii
0126 629C 0A30  30         sla r0,3                    ; multiply by 8
0127 629E 0220  22         ai r0,>800                  ; add pattern table offset
     62A0 0800     
0128 62A2 C04A  18         mov r10,r1                  ; source address
0129 62A4 C089  18         mov r9,r2                   ; count
0130 62A6 0A12  26         sla r2,1                    ; convert from words to bytes
0131 62A8 06A0  32         bl @_vmbw                   ; write to vdp
     62AA 7878     
0132 62AC 10D2  14         jmp gexit
0133               ;]
0134               
0135               ;[ SPRITE ( sprite y x ascii color -- )
0136               ; sprite attribute list begins at 6*80h=300h
0137 62AE 06A0  32 _sprit  bl @sget5                   ; get 5 parameters
     62B0 65D4     
0138 62B2 0609  14         dec r9                      ; correct for screen to char alignment
0139 62B4 0A2A  28         sla r10,2                   ; multiply sprite by 4 (offset into SAL)
0140 62B6 020B  20         li r11,sal                  ; address of SAL in CPU ram
     62B8 A08A     
0141 62BA 0200  20         li r0,>300                  ; address of SAL in VDP ram
     62BC 0300     
0142 62BE A2CA  18         a r10,r11                   ; add offset to cpu addr according to
0143                                                   ; sprite number
0144 62C0 C04B  18         mov r11,r1                  ; cpu source for vmbw
0145 62C2 A00A  18         a r10,r0                    ; destination address for vmbw
0146 62C4 06C6  14         swpb r6                     ; rotate colour
0147 62C6 06C7  14         swpb r7                     ; rotate ascii
0148 62C8 06C8  14         swpb r8                     ; rotate x
0149 62CA 06C9  14         swpb r9                     ; rotate y
0150 62CC DEC9  32         movb r9,*r11+               ; move y to cpu buffer
0151 62CE DEC8  32         movb r8,*r11+               ; move x to cpu buffer
0152 62D0 DEC7  32         movb r7,*r11+               ; move ascii to cpu buffer
0153 62D2 DEC6  32         movb r6,*r11+               ; move colour to cpu buffer
0154 62D4 0202  20         li r2,4
     62D6 0004     
0155 62D8 06A0  32         bl @_vmbw                   ; copy entry from SAL to appropriate sprite
     62DA 7878     
0156                                                   ; address in VDP
0157 62DC 0460  24 sprtx   b @retB0
     62DE 833A     
0158               ;]
0159               
0160               ;[ COINC ( tolerance spr1 spr2 -- flag )
0161               ; check for coincidence between sprite spr1 and spr2. If both the horizontal
0162               ; and vertical difference between the two sprites is < tolerance then the
0163               ; sprites are considered to be in coincidence with each other and flag shall be
0164               ; true, otherwise it shall be false.
0165 62E0 C820  54 _coinc  mov @bank1_,@retbnk         ; return to bank 1 if taking interrupt
     62E2 606A     
     62E4 A070     
0166 62E6 0300  22         limi 2                      ; let interrupts run
     62E8 0002     
0167 62EA 0300  22         limi 0
     62EC 0000     
0168 62EE C0B4  30         mov *stack+,r2              ; get spr2
0169 62F0 C074  30         mov *stack+,r1              ; get spr1
0170 62F2 D020  30         movb @>837b,r0              ; get vdp status register (ed/as pg. 405)
     62F4 837B     
0171 62F6 0240  22         andi r0,>2000               ; check collision bits
     62F8 2000     
0172 62FA 1316  14         jeq miss                    ; if NO sprites are in collision then
0173                                                   ; don't do the rest of the test.
0174                   ; some sprites are in collision, so....
0175 62FC 0A21  28         sla r1,2                    ; spr1 * 4
0176 62FE 0A22  28         sla r2,2                    ; spr2 * 4
0177 6300 0206  20         li r6,sal                   ; address of sprite attribute list
     6302 A08A     
0178 6304 A046  18         a r6,r1                     ; address of spr1 in sal
0179 6306 A086  18         a r6,r2                     ; address of spr2 in sal
0180                   ; check row coordinates
0181 6308 06A0  32         bl @chkcnc                  ; check for coincidence
     630A 6318     
0182 630C 140D  14         jhe miss                    ; if more than tolerance it's a miss so...
0183                   ; check column coordinates
0184 630E 06A0  32 chkrow  bl @chkcnc
     6310 6318     
0185 6312 140A  14         jhe miss                    ; if distance > tolerance then its a miss
0186 6314 0714  26         seto *stack                 ; otherwise it's a hit
0187 6316 10E2  14         jmp sprtx                   ; exit
0188               ; subroutine: check distance between sprites
0189 6318 D231  28 chkcnc  movb *r1+,r8                ; get spr1 coordinate
0190 631A D272  28         movb *r2+,r9                ; get spr2 coordinate
0191 631C 0988  40         srl r8,8                    ; spr2 row to low byte
0192 631E 0989  40         srl r9,8                    ; spr2 row to low byte
0193 6320 6248  18         s r8,r9                     ; subtract
0194 6322 0749  18         abs r9                      ; ignore sign
0195 6324 8509  26         c r9,*stack                 ; compare to tolerance
     **** ****     > RT
0001 6326 045B  20        b * r11
                   < 1-03-Graphics.asm
0197                   ; report a miss...
0198 6328 04D4  26 miss    clr *stack
0199 632A 10D8  14 coincx  jmp sprtx                   ; exit
0200               
0201               ;]
0202               
0203               ;[ MAGNIFY ( x -- )
0204               ; sets sprite magnification:
0205               ; only the least significant bits are used:
0206               ; bit 7: 1=magnified (0=not magnified)
0207               ; bit 6: 1=double size (4 character)
0208               ; Remember: TI number their bits backwards! Idiots!
0209 632C C2B4  30 _magfy  mov *stack+,r10             ; pop x
0210 632E 06CA  14         swpb r10                    ; get value in msb
0211 6330 024A  22         andi r10,>0300              ; mask out any crap
     6332 0300     
0212 6334 0200  20         li r0,>0001                 ; vdp register number in lsb
     6336 0001     
0213 6338 04C2  14         clr r2                      ; prepare for byte operations
0214 633A D0A0  34         movb @VDPR1,r2              ; get copy of VDP R1
     633C A06E     
0215 633E 0242  22         andi r2,>fc00               ; mask out magnification bits
     6340 FC00     
0216 6342 F282  18         socb r2,r10                 ; OR in new magnification value
0217 6344 D00A  18         movb r10,r0                 ; place in r0 msb
0218 6346 D800  30         movb r0,@>83d4              ; place copy in 83d4
     6348 83D4     
0219 634A D800  38         movb r0,@VDPR1              ; reserve copy (VDP regs are read only)
     634C A06E     
0220 634E 06C0  14         swpb r0                     ; rotate
0221 6350 06A0  32         bl @_vwtr                   ; set the register
     6352 78D0     
0222 6354 10C3  14         jmp sprtx
0223               ;]
0224               
0225               ;[ SPRCOL ( sprite# colour -- )
0226               ; sets the colour of a sprite
0227 6356 C274  30 _spcol  mov *stack+,r9              ; pop colour
0228 6358 C2B4  30         mov *stack+,r10             ; pop sprite#
0229 635A 0200  20         li r0,>300+3                ; SAL in vdp (offset to colour byte added)
     635C 0303     
0230 635E 0208  20         li r8,SAL+3                 ; SAL in CPU (offset to colour byte added)
     6360 A08D     
0231 6362 0A2A  28         sla r10,2                   ; multiply sprite number by 4
0232 6364 A00A  18         a r10,r0                    ; point to correct address in vdp
0233 6366 A20A  18         a r10,r8                    ; point to correct address in CPU SAL
0234 6368 06C9  14         swpb r9                     ; rotate colour into MSB
0235 636A C049  18         mov r9,r1                   ; into r1 for VSBW
0236 636C D609  30         movb r9,*r8                 ; load into CPU SAL
0237 636E 06A0  32         bl @_vsbw                   ; write colour byte into VDP
     6370 7850     
0238 6372 10B4  14         jmp sprtx
0239               ;]
0240               
0241               ;[ SPRLOC ( sprite y x -- )
0242               ; sets the location of a sprite
0243 6374 06A0  32 _sploc  bl @sget3                   ; get 3 parameters from stack
     6376 65D8     
0244 6378 0609  14         dec r9                      ; correct for screen to char alignment
0245 637A 0200  20         li r0,>300                  ; address of SAL in VDP
     637C 0300     
0246 637E 0201  20         li r1,SAL                   ; address of SAL in CPU
     6380 A08A     
0247 6382 0A2A  28         sla r10,2                   ; get offset into tables
0248 6384 A00A  18         a r10,r0                    ; add to vdp addr
0249 6386 A04A  18         a r10,r1                    ; add to cpu addr
0250 6388 06C8  14         swpb r8                     ; rotate x
0251 638A 06C9  14         swpb r9                     ; rotate y
0252 638C DC49  32         movb r9,*r1+                ; write y to cpu SAL
0253 638E D448  30         movb r8,*r1                 ; write x to cpu SAL
0254 6390 0601  14         dec r1                      ; point to beginning of entry in SAL
0255 6392 0202  20         li r2,2                     ; two bytes to write
     6394 0002     
0256 6396 06A0  32         bl @_vmbw                   ; write to VDP
     6398 7878     
0257 639A 10A0  14         jmp sprtx
0258               ;]
0259               
0260               ;[ SPRLOC? ( sprite -- y x )
0261               ; gets the location of a sprite
0262 639C C294  26 _spget  mov *stack,r10              ; pop sprite#
0263 639E 0200  20         li r0,sal                   ; address of SAL in CPU ram
     63A0 A08A     
0264 63A2 0A2A  28         sla r10,2                   ; get offset
0265 63A4 A00A  18         a r10,r0                    ; point to correct address in SAL
0266 63A6 04C1  14         clr r1                      ; prepare for byte operations
0267 63A8 D070  28         movb *r0+,r1                ; get y and point to x
0268 63AA 0221  22         ai r1,>0100                 ; correct for screen to char alignment
     63AC 0100     
0269 63AE 06C1  14         swpb r1                     ; move to lsb
0270 63B0 C501  30         mov r1,*stack               ; place on stack
0271 63B2 0644  14         dect stack                  ; make new stack entry
0272 63B4 04C1  14         clr r1
0273 63B6 D050  26         movb *r0,r1                 ; get x
0274 63B8 06C1  14         swpb r1                     ; move to lsb
0275 63BA C501  30         mov r1,*stack               ; place on stack
0276 63BC 108F  14         jmp sprtx
0277               ;]
0278               
0279               ;[ SPRPAT ( sprite# ascii -- )
0280               ; sets the pattern of a sprite
0281 63BE C274  30 _sppat  mov *stack+,r9              ; pop ascii
0282 63C0 C2B4  30         mov *stack+,r10             ; pop sprite#
0283 63C2 0200  20         li r0,>300+2                ; address of SAL in vdp
     63C4 0302     
0284 63C6 0202  20         li r2,SAL+2                 ; address of SAL in cpu
     63C8 A08C     
0285 63CA 0A2A  28         sla r10,2                   ; calculate offset
0286 63CC A00A  18         a r10,r0                    ; offset into vdp
0287 63CE A08A  18         a r10,r2                    ; offset into cpu
0288 63D0 06C9  14         swpb r9                     ; rotate ascii into msb
0289 63D2 C049  18         mov r9,r1                   ; for vsbw
0290 63D4 D489  30         movb r9,*r2                 ; set in cpu ram
0291 63D6 06A0  32         bl @_vsbw                   ; set in vdp ram
     63D8 7850     
0292 63DA 1080  14         jmp sprtx
0293               ;]
0294               
0295               ;[ SPRVEC ( sprite y x -- )
0296               ; sets the Y and X movement offsets for sprite movement with SPRMOV
0297 63DC 06A0  32 _smlst  bl @sget3                   ; get 3 parameters
     63DE 65D8     
0298 63E0 0200  20         li r0,smlist                ; address of sprite movement list
     63E2 A10A     
0299 63E4 0A1A  26         sla r10,1                   ; multiply sprite number by 2
0300 63E6 A00A  18         a r10,r0                    ; r0=address of appropriate entry in smlist
0301                                                   ; table.
0302 63E8 06C9  14         swpb r9                     ; get y in MSB
0303 63EA 06C8  14         swpb r8                     ; get x in MSB
0304 63EC DC09  32         movb r9,*r0+                ; load y into smlist
0305 63EE D408  30         movb r8,*r0                 ; load x into smlist
0306 63F0 1028  14         jmp gexit1
0307               ;]
0308               
0309               ;[ SPRMOV ( start_sprite number_of_sprites -- )
0310               ; moves sprites according to the entries in SMLIST, starting from start_sprite
0311               ; and continuing for number_of_sprites
0312               ;
0313               ; UPDATED MARCH 2012 SO THAT ONLY SPRITES WHO HAVE THEIR COORDINATES CHANGED
0314               ; ARE ACTUALLY UPDATED IN VDP
0315 63F2 C274  30 _spmov  mov *stack+,r9              ; pop number of sprites
0316 63F4 C2B4  30         mov *stack+,r10             ; pop start sprite
0317 63F6 0749  18         abs r9                      ; force positive & compare to zero. Nice.
0318 63F8 1324  14         jeq gexit1                  ; just exit if number of sprites=0
0319 63FA C089  18         mov r9,r2                   ; save no. of sprites to move in r2
0320 63FC C2CA  18         mov r10,r11                 ; copy start sprite
0321 63FE C18A  18         mov r10,r6                  ; copy again
0322 6400 0A1A  26         sla r10,1                   ; adjust for start sprite smlist
0323 6402 022A  22         ai r10,smlist               ; point to correct entry in smlist
     6404 A10A     
0324 6406 0A2B  28         sla r11,2                   ; adjust destination for sal
0325 6408 022B  22         ai r11,sal                  ; point to correct entry in the sal
     640A A08A     
0326 640C BEFA  42 sprmv1  ab *r10+,*r11+              ; add y
0327 640E BEFA  42         ab *r10+,*r11+              ; add x
0328 6410 05CB  14         inct r11                    ; skip ascii code and colour in sal
0329 6412 0609  14         dec r9                      ; decrement count
0330 6414 16FB  14         jne sprmv1                  ; repeat if not finished
0331 6416 0200  20         li r0,>300                  ; vdp address of sal
     6418 0300     
0332 641A 0A26  28         sla r6,2                    ; calculate offset into sal
0333 641C A006  18         a r6,r0                     ; calculate vdp sal address
0334 641E 0201  20         li r1,sal                   ; cpu address of sal
     6420 A08A     
0335 6422 A046  18         a r6,r1                     ; calculate cpu source address of sal
0336 6424 0A22  28         sla r2,2                    ; calculate number of bytes to write
0337 6426 06A0  32         bl @_vmbw                   ; copy cpu sal to vdp sal
     6428 7878     
0338 642A 100B  14         jmp gexit1
0339               ;]
0340               
0341               ;[ COLOR ( char_set foreground background -- )
0342               ; sets the color sets in 32 column mode
0343 642C 06A0  32 _color  bl @sget3                   ; get 3 parameters
     642E 65D8     
0344 6430 0200  20         li r0,>380                  ; address of colour table
     6432 0380     
0345 6434 A00A  18         a r10,r0                    ; point to correct colour set entry
0346 6436 0A49  32         sla r9,4                    ; move foreground into ms nybble
0347 6438 E209  18         soc r9,r8                   ; OR foreground into background
0348 643A C048  18         mov r8,r1                   ; move to r1 for vsbw
0349 643C 06C1  14         swpb r1                     ; move to ms byte
0350 643E 06A0  32         bl @_vsbw0                  ; write to vdp
     6440 785E     
0351 6442 0460  24 gexit1  b @retB0
     6444 833A     
0352               ;]
0353               
0354               ;[ SCREEN ( colour -- )
0355               ; sets the screen colour
0356 6446 C2B4  30 _scren  mov *stack+,r10             ; pop colour
0357 6448 0200  20         li r0,>0700                 ; vdp register number
     644A 0700     
0358 644C 024A  22         andi r10,>00ff              ; mask out any crap
     644E 00FF     
0359 6450 E00A  18         soc r10,r0                  ; or colour into register
0360 6452 06A0  32         bl @_vwtr
     6454 78D0     
0361 6456 10F5  14         jmp gexit1
0362               ;]
0363               
0364               ;[ SCROLL ( direction -- )
0365               ; scrolls the screen, according to the coodinates in PANEL
0366               ; 0=left 2=right 4=up 6=down
0367               ; I'm not happy with these routines. I'm sure they could be shorter and faster
0368               ; I'll have to revisit them later.
0369               _scrol
0370 6458 C260  34         mov @panxy,r9               ; screen address to start
     645A A034     
0371 645C C1A0  34         mov @panc,r6                ; column count
     645E A038     
0372 6460 C1E0  34         mov @panr,r7                ; row count
     6462 A036     
0373 6464 0208  20         li r8,>2000                 ; space character (used if no wrap around)
     6466 2000     
0374 6468 C2A0  34         mov @wrap,r10               ; get WRAP in a register
     646A A032     
0375 646C C3E0  34         mov @xmax,r15               ; get xmax in a register
     646E A02E     
0376 6470 C820  54         mov @bank1_,@retbnk         ; interrupts should return to bank 1
     6472 606A     
     6474 A070     
0377                       ; check direction and call appropriate routine...
0378 6476 0200  20         li r0,scrlut                ; address of look up table
     6478 6480     
0379 647A A034  30         a *stack+,r0                ; add and pop parameter to get address of
0380               ;                                   ; routine.
0381 647C C010  26         mov *r0,r0                  ; get the address in a register
0382 647E 0450  20         b *r0                       ; call the routine
0383 6480 6488     scrlut  data _left,_right,_up,_down ; addresses of the routines to call
     6482 64C6     
     6484 650C     
     6486 6560     
0384               
0385               ;[      ; left scroll...
0386               _left   ; read a line from screen into buffer...
0387 6488 C009  18         mov r9,r0                   ; vdp address
0388 648A C086  18         mov r6,r2                   ; number of bytes to read
0389 648C C060  34         mov @here,r1                ; cpu buffer
     648E A048     
0390 6490 06A0  32         bl @_vmbr2                  ; read a line
     6492 7830     
0391 6494 C020  34         mov @here,r0                ; start of buffer
     6496 A048     
0392 6498 C040  18         mov r0,r1                   ; one character to the right
0393 649A 0581  14         inc r1                      ; one character to the right
0394 649C C28A  18         mov r10,r10                 ; check WRAP
0395 649E 1602  14         jne _lwrap                  ; jump if true (wrap=on)
0396 64A0 D388  18         movb r8,r14                 ; else load a space character for the
0397                                                   ; wrap-around.
0398 64A2 1001  14         jmp $+4                     ; skip next instruction
0399 64A4 D390  26 _lwrap  movb *r0,r14                ; save leftmost char for wrap around
0400 64A6 C086  18         mov r6,r2                   ; x count
0401 64A8 0602  14         dec r2                      ; point to end of line for wrap-around
0402 64AA DC31  42 _left1  movb *r1+,*r0+              ; copy character to the left
0403 64AC 0602  14         dec r2                      ; reduce x count
0404 64AE 16FD  14         jne _left1                  ; loop if not finished
0405 64B0 D40E  30         movb r14,*r0                ; copy saved character for wrap around
0406 64B2 C009  18         mov r9,r0                   ; set screen address
0407 64B4 C060  34         mov @here,r1                ; source
     64B6 A048     
0408 64B8 C086  18         mov r6,r2                   ; count
0409 64BA 06A0  32         bl @_vmbw2                  ; write to screen
     64BC 787E     
0410 64BE 0607  14         dec r7                      ; finished?
0411 64C0 13C0  14         jeq gexit1                  ; if so exit
0412 64C2 A24F  18         a r15,r9                    ; move down one line
0413 64C4 10E1  14         jmp _left                   ; repeat
0414               ;]
0415               
0416               ;[      ; right scroll...
0417               _right  ; read a line from screen into buffer...
0418 64C6 C009  18         mov r9,r0                   ; vdp address
0419 64C8 C086  18         mov r6,r2                   ; number of bytes to read
0420 64CA C060  34         mov @here,r1                ; cpu buffer
     64CC A048     
0421 64CE 06A0  32         bl @_vmbr2                  ; read a line
     64D0 7830     
0422 64D2 C020  34         mov @here,r0                ; start of buffer
     64D4 A048     
0423 64D6 A006  18         a r6,r0                     ; end of buffer +1
0424 64D8 0600  14         dec r0                      ; correct to point to end of buffer
0425 64DA C040  18         mov r0,r1                   ; r1 will hold...
0426 64DC 0601  14         dec r1                      ; ...end of buffer -1
0427 64DE C28A  18         mov r10,r10                 ; check WRAP
0428 64E0 1602  14         jne _rwrap                  ; jump if true (wrap=on)
0429 64E2 D388  18         movb r8,r14                 ; else load a space character for the wrap-around
0430 64E4 1001  14         jmp $+4                     ; skip next instruction
0431 64E6 D390  26 _rwrap  movb *r0,r14                ; save leftmost char for wrap around
0432 64E8 C086  18         mov r6,r2                   ; x count
0433 64EA 0602  14         dec r2                      ; point to end of line for wrap-around
0434 64EC D411  38 _right1 movb *r1,*r0                ; copy character to the left
0435 64EE 0600  14         dec r0                      ; decrement pointer
0436 64F0 0601  14         dec r1                      ; decrement pointer
0437 64F2 0602  14         dec r2                      ; reduce x count
0438 64F4 16FB  14         jne _right1                 ; loop if not finished
0439 64F6 D40E  30         movb r14,*r0                ; copy saved character for wrap around
0440 64F8 C009  18         mov r9,r0                   ; set screen address
0441 64FA C060  34         mov @here,r1                ; source
     64FC A048     
0442 64FE C086  18         mov r6,r2                   ; count
0443 6500 06A0  32         bl @_vmbw2                  ; write to screen
     6502 787E     
0444 6504 0607  14         dec r7                      ; finished?
0445 6506 139D  14         jeq gexit1                  ; if so exit
0446 6508 A24F  18         a r15,r9                    ; move down one line
0447 650A 10DD  14         jmp _right                  ; repeat
0448               ;]
0449               
0450               ;[      ; up scroll...
0451 650C C28A  18 _up     mov r10,r10                 ; check wrap
0452 650E 1306  14         jeq _up0                    ; jump if no wrap
0453 6510 C009  18         mov r9,r0                   ; top left address
0454 6512 C086  18         mov r6,r2                   ; x count
0455 6514 0201  20         li r1,tib                   ; we'll use the terminal input buffer for storage
     6516 3420     
0456 6518 06A0  32         bl @_vmbr2                  ; read the liine
     651A 7830     
0457 651C C009  18 _up0    mov r9,r0                   ; top left screen address to r0
0458 651E A00F  18 _up1    a r15,r0                    ; move down one line
0459 6520 C060  34         mov @here,r1                ; buffer address
     6522 A048     
0460 6524 C086  18         mov r6,r2                   ; x count
0461 6526 06A0  32         bl @_vmbr2                  ; read from screen
     6528 7830     
0462 652A 600F  18         s r15,r0                    ; move up a line
0463 652C C060  34         mov @here,r1                ; buffer address
     652E A048     
0464 6530 C086  18         mov r6,r2                   ; number of bytes to write (x count)
0465 6532 06A0  32         bl @_vmbw2                  ; write them
     6534 787E     
0466 6536 0607  14         dec r7                      ; decrement counter
0467 6538 1302  14         jeq _up2                    ; exit if finished
0468 653A A00F  18         a r15,r0                    ; move down a line
0469 653C 10F0  14         jmp _up1                    ; repeat
0470 653E C28A  18 _up2    mov r10,r10                 ; check wrap
0471 6540 1306  14         jeq _up3                    ; blank line if not required
0472 6542 0201  20         li r1,tib                   ; else get ready to write the buffered line
     6544 3420     
0473 6546 C086  18         mov r6,r2                   ; x count
0474 6548 06A0  32         bl @_vmbw2                  ; write it
     654A 787E     
0475 654C 1005  14         jmp _upout                  ; see ya
0476 654E 0201  20 _up3    li r1,>2000                 ; write a blank line
     6550 2000     
0477 6552 C086  18         mov r6,r2                   ; x count
0478 6554 06A0  32         bl @_vsbwm2                 ; write it
     6556 78AA     
0479 6558 04E0  34 _upout  clr @tib                    ; clear tib
     655A 3420     
0480 655C 0460  24 gexit2  b @retB0
     655E 833A     
0481               ;]
0482               
0483               ;[      ; down scroll...
0484 6560 0607  14 _down   dec r7
0485 6562 C007  18         mov r7,r0                   ; y length
0486 6564 380F  58         mpy r15,r0                  ; convert to address (result in r1)
0487 6566 A049  18         a r9,r1                     ; add top of panel offset
0488 6568 C001  18         mov r1,r0                   ; vdp address in r0
0489 656A C28A  18         mov r10,r10                 ; check wrap
0490 656C 1305  14         jeq _down0                  ; skip if not required
0491 656E 0201  20         li r1,tib                   ; we'll use the terminal input buffer for storage
     6570 3420     
0492 6572 C086  18         mov r6,r2                   ; x count
0493 6574 06A0  32         bl @_vmbr2                  ; read the line
     6576 7830     
0494 6578 600F  18 _down0  s r15,r0                    ; move up a line
0495 657A C060  34         mov @here,r1                ; buffer address
     657C A048     
0496 657E C086  18         mov r6,r2                   ; x count
0497 6580 06A0  32         bl @_vmbr2                  ; read a line
     6582 7830     
0498 6584 A00F  18         a r15,r0                    ; move down a line
0499 6586 C060  34         mov @here,r1                ; buffer address
     6588 A048     
0500 658A C086  18         mov r6,r2                   ; x count
0501 658C 06A0  32         bl @_vmbw2                  ; write it
     658E 787E     
0502 6590 0607  14         dec r7                      ; decrement line count
0503 6592 1302  14         jeq _down1                  ; jump if finished
0504 6594 600F  18         s r15,r0                    ; otherwise move up a line
0505 6596 10F0  14         jmp _down0                  ; and repeat
0506 6598 600F  18 _down1  s r15,r0                    ; up a line
0507 659A C28A  18         mov r10,r10                 ; check wrap
0508 659C 1306  14         jeq _down2                  ; blank line if not required
0509 659E 0201  20         li r1,tib                   ; source
     65A0 3420     
0510 65A2 C086  18         mov r6,r2                   ; x count
0511 65A4 06A0  32         bl @_vmbw2                  ; write saved line
     65A6 787E     
0512 65A8 1005  14         jmp _dnout                  ; see ya
0513 65AA 0201  20 _down2  li r1,>2000                 ; write a blank line
     65AC 2000     
0514 65AE C086  18         mov r6,r2                   ; x count
0515 65B0 06A0  32         bl @_vsbwm2                 ; write it
     65B2 78AA     
0516 65B4 04E0  34 _dnout  clr @tib                    ; clear tib
     65B6 3420     
0517 65B8 10D1  14         jmp gexit2
0518               ;]
0519               ;]
0520               
0521               ;[ PANEL ( x y xl yl -- )
0522               ; defines a screen panel to be used by SCROLL
0523               _panel
0524 65BA 06A0  32         bl @sget4                   ; get 4 parameters off stack
     65BC 65D6     
0525 65BE C009  18         mov r9,r0                   ; move y
0526 65C0 3820  74         mpy @xmax,r0                ; multiply y by line length
     65C2 A02E     
0527 65C4 A04A  18         a r10,r1                    ; add x
0528 65C6 C801  38         mov r1,@panxy               ; save it
     65C8 A034     
0529 65CA C807  38         mov r7,@panr                ; save yl
     65CC A036     
0530 65CE C808  38         mov r8,@panc                ; save xl
     65D0 A038     
0531 65D2 10C4  14         jmp gexit2
0532               ;]
0533               
0534               ;[
0535               ; subroutine to get parameters off the stack
0536 65D4 C1B4  30 sget5   mov *stack+,r6
0537 65D6 C1F4  30 sget4   mov *stack+,r7
0538 65D8 C234  30 sget3   mov *stack+,r8
0539 65DA C274  30         mov *stack+,r9
0540 65DC C2B4  30         mov *stack+,r10
     **** ****     > RT
0001 65DE 045B  20        b * r11
                   < 1-03-Graphics.asm
0542               ;]
0543               
0544               ;[
0545               ; subroutine to get parameters off the stack for HCHAR VCHAR and GCHAR
0546               ; Has two entry points:
0547               ; get4: gets four parameters (HCHAR & VHCAR)
0548               ; get2: gets two parameters (GCHAR)
0549 65E0 C0B4  30 get4    mov *stack+,r2              ; pop count
0550 65E2 1308  14         jeq gabort                  ; if count=0 then cancel the instruction
0551 65E4 C074  30         mov *stack+,r1              ; pop ascii
0552 65E6 06C1  14         swpb r1                     ; move to high byte
0553 65E8 C034  30 get2    mov *stack+,r0              ; pop x
0554 65EA C1B4  30         mov *stack+,r6              ; pop y
0555 65EC 39A0  74         mpy @xmax,r6                ; multiply by screen size
     65EE A02E     
0556 65F0 A007  18         a r7,r0                     ; calculate screen start address
     **** ****     > RT
0001 65F2 045B  20        b * r11
                   < 1-03-Graphics.asm
0558 65F4 0224  22 gabort  ai stack,6                  ; pop remaining parameters off the stack
     65F6 0006     
0559 65F8 0460  24         b @retB0                    ; and just exit
     65FA 833A     
0560               ;]
                   < build.asm
0041                   copy "./bank1/1-04-Memory.asm"
     **** ****     > ./bank1/1-04-Memory.asm
0001               ;  __  __
0002               ; |  \/  |                                     /\
0003               ; | \  / | ___ _ __ ___   ___  _ __ _   _     /  \   ___  ___  ___ ___ ___
0004               ; | |\/| |/ _ \ '_ ` _ \ / _ \| '__| | | |   / /\ \ / __|/ __|/ _ | __/ __|
0005               ; | |  | |  __/ | | | | | (_) | |  | |_| |  / ____ \ (__| (__|  __|__ \__ \
0006               ; |_|  |_|\___|_| |_| |_|\___/|_|   \__, | /_/    \_\___|\___|\___|___/___/
0007               ; Memory access words                __/ |
0008               ;                                   |___/
0009               ;[ FILL ( addr count value -- )
0010 65FC 06A0  32 _fill   bl @sget3                   ; get 3 parameters
     65FE 65D8     
0011 6600 C249  18         mov r9,r9                   ; if value=0 then...
0012 6602 131A  14         jeq cmvext                  ; ...just exit
0013 6604 06C8  14         swpb r8                     ; get byte value in msb
0014 6606 DE88  32 filllp  movb r8,*r10+               ; move to addr and increment addr
0015 6608 0609  14         dec r9                      ; finished?
0016 660A 16FD  14         jne filllp                  ; repeat if not
0017 660C 1015  14         jmp cmvext                  ; clean up and exit
0018               ;]
0019               
0020               ;[ CMOVE ( addr1 addr2 count -- )
0021               ; Move count bytes beginning at address addr1 to addr2. The byte at addr1 is
0022               ; moved first, proceeding toward high memory. If count is zero nothing is moved
0023 660E 06A0  32 _cmove  bl @sget3                   ; get 3 parameters
     6610 65D8     
0024 6612 C208  18         mov r8,r8                   ; if count=0 then...
0025 6614 1311  14         jeq cmvext                  ; ...just exit
0026 6616 DE7A  42 cmovlp  movb *r10+,*r9+             ; move a byte
0027 6618 0608  14         dec r8                      ; finished?
0028 661A 16FD  14         jne cmovlp                  ; repeat if not
0029 661C 100D  14         jmp cmvext                  ; clean up and exit
0030               ;]
0031               
0032               ;[ CMOVE> ( addr1 addr2 count -- )
0033               ; Move the count bytes at address addr1 to addr2. The move begins by moving the
0034               ; byte at addr1 plus count minus 1 to addr2 plus count minus 1 and proceeds to
0035               ; successively lower addresses for count bytes.
0036               ; If count is zero nothing is moved.
0037               ; (Useful for sliding a string towards higher addresses)
0038 661E 06A0  32 _cmovf  bl @sget3                   ; get 3 parameters
     6620 65D8     
0039 6622 C208  18         mov r8,r8                   ; if count=0 then...
0040 6624 1309  14         jeq cmvext                  ; ...just exit
0041 6626 0608  14         dec r8                      ; count-1
0042 6628 A248  18         a r8,r9                     ; addr2=addr2+count-1
0043 662A A288  18         a r8,r10                    ; addr1=addr1+count-1
0044 662C 0588  14         inc r8                      ; restore count
0045 662E D65A  38 cmvflp  movb *r10,*r9               ; move a byte
0046 6630 060A  14         dec r10                     ; decrement addr 1
0047 6632 0609  14         dec r9                      ; decrement addr 2
0048 6634 0608  14         dec r8                      ; decrement count
0049 6636 16FB  14         jne cmvflp                  ; loop if not finished
0050 6638 0460  24 cmvext  b @retB0
     663A 833A     
0051               ;]
0052               
0053               ;[ COPYW (source destination count -- )
0054               ; copy WORDS from source to destination for 'count' words
0055               ; no action taken if count=0
0056 663C 06A0  32 _copyw  bl @sget3
     663E 65D8     
0057 6640 C208  18         mov r8,r8                   ; if count=0 then...
0058 6642 13FA  14         jeq cmvext                  ; ...just exit
0059 6644 CE7A  46 copywl  mov *r10+,*r9+              ; copy a word
0060 6646 0608  14         dec r8                      ; decrement counter
0061 6648 16FD  14         jne copywl                  ; loop if counter not zero
0062 664A 10F6  14         jmp cmvext                  ; clean up and exit
0063               ;]
0064               
0065               ;[ ; >MAP ( bank address -- )
0066               ; If a SAMS card is present, maps memory bank "bank" to address "address"
0067 664C C2CC  18 _sams   mov r12,r11                 ; save address of NEXT
0068 664E C074  30         mov *stack+,r1              ; get address
0069 6650 0241  22         andi r1,>f000               ; set to 4k boundary
     6652 F000     
0070 6654 09B1  46         srl r1,11                   ; divide by 2048
0071 6656 0221  22         ai r1,>4000                 ; convert to SAMS register address
     6658 4000     
0072 665A C0B4  30         mov *stack+,r2              ; get bank
0073 665C 0242  22         andi r2,>ff                 ; mask off any crap
     665E 00FF     
0074 6660 C002  18         mov r2,r0                   ; keep a copy
0075 6662 0A82  40         sla r2,8                    ; move to high byte
0076 6664 2880  16         xor r0,r2                   ; combine r0 & r2. Hi & lo bytes are now identical
0077 6666 020C  20         li r12,>1e00                ; cru address of SAMS
     6668 1E00     
0078 666A 1D00  16         sbo 0                       ; enable SAMS registers
0079 666C C442  30         mov r2,*r1                  ; poke sams register
0080 666E 1E00  16         sbz 0                       ; disable sams registers
0081 6670 C30B  18         mov r11,r12                 ; restore address of NEXT
0082 6672 0460  24         b @retB0                    ; return to caller
     6674 833A     
0083               
0084               ;]
0085               
0086               ;[ VDP Write To Register ( value register -- )
0087 6676 C034  30 _vwtrf  mov *stack+,r0              ; get register
0088 6678 0A80  40         sla r0,8                    ; move to high byte
0089 667A C074  30         mov *stack+,r1              ; get value
0090 667C 0241  22         andi r1,>00ff               ; mask off high byte
     667E 00FF     
0091 6680 E001  18         soc r1,r0                   ; merge
0092 6682 06A0  32         bl @_vwtr                   ; write it
     6684 78D0     
0093 6686 0460  24         b @retB0
     6688 833A     
0094               ;]
                   < build.asm
0042                   copy "./bank1/1-05-Speech.asm"
     **** ****     > ./bank1/1-05-Speech.asm
0001               ;   _____                      _      __          __            _
0002               ;  / ____|                    | |     \ \        / /           | |
0003               ; | (___  _ __   ___  ___  ___| |__    \ \  /\  / /___  _ __ __| |___
0004               ;  \___ \| '_ \ / _ \/ _ \/ __| '_ \    \ \/  \/ // _ \| '__/ _` / __|
0005               ;  ____) | |_) |  __/  __/ (__| | | |    \  /\  /| (_) | | | (_| \__ \
0006               ; |_____/| .__/ \___|\___|\___|_| |_|     \/  \/  \___/|_|  \__,_|___/
0007               ;        | |
0008               ;        |_|
0009               
0010      9000     spchrd  equ >9000                   ; speech read register
0011      9400     spchwt  equ >9400                   ; speech write register
0012               
0013 668A 10       spread  byte 16                     ; 'read data' command code
0014 668B   AA     ssflag  byte >aa                    ; 'speech synth present' check code
0015 668C 50       spkROM  byte >50                    ; 'speak from ROM' command code
0016                       even
0017               
0018               ;[ TALKING? ( -- flag )
0019               ; returns 0 if speech synth is idle, else returns -1
0020 668E 0644  14 _spkng  dect stack                  ; make space on data stack
0021 6690 C020  34         mov @synyes,r0              ; synth fitted?
     6692 A042     
0022 6694 130B  14         jeq nspk                    ; if not then just return 'not speaking'
0023 6696 06A0  28         bl @spstat                  ; else get status from speech synth
     6698 8340     
0024 669A C020  30         mov @spdata,r0              ; get the data from speech synth
     669C 834A     
0025 669E 0240  22         andi r0,>8000               ; isolate busy bit
     66A0 8000     
0026 66A2 A020  34         a @spcnt,r0                 ; add words/bytes remaining in speech buffer
     66A4 A03C     
0027 66A6 1302  14         jeq nspk                    ; not speaking
0028 66A8 0714  26         seto *stack                 ; speaking
0029 66AA 100D  14         jmp sayxit                  ; return via r15
0030 66AC 04D4  26 nspk    clr *stack                  ; not speaking
0031 66AE 100B  14         jmp sayxit
0032               ;]
0033               
0034               ;[ SAY ( addr count -- )
0035               ; feeds count words to the speech synth, starting at addr. Used to speak words
0036               ; from the built in speech rom. The data fed to the synth should be the entry
0037               ; addresses of speech rom words, as found in the editor assembler manual.
0038 66B0 C834  50 _say    mov *stack+,@spcnt          ; pop speech buffer count
     66B2 A03C     
0039 66B4 C834  50         mov *stack+,@spadr          ; pop speech buffer address
     66B6 A03E     
0040 66B8 C020  34         mov @synyes,r0              ; check if speech synth is fitted
     66BA A042     
0041 66BC 1304  14         jeq sayxit                  ; if not, just exit immediately
0042 66BE 0200  20         li r0,romspk                ; else get address of rom-speak routine
     66C0 60FC     
0043 66C2 C800  38         mov r0,@spcsvc              ; load into speech service routine pointer
     66C4 A040     
0044 66C6 0460  24 sayxit  b @retB0
     66C8 833A     
0045               ;]
0046               
0047               ;[ STREAM ( addr count -- )
0048               ; feeds addr bytes to the speech synth, starting at addr. Used to stream raw
0049               ; speech data to the speech synth.
0050               ; MODIFIED FOR V1.2.3: If the synth is already talking then a new STREAM
0051               ; command will be ignored.
0052 66CA C034  30 _strem  mov *stack+,r0              ; pop speech buffer count
0053 66CC 0A10  26         sla r0,1                    ; convert to byte count
0054 66CE C800  38         mov r0,@spcnt               ; store it
     66D0 A03C     
0055 66D2 C834  50         mov *stack+,@spadr          ; pop speech buffer address
     66D4 A03E     
0056 66D6 C020  34         mov @synyes,r0              ; check if speech synth is fitted
     66D8 A042     
0057 66DA 13F5  14         jeq sayxit                  ; just exit if not
0058 66DC 0200  20         li r0,strspk                ; else get address of stream-speak routine
     66DE 608E     
0059                                                   ; (defined in 1-01-ISR.a99)
0060 66E0 C800  38         mov r0,@spcsvc              ; load into speech service routine pointer
     66E2 A040     
0061 66E4 10F0  14         jmp sayxit
0062               ;]
0063               
0064               ;[ speech support routines
0065               ; routine to see if speech synth is fitted
0066               ; on exit sets r0: 0=not detected >ffff=detected
0067 66E6 04E0  34 isspch  clr @synyes                 ; assume no speech synth detected
     66E8 A042     
0068 66EA 04C0  14         clr r0                      ; check address 0 in speech synth
0069 66EC 06A0  32         bl @readsp                  ; read byte from the speech synth in r0 msb
     66EE 66FE     
0070 66F0 9800  34         cb r0,@ssflag               ; is the speech synth here?
     66F2 668B     
0071 66F4 1301  14         jeq spyes                   ; speech synth is detected
0072 66F6 10E7  14         jmp sayxit                  ; see ya
0073 66F8 0720  34 spyes   seto @synyes                ; found speech synth
     66FA A042     
0074 66FC 10E4  14 spchx   jmp sayxit                  ; gtf outta here
0075               
0076               
0077               ; routine to read a byte from the speech synth
0078               ; Inputs: R0=address in speech synth to read
0079               ; Outputs R0=byte read from speech synth in MSB
0080 66FE C20B  18 readsp  mov r11,r8                  ; save return address
0081 6700 06A0  32         bl @spaddr                  ; load address into speech synth (in r0)
     6702 6714     
0082 6704 D820  54         movb @spread,@spchwt        ; send read data command
     6706 668A     
     6708 9400     
0083 670A 0BC0  40         src r0,12                   ; 12uS delay
0084 670C 04C0  14         clr r0                      ; prepare for byte operations
0085 670E D020  34         movb @spchrd,r0             ; read the byte from the speech synth
     6710 9000     
0086 6712 0458  20         b *r8                       ; return to caller
0087               
0088               
0089               ; routine to load an address into the speech synth's address register
0090               ; the address to load is passed in r0
0091 6714 0202  20 spaddr  li r2,4                     ; 4 nybbles to load
     6716 0004     
0092 6718 0B40  24 loadlp  src r0,4                    ; start with least significant nybble
0093 671A C040  18         mov r0,r1                   ; copy it
0094 671C 0B41  24         src r1,4                    ; get target nybble into correct position
0095 671E 0241  22         andi r1,>0f00               ; mask out the nybble of interest
     6720 0F00     
0096 6722 0261  22         ori r1,>4000                ; put in 4x00 format for speech synth
     6724 4000     
0097 6726 D801  38         movb r1,@spchwt             ; send it to the speech synth
     6728 9400     
0098 672A 0602  14         dec r2                      ; finished?
0099 672C 16F5  14         jne loadlp                  ; do next nybble repeat if not
0100 672E 0201  20         li r1,>4000                 ; signal to speech synth that we finished...
     6730 4000     
0101 6732 D801  38         movb r1,@spchwt             ; ...sending the address.
     6734 9400     
     **** ****     > RT
0001 6736 045B  20        b * r11
                   < 1-05-Speech.asm
0103               ;]
0104               
0105               ;[ (DATA) - runtime code for DATA
0106 6738 0644  14 _data   dect stack              ; make stack entry
0107 673A C503  30         mov pc,*stack           ; current address to stack
0108 673C 05D4  26         inct *stack             ; plus 2
0109 673E 0644  14         dect stack              ; stack entry
0110 6740 C073  30         mov *pc+,r1             ; number of data items...
0111 6742 C501  30         mov r1,*stack           ; ...to stack
0112 6744 0A11  26         sla r1,1                ; compute byte offset past data
0113 6746 A0C1  18         a r1,pc                 ; adjust program counter
0114 6748 0460  24         b @retB0
     674A 833A     
0115               ;]
                   < build.asm
0043                   copy "./bank1/1-06-Blocks.asm"
     **** ****     > ./bank1/1-06-Blocks.asm
0001               ;  ____  _            _      _____     ______   __          __            _
0002               ; |  _ \| |          | |    |_   _|   / / __ \  \ \        / /           | |
0003               ; | |_) | | ___   ___| | __   | |    / / |  | |  \ \  /\  / /___  _ __ __| |___
0004               ; |  _ <| |/ _ \ / __| |/ /   | |   / /| |  | |   \ \/  \/ // _ \| '__/ _` / __|
0005               ; | |_) | | (_) | (__|   <   _| |_ / / | |__| |    \  /\  /| (_) | | | (_| \__ \
0006               ; |____/|_|\___/ \___|_|\_\ |_____/_/   \____/      \/  \/  \___/|_|  \__,_|___/
0007               ; block file system words & subroutines
0008               ; Some heavy stuff in here. In here be demons.
0009               ; Turn back all ye faint of heart...
0010               
0011               ;[ pab opcodes
0012      0000     open    equ 0                       ; open opcode
0013      0001     close   equ >1                      ; close opcode
0014      0002     read    equ >2                      ; read opcode
0015      0003     write   equ >3                      ; write opcode
0016      0004     fwdrew  equ >4                      ; restore/rewind opcode (fwd/rew)
0017      0009     status  equ >9                      ; status op-code
0018               ;]
0019               
0020               ;[ USE ( addr len -- )
0021               ; Tells the system which block file to use for block IO
0022               ; e.g. USE DSK1.BLOCKS
0023               ; Simply sets the filename and length in the blockIO PAB
0024               ; Syntax: S" DSKn.FILENAME" USE
0025 674C C0B4  30 _use    mov *stack+,r2              ; length of filename
0026 674E 06C2  14         swpb r2                     ; move to MSB
0027 6750 C034  30         mov *stack+,r0              ; address of file name
0028 6752 0209  20         li r9,pabnln                ; address of filename length in blockIO PAB
     6754 A18B     
0029 6756 DE42  32         movb r2,*r9+                ; write length to PAB length byte, now
0030                                                   ; pointing at filename
0031 6758 06C2  14         swpb r2                     ; move to LSB
0032 675A DE70  42 _use3   movb *r0+,*r9+              ; copy byte of filename to pab
0033 675C 0602  14         dec r2                      ; finished copying?
0034 675E 16FD  14         jne _use3                   ; repeat if not
0035                   ; clear all blk pointers...
0036 6760 04E0  34         clr @lstblk
     6762 A1B6     
0037 6764 04E0  34         clr @blk0
     6766 A1B8     
0038 6768 04E0  34         clr @blk1
     676A A1BC     
0039 676C 04E0  34         clr @blk2
     676E A1C0     
0040 6770 04E0  34         clr @blk3
     6772 A1C4     
0041 6774 04E0  34         clr @blk4
     6776 A1C8     
0042 6778 04E0  34         clr @blk5
     677A A1CC     
0043 677C 0460  24 usexit  b @retB0
     677E 833A     
0044               ;]
0045               
0046               ;[ BLOCK ( block# -- addr )
0047               ; Brings a block into a buffer, if not already in memory
0048               ;  1) If already in memory, the block is not re-loaded from device
0049               ;  2) If not in memory:
0050               ;  3)  Scans for a free buffer
0051               ;  4)  If no free buffer:
0052               ;  5)   flush all buffers back to device
0053               ;  6)   Repeat from 3
0054               ;  7) If free buffer:
0055               ;  9)  Load block from device into free buffer
0056               ; 10)  Return address of buffer
0057               ; 11) If disk error, or block not found etc, return 0
0058               ; Note: If a block number of 0 is given 0 is returned
0059 6780 04E0  34 _block  clr @errnum                 ; clear last disk io error
     6782 A03A     
0060 6784 C014  26         mov *stack,r0               ; block number in r0 for scnblk
0061 6786 13FA  14         jeq usexit                  ; if zero then just exit
0062 6788 C800  38         mov r0,@lstblk              ; update last block accessed (for UPDATE)
     678A A1B6     
0063 678C 06A0  32         bl @scnblk                  ; see if the block is already in memory
     678E 6A02     
0064 6790 C041  18         mov r1,r1                   ; check returned result
0065 6792 1303  14         jeq blknim                  ; block is not in memory
0066 6794 05C1  14         inct r1                     ; block is in memory. point to vdp address
0067                                                   ; pointer
0068 6796 C511  38         mov *r1,*stack              ; place vdp address on stack
0069 6798 10F1  14         jmp usexit                  ; exit
0070                   ; look for a free buffer
0071 679A 06A0  32 blknim  bl @frebuf                  ; block is not in memory, scan for a buffer
     679C 69EA     
0072 679E C000  18         mov r0,r0                   ; check returned result
0073 67A0 1328  14         jeq bnfb                    ; jump if no free buffers
0074                   ; we have a free buffer, it's blk address is in r0...
0075 67A2 C414  38 blkfb   mov *stack,*r0              ; update block indicator in block buffer
0076 67A4 C200  18         mov r0,r8                   ; copy blk address
0077 67A6 C090  26         mov *r0,r2                  ; copy block number
0078 67A8 0602  14         dec r2                      ; reduce by one (so we can use block 0)
0079 67AA 0A32  30         sla r2,3                    ; calculate record number (block no. x 8)
0080 67AC 05C0  14         inct r0                     ; point to vdp address
0081 67AE C250  26         mov *r0,r9                  ; save vdp address
0082 67B0 C509  30         mov r9,*stack               ; place vdp address on stack
0083                   ; put the pab into vdp ram, with an open opcode and open the file...
0084 67B2 0201  20         li r1,>8000                 ; logical record length: 128 bytes (in msb)
     67B4 8000     
0085 67B6 D801  38         movb r1,@pablrl             ; set logical record length in pab
     67B8 A186     
0086 67BA C802  38         mov r2,@pabrec              ; set record number in PAB
     67BC A188     
0087 67BE C809  38         mov r9,@pabbuf              ; address to load data into in VDP
     67C0 A184     
0088 67C2 06A0  32         bl @diskio                  ; witchcraft
     67C4 6A1A     
0089 67C6 0005             byte open,5                 ; dis/fix input
0090 67C8 1319  14         jeq blkerr                  ; jump if an an error occurred
0091                   ; read 8 128 byte records (1K)...
0092 67CA 0207  20         li r7,8                     ; 8 records to read
     67CC 0008     
0093 67CE 06A0  32 blknxt  bl @diskio                  ; call disk system
     67D0 6A1A     
0094 67D2 0205             byte read,5                 ; dis/fix input
0095 67D4 1313  14         jeq blkerr                  ; jump if an an error occurred
0096 67D6 0229  22         ai r9,128                   ; increment vdp address
     67D8 0080     
0097 67DA C809  38         mov r9,@pabbuf              ; address to load data into in VDP
     67DC A184     
0098 67DE 05A0  34         inc @pabrec                 ; set next record in PAB
     67E0 A188     
0099 67E2 0607  14         dec r7                      ; finished reading all the records?
0100 67E4 16F4  14         jne blknxt                  ; repeat if not
0101 67E6 06A0  32         bl @diskio                  ; more alchemy
     67E8 6A1A     
0102 67EA 0105             byte close,5                ; dis/fix input
0103 67EC 06A0  32         bl @rstsp                   ; restore code in scratchpad
     67EE 6B50     
0104                                                   ; (destroyed by DSR access)
0105 67F0 10C5  14         jmp usexit                  ; exit
0106                   ; no free buffers :-( we need to do a flush...
0107 67F2 06A0  32 bnfb    bl @flush1                  ; flush all our buffers to device
     67F4 6816     
0108 67F6 0200  20         li r0,blk0                  ; point to first (which is now free) block
     67F8 A1B8     
0109 67FA 10D3  14         jmp blkfb                   ; repeat
0110                   ; an error occurred, return 0 on the stack
0111 67FC 04D4  26 blkerr  clr *stack                  ; zero the TOS
0112 67FE 06C0  14         swpb r0
0113 6800 C800  38         mov r0,@errnum              ; set disk io error number
     6802 A03A     
0114 6804 06A0  32         bl @diskio                  ; close the file
     6806 6A1A     
0115 6808 0105             byte close,5
0116 680A 06A0  32         bl @rstsp                   ; restore code in scratchpad
     680C 6B50     
0117                                                   ; (destroyed by DSR access)
0118 680E 10B6  14         jmp usexit                  ; exit
0119               ;]
0120               
0121               ;[ FLUSH ( -- )
0122               ; Flushes all dirty blocks back to disk
0123               ; If a blocks' DIRTY flag is set, the block is physically written back to disk.
0124               ; If the block is NOT dirty, it's (BLK) status is simply set to un-used.
0125               ; Sets DSKERR to reflect disk DSR error status (0=no error)
0126 6810 06A0  32 _flush  bl @flush1
     6812 6816     
0127 6814 10B3  14 flushx  jmp usexit
0128 6816 04E0  34 flush1  clr @errnum                 ; reset last disk io error
     6818 A03A     
0129 681A C38B  18         mov r11,r14                 ; save return address of caller
0130                   ;    li r6,6                     ; 6 buffers to check
0131 681C C1A0  34     mov @totblk,r6              ; number of buffers to check
     681E A1B2     
0132 6820 0207  20         li r7,blk0+2                ; start with the first vdp address pointer
     6822 A1BA     
0133 6824 C217  26 flnext  mov *r7,r8                  ; get address
0134 6826 0248  22         andi r8,>8000               ; check dirty flag
     6828 8000     
0135 682A 1325  14         jeq flush2                  ; if 0, not dirty, just reset pointers
0136                   ; else flush to disk...
0137 682C 0201  20         li r1,>8000                 ; logical record length: 128 bytes (in msb)
     682E 8000     
0138 6830 D801  38         movb r1,@pablrl             ; set logical record length
     6832 A186     
0139 6834 04E0  34         clr @pabrec                 ; set record number to 0
     6836 A188     
0140 6838 06A0  32         bl @diskio
     683A 6A1A     
0141 683C 0001             byte open,1                 ; dis/fixed update
0142 683E 132A  14         jeq flerr                   ; jump if error
0143 6840 020C  20         li r12,8                    ; 8 128 byte records (1024 bytes)
     6842 0008     
0144 6844 C217  26         mov *r7,r8                  ; vdp address
0145 6846 0248  22         andi r8,>7fff               ; remove dirty bit
     6848 7FFF     
0146 684A C067  34         mov @-2(r7),r1              ; get block number
     684C FFFE     
0147 684E 0601  14         dec r1                      ; account for blocks starting at 1
0148 6850 0A31  30         sla r1,3                    ; convert to record count
0149 6852 C801  38         mov r1,@pabrec              ; set record number
     6854 A188     
0150 6856 C808  38 flnrec  mov r8,@pabbuf              ; set source vdp address
     6858 A184     
0151 685A 06A0  32         bl @diskio                  ; write the record to disk
     685C 6A1A     
0152 685E 0301             byte write,1                ; dis/fix update
0153 6860 1319  14         jeq flerr                   ; jump if error
0154 6862 0228  22         ai r8,128                   ; next 128 bytes of vdp
     6864 0080     
0155 6866 05A0  34         inc @pabrec                 ; next record on disk
     6868 A188     
0156 686A 060C  14         dec r12                     ; decrement counter
0157 686C 16F4  14         jne flnrec                  ; loop if not finished
0158 686E 06A0  32         bl @diskio                  ; close the file
     6870 6A1A     
0159 6872 0101             byte close,1                ; dis/fix update
0160 6874 130F  14         jeq flerr                   ; jump if error
0161                   ; reset blk & dirty flag...
0162 6876 04E7  34 flush2  clr @-2(r7)                 ; clear blk indicator
     6878 FFFE     
0163 687A C057  26         mov *r7,r1                  ; get vdp address from pointer
0164 687C 0241  22         andi r1,>7fff               ; reset dirty bit
     687E 7FFF     
0165 6880 C5C1  30         mov r1,*r7                  ; write it back
0166                   ; loop back for remaining blks...
0167 6882 0227  22         ai r7,4                     ; point to next vdp address
     6884 0004     
0168 6886 0606  14         dec r6                      ; finished?
0169 6888 16CD  14         jne flnext                  ; repeat if not
0170 688A 020C  20 flexit  li r12,_next                ; restore pointer to NEXT
     688C 8326     
0171 688E 06A0  32         bl @rstsp                   ; restore code in scratchpad (destroyed by
     6890 6B50     
0172                                                   ; DSR access)
0173 6892 045E  20         b *r14                      ; return to caller
0174                   ; an error occurred... exit...
0175 6894 06C0  14 flerr   swpb r0                     ; move error into low byte
0176 6896 C800  38         mov r0,@errnum              ; set DSKERR with error code
     6898 A03A     
0177 689A 06A0  32         bl @diskio                  ; set the file to closed
     689C 6A1A     
0178 689E 0101             byte close,1
0179 68A0 10F4  14         jmp flexit
0180               ;]
0181               
0182               ;[ UPDATE ( -- )
0183               ; marks the last accessed block as dirty so that it will subsequently be flushed
0184               ; to disk.
0185 68A2 C020  34 _updat  mov @lstblk,r0              ; get current block
     68A4 A1B6     
0186 68A6 06A0  32         bl @scnblk                  ; locate it (blk address in r1)
     68A8 6A02     
0187 68AA 05C1  14         inct r1                     ; point to VDP address pointer
0188 68AC C011  26         mov *r1,r0                  ; get the VDP address
0189 68AE 0260  22         ori r0,>8000                ; set dirty bit
     68B0 8000     
0190 68B2 C440  30         mov r0,*r1                  ; write it back
0191 68B4 10AF  14         jmp flushx
0192               ;]
0193               
0194               ;[ EMPTY-BUFFERS ( -- )
0195               ; marks all buffers as unused.
0196 68B6 0202  20 _mtbuf  li r2,6                     ; counter
     68B8 0006     
0197 68BA 0200  20         li r0,blk0                  ; address of first blk
     68BC A1B8     
0198 68BE 04F0  30 mtbufl  clr *r0+                    ; zero block number then point to vdp
0199                                                   ; address
0200 68C0 C050  26         mov *r0,r1                  ; get vdp address
0201 68C2 0241  22         andi r1,>7fff               ; set dirty to zero
     68C4 7FFF     
0202 68C6 CC01  34         mov r1,*r0+                 ; write it back, point to next blk
0203 68C8 0602  14         dec r2                      ; decrement counter
0204 68CA 16F9  14         jne mtbufl                  ; repeat if not finished
0205 68CC 04E0  34         clr @lstblk                 ; no blocks in memory
     68CE A1B6     
0206 68D0 10A1  14         jmp flushx
0207               ;]
0208               
0209               ;[ CLEAN ( buffer -- )
0210               ; forces a buffers' status to clean
0211 68D2 06A0  32 _clean  bl @cba                     ; compute blk address
     68D4 69DA     
0212 68D6 0241  22         andi r1,>7fff               ; reset dirty bit
     68D8 7FFF     
0213 68DA C401  30         mov r1,*r0                  ; write it back
0214 68DC 109B  14         jmp flushx
0215               
0216               ;]
0217               
0218               ;[ DIRTY ( buffer -- )
0219               ; forces a buffers' status to dirty
0220 68DE 06A0  32 _dirty  bl @cba                     ; compute blk address
     68E0 69DA     
0221 68E2 0261  22         ori r1,>8000                ; set dirty bit
     68E4 8000     
0222 68E6 C401  30         mov r1,*r0                  ; write it back
0223 68E8 1095  14         jmp flushx
0224               ;]
0225               
0226               ;[ DIRTY? ( buffer -- flag )
0227               ; interrogates a buffers' status, returning true if the buffer is dirty, else
0228               ; returning false
0229 68EA 06A0  32 _qdirt  bl @cba                     ; compute blk address
     68EC 69DA     
0230 68EE 0644  14         dect stack                  ; make space on stack (cba reduces stack
0231                                                   ; pointer)
0232 68F0 0241  22         andi r1,>8000               ; mask out everything except dirty bit
     68F2 8000     
0233 68F4 1303  14         jeq ndirt                   ; if 0 then it's not dirty
0234 68F6 0714  26         seto *stack                 ; it's dirty
0235 68F8 0460  24         b @retB0
     68FA 833A     
0236 68FC 04D4  26 ndirt   clr *stack                  ; it's clean
0237 68FE 108A  14         jmp flushx
0238               ;]
0239               
0240               ;[ BLK? ( buffer -- block vdp_address )
0241               ; For a given buffer, returns the actual block stored in that buffer
0242               ; and the vdp address of that buffer
0243 6900 06A0  32 _blkq   bl @cba                     ; compute blk address
     6902 69DA     
0244 6904 0644  14         dect stack                  ; make space on stack
0245 6906 0640  14         dect r0                     ; point to blk
0246 6908 C510  38         mov *r0,*stack              ; place on stack
0247 690A 0241  22         andi r1,>7fff               ; mask out dirty bit
     690C 7FFF     
0248 690E 0644  14         dect stack
0249 6910 C501  30         mov r1,*stack               ; place vdp address of buffer on stack
0250 6912 1080  14         jmp flushx
0251               ;]
0252               
0253               ;[ BUF? ( block -- buffer vdp_address )
0254               ; For a given block, return the buffer number, and the vdp address of the buffer
0255               ; returns 0 0 if the block is not in memory
0256 6914 C054  26 _buf    mov *stack,r1               ; get block
0257 6916 0202  20         li r2,0                     ; six buffers to check
     6918 0000     
0258 691A 0200  20         li r0,blk0                  ; point to top of buffer descriptor table
     691C A1B8     
0259 691E 8050  26 bufrpt  c *r0,r1                    ; compare block to block being sought
0260 6920 130A  14         jeq fndbuf                  ; jump if we found it
0261 6922 0220  22         ai r0,4                     ; else point to next buffer in the table
     6924 0004     
0262 6926 0582  14         inc r2                      ; increment counter
0263 6928 0282  22         ci r2,6                     ; finished?
     692A 0006     
0264 692C 16F8  14         jne bufrpt
0265 692E 04D4  26         clr *stack                  ; the block was not found - return 0 0
0266 6930 0644  14         dect stack                  ; new stack entry
0267 6932 04D4  26         clr *stack
0268 6934 1004  14         jmp bufxit
0269 6936 C502  30 fndbuf  mov r2,*stack               ; push buffer number
0270 6938 0644  14         dect stack                  ; new stack entry
0271 693A 05C0  14         inct r0                     ; point to vdp address
0272 693C C510  38         mov *r0,*stack              ; push it to stack
0273 693E 0460  24 bufxit  b @retB0
     6940 833A     
0274               ;]
0275               
0276               ;[ SETBLK ( buffer block -- )
0277               ; For a given buffer, changes the block that it is associated with.
0278               ; Allows blocks to copied to other blocks, using FLUSH.
0279 6942 C074  30 _setbk  mov *stack+,r1              ; pop the block
0280 6944 C0B4  30         mov *stack+,r2              ; pop the buffer
0281 6946 0A22  28         sla r2,2                    ; multiply buffer by 4 to act as offset into
0282                                                   ; buffer descriptor table
0283 6948 0200  20         li r0,blk0                  ; point to top of buffer descriptor table
     694A A1B8     
0284 694C A002  18         a r2,r0                     ; point to correct entry in buffer
0285                                                   ; descriptor table
0286 694E C401  30         mov r1,*r0                  ; change block entry
0287 6950 10F6  14         jmp bufxit
0288               ;]
0289               
0290               ;[ MKBLK ( filename size_in_kilobytes -- )
0291               ; makes a block file on disk. Sets DSKERR with result code. >0=some error
0292 6952 04E0  34 _mkblk  clr @errnum                 ; clear last disk error
     6954 A03A     
0293 6956 C034  30         mov *stack+,r0              ; length of file name
0294 6958 C074  30         mov *stack+,r1              ; address of filename
0295 695A C1B4  30         mov *stack+,r6              ; pop number of kilobytes
0296 695C 06C0  14         swpb r0                     ; get file name length in MSB
0297 695E D800  38         movb r0,@pabnln             ; load name length byte in CPU PAB
     6960 A18B     
0298 6962 06C0  14         swpb r0
0299                   ; check size against limits...
0300 6964 0286  22         ci r6,1                     ; minimum size
     6966 0001     
0301 6968 1104  14         jlt toosml                  ; size is too small, force to 1
0302 696A 0286  22         ci r6,1024                  ; maximum size
     696C 0400     
0303 696E 1504  14         jgt toobig                  ; size is too big, force to 1024
0304 6970 1005  14         jmp cont
0305 6972 0206  20 toosml  li r6,1                     ; force size to 1
     6974 0001     
0306 6976 1002  14         jmp cont                    ; continue
0307 6978 0206  20 toobig  li r6,1024                  ; force size to 1024
     697A 0400     
0308                   ; copy the filename into the cpu ram PAB...
0309 697C 0202  20 cont    li r2,pabfil                ; address of filename in CPU PAB
     697E A18C     
0310 6980 DCB1  42 mkdskl  movb *r1+,*r2+              ; copy character of filename
0311 6982 0600  14         dec r0                      ; finished copying filename?
0312 6984 16FD  14         jne mkdskl
0313                   ; create a 128 byte block of space characters in vdp ram
0314 6986 0200  20         li r0,recbuf                ; vdp target address
     6988 1BA0     
0315 698A C800  38         mov r0,@pabbuf              ; set vdp source buffer address
     698C A184     
0316 698E 0201  20         li r1,>2000                 ; space character
     6990 2000     
0317 6992 0202  20         li r2,128                   ; 128 bytes to write
     6994 0080     
0318 6996 06A0  32         bl @vsbwmi                  ; write bytes
     6998 78B2     
0319                   ; put the pab into vdp ram, with an open opcode. open the file, dis/fix 128
0320 699A 0201  20         li r1,>8000                 ; logical record length: 128 bytes (in msb)
     699C 8000     
0321 699E D801  38         movb r1,@pablrl             ; set logical record length
     69A0 A186     
0322 69A2 04E0  34         clr @pabrec                 ; set record number to 0
     69A4 A188     
0323 69A6 06A0  32         bl @diskio
     69A8 6A1A     
0324 69AA 0003             byte open,3                 ; dis/fix output
0325 69AC 1312  14         jeq mkderr                  ; jump if error
0326                   ; the file should be created at this point. now write a record:
0327                   ; the number of kilobytes to create is in r6
0328 69AE 0207  20 next1k  li r7,8                     ; number of records for 1k. 8x128 bytes=1024
     69B0 0008     
0329 69B2 06A0  32 nxtrec  bl @diskio                  ; write the pab to vdp
     69B4 6A1A     
0330 69B6 0303             byte write,3                ; dis/fix output
0331 69B8 130C  14         jeq mkderr                  ; jump if error
0332 69BA 05A0  34         inc @pabrec                 ; increment record number
     69BC A188     
0333 69BE 0607  14         dec r7                      ; decrement record counter
0334 69C0 16F8  14         jne nxtrec                  ; repeat if we haven't written 8 records
0335 69C2 0606  14         dec r6                      ; decrement kilobyte counter
0336 69C4 16F4  14         jne next1k                  ; repeat if not finished
0337                   ; close the file
0338 69C6 06A0  32 mkclse  bl @diskio                  ; write the pab to vdp
     69C8 6A1A     
0339 69CA 0103             byte close,3                ; dis/fix output
0340 69CC 06A0  32         bl @rstsp                   ; restore code in scratchpad
     69CE 6B50     
0341                                                   ; (destroyed by DSR access)
0342 69D0 10B6  14         jmp bufxit
0343                   ; something went wrong...
0344 69D2 06C0  14 mkderr  swpb r0
0345 69D4 C800  38         mov r0,@errnum              ; set disk io error number
     69D6 A03A     
0346 69D8 10F6  14         jmp mkclse                  ; close file (for what it's worth) and exit
0347               ;]
0348               
0349               ;[ compute block address routine
0350               ; given buffer number on the stack, gives address of appropriate blk in r0
0351               ; and the associated vdp address in r1
0352               ; Used by CLEAN, DIRTY, and DIRTY?
0353 69DA C034  30 cba     mov *stack+,r0              ; get blk number
0354 69DC 0A20  28         sla r0,2                    ; convert to offset
0355 69DE 0201  20         li r1,blk0                  ; address of first blk
     69E0 A1B8     
0356 69E2 A001  18         a r1,r0                     ; get address of blk
0357 69E4 05C0  14         inct r0                     ; point to vdp address pointer
0358 69E6 C050  26         mov *r0,r1                  ; get vdp address
     **** ****     > RT
0001 69E8 045B  20        b * r11
                   < 1-06-Blocks.asm
0360               ;]
0361               
0362               ;[ Free Buffer subroutine. Scans for a free buffer.
0363               ; Returns a free blk address in r0.
0364               ; r0=0 means there are no free buffers
0365               ; a buffer will treated as free if it's dirty flag is not set
0366 69EA C0A0  34 frebuf  mov @totblk,r2              ; number of buffers to check
     69EC A1B2     
0367 69EE 0200  20         li r0,blk0                  ; buffer status pointer for 1st buffer
     69F0 A1B8     
0368 69F2 C050  26 nxtfb   mov *r0,r1                  ; check block assignment
0369 69F4 1305  14         jeq bfree                   ; jump if buffer is free
0370 69F6 0220  22         ai r0,4                     ; point to next blk
     69F8 0004     
0371 69FA 0602  14         dec r2                      ; finished?
0372 69FC 16FA  14         jne nxtfb                   ; check again if not
0373 69FE 04C0  14         clr r0                      ; there are no free buffers
     **** ****     > RT
0374               bfree   .rt
0001 6A00 045B  20        b * r11
                   < 1-06-Blocks.asm
0375               ;]
0376               
0377               ;[ scan buffers to see if the block in question is already in memory
0378               ; expects block number in r0
0379               ; returns address of blk in r1, or 0 if the block is not in memory
0380 6A02 0201  20 scnblk  li r1,blk0                  ; address of first buffer
     6A04 A1B8     
0381 6A06 C0A0  34         mov @totblk,r2              ; number of buffers to check
     6A08 A1B2     
0382 6A0A 8440  26 scnnxt  c r0,*r1                    ; is this the block we're looking for?
0383 6A0C 1305  14         jeq fndblk                  ; jump if yes
0384 6A0E 0221  22         ai r1,4                     ; check next buffer
     6A10 0004     
0385 6A12 0602  14         dec r2                      ; finished?
0386 6A14 16FA  14         jne scnnxt                  ; repeat if not
0387 6A16 04C1  14         clr r1                      ; not in memory
     **** ****     > RT
0388               fndblk  .rt
0001 6A18 045B  20        b * r11
                   < 1-06-Blocks.asm
0389               ;]
0390               
0391               ;[ put the pab into vdp ram with the appropriate opcode in byte 0 of pab
0392               ; then call dos...
0393 6A1A C83B  50 diskio  mov *r11+,@pabopc           ; load opcode and file format into ram pab
     6A1C A182     
0394 6A1E C28B  18         mov r11,r10                 ; save return address, as BL below will
0395                                                   ; destroy it
0396 6A20 0201  20         li r1,pabloc+9              ; vdp address of name length byte
     6A22 1B81     
0397 6A24 C801  30         mov r1,@namptr              ; move it to >8356 as per DSR requirements
     6A26 8356     
0398                   ; write the PAB into VDP ram...
0399 6A28 0200  20         li r0,pabloc                ; vdp destination
     6A2A 1B78     
0400 6A2C 0201  20         li r1,pabopc                ; source
     6A2E A182     
0401 6A30 0202  20         li r2,30                    ; number of bytes to copy to vdp
     6A32 001E     
0402 6A34 06A0  32         bl @_vmbw0                  ; write the pab to vdp
     6A36 7886     
0403 6A38 0420  50         blwp @dsrlnk                ; call dos
     6A3A 6A40     
0404 6A3C 0008             data 8                      ; disk op parameter, level 3 command
0405 6A3E 045A  20         b *r10
0406               ;]
0407               
0408               ;[ dsr link routine - Written by Paolo Bagnaresi
0409 6A40 A158     dsrlnk  data dsrlws                 ; dsrlnk workspace
0410 6A42 6A44             data dlentr                 ; entry point
0411               
0412 6A44 0200  20 dlentr  li r0,>aa00
     6A46 AA00     
0413 6A48 D800  38         movb r0,@haa                ; load haa
     6A4A A178     
0414 6A4C C17E  30         mov *r14+,r5                ; get pgm type for link
0415 6A4E C805  38         mov r5,@sav8a               ; save data following blwp @dsrlnk (8 or >a)
     6A50 A14A     
0416 6A52 53E0  34         szcb @h20,r15               ; reset equal bit
     6A54 6B4E     
0417 6A56 C020  30         mov @>8356,r0               ; get ptr to pab
     6A58 8356     
0418 6A5A C240  18         mov r0,r9                   ; save ptr
0419 6A5C C800  38         mov r0,@flgptr              ; save again pointer to pab+1 for dsrlnk
     6A5E A156     
0420                                                   ; data 8
0421 6A60 0229  22         ai r9,>fff8                 ; adjust to flag
     6A62 FFF8     
0422 6A64 06A0  32         bl @_vsbr                   ; read device name length
     6A66 7816     
0423 6A68 D0C1  18         movb r1,r3                  ; copy it
0424 6A6A 0983  40         srl r3,8                    ; make it lo byter
0425 6A6C 0704  14         seto r4                     ; init counter
0426 6A6E 0202  20         li r2,namsto                ; point to buffer
     6A70 A17A     
0427 6A72 0580  14 lnkslp  inc r0                      ; point to next char of name
0428 6A74 0584  14         inc r4                      ; incr char counter
0429 6A76 0284  22         ci r4,>0007                 ; see if length more than 7 chars
     6A78 0007     
0430 6A7A 1561  14         jgt lnkerr                  ; yes, error
0431 6A7C 80C4  18         c r4,r3                     ; end of name?
0432 6A7E 1306  14         jeq lnksln                  ; yes
0433 6A80 06A0  32         bl @_vsbr                   ; read curr char
     6A82 7816     
0434 6A84 DC81  32         movb r1,*r2+                ; move into buffer
0435 6A86 9801  34         cb r1,@decmal               ; is it a period?
     6A88 6B4C     
0436 6A8A 16F3  14         jne lnkslp                  ; no
0437 6A8C C104  18 lnksln  mov r4,r4                   ; see if 0 length
0438 6A8E 1357  14         jeq lnkerr                  ; yes, error
0439 6A90 04E0  26         clr @>83d0
     6A92 83D0     
0440 6A94 C804  30         mov r4,@>8354               ; save name length for search
     6A96 8354     
0441 6A98 C804  38         mov r4,@savlen              ; save it here too
     6A9A A150     
0442 6A9C 0584  14         inc r4                      ; adjust for period
0443 6A9E A804  30         a r4,@>8356                 ; point to position after name
     6AA0 8356     
0444 6AA2 C820  50         mov @>8356,@savpab          ; save pointer to position after name
     6AA4 8356     
     6AA6 A152     
0445 6AA8 02E0  18 srom    lwpi >83e0                  ; use gplws
     6AAA 83E0     
0446 6AAC 04C1  14         clr r1                      ; version found of dsr
0447 6AAE 020C  20         li r12,>0f00                ; init cru addr
     6AB0 0F00     
0448 6AB2 C30C  18 norom   mov r12,r12                 ; anything to turn off?
0449 6AB4 1301  14         jeq nooff                   ; no
0450 6AB6 1E00  16         sbz 0                       ; yes, turn off
0451 6AB8 022C  22 nooff   ai r12,>0100                ; next rom to turn on
     6ABA 0100     
0452 6ABC 04E0  26         clr @>83d0                  ; clear in case we are done
     6ABE 83D0     
0453 6AC0 028C  22         ci r12,>2000                ; see if done
     6AC2 2000     
0454 6AC4 133A  14         jeq nodsr                   ; yes, no dsr match
0455 6AC6 C80C  30         mov r12,@>83d0              ; save addr of next cru
     6AC8 83D0     
0456 6ACA 1D00  16         sbo 0                       ; turn on rom
0457 6ACC 0202  20         li r2,>4000                 ; start at beginning of rom
     6ACE 4000     
0458 6AD0 9812  42         cb *r2,@haa                 ; check for a valid rom
     6AD2 A178     
0459 6AD4 16EE  14         jne norom                   ; no rom here
0460 6AD6 A0A0  34         a @dstype,r2                ; go to first pointer
     6AD8 A162     
0461 6ADA 1003  14         jmp sgo2
0462 6ADC C0A0  30 sgo     mov @>83d2,r2               ; continue where we left off
     6ADE 83D2     
0463 6AE0 1D00  16         sbo 0                       ; turn rom back on
0464 6AE2 C092  26 sgo2    mov *r2,r2                  ; is addr a zero (end of link)
0465 6AE4 13E6  14         jeq norom                   ; yes, no programs to check
0466 6AE6 C802  30         mov r2,@>83d2               ; remember where to go next
     6AE8 83D2     
0467 6AEA 05C2  14         inct r2                     ; go to entry point
0468 6AEC C272  30         mov *r2+,r9                 ; get entry addr just in case
0469 6AEE D160  30         movb @>8355,r5              ; get length as counter
     6AF0 8355     
0470 6AF2 1309  14         jeq namtwo                  ; if zero, do not check
0471 6AF4 9C85  28         cb r5,*r2+                  ; see if length matches
0472 6AF6 16F2  14         jne sgo                     ; no, try next
0473 6AF8 0985  40         srl r5,8                    ; yes, move to lo byte as counter
0474 6AFA 0206  20         li r6,namsto                ; point to buffer
     6AFC A17A     
0475 6AFE 9CB6  38 namone  cb *r6+,*r2+                ; compare buffer with rom
0476 6B00 16ED  14         jne sgo                     ; try next if no match
0477 6B02 0605  14         dec r5                      ; loop til full length checked
0478 6B04 16FC  14         jne namone
0479 6B06 0581  14 namtwo  inc r1                      ; next version found
0480 6B08 C801  38         mov r1,@savver              ; save version
     6B0A A154     
0481 6B0C C809  38         mov r9,@savent              ; save entry addr
     6B0E A14E     
0482 6B10 C80C  38         mov r12,@savcru             ; save cru
     6B12 A14C     
0483 6B14 0699  24         bl *r9                      ; go run routine
0484 6B16 10E2  14         jmp sgo                     ; error return
0485 6B18 1E00  16         sbz 0                       ; turn off rom if good return
0486 6B1A 02E0  18         lwpi dsrlws                 ; restore workspace
     6B1C A158     
0487 6B1E C009  30         mov r9,r0                   ; point to flag in pab
0488 6B20 C060  42 frmdsr  mov @sav8a,r1               ; get back data following blwp @dsrlnk
     6B22 A14A     
0489                                                   ; (8 or >a)
0490 6B24 0281  26         ci r1,8                     ; was it 8?
     6B26 0008     
0491 6B28 1303  14         jeq dsrdt8                  ; yes, jump: normal dsrlnk
0492 6B2A D060  38         movb @>8350,r1              ; no, we have a data >a. get error byte from
     6B2C 8350     
0493                                                   ; >8350
0494 6B2E 1002  14         jmp dsrdta                  ; go and return error byte to the caller
0495 6B30 06A0  36 dsrdt8  bl @_vsbr                   ; read flag
     6B32 7816     
0496 6B34 09D1  58 dsrdta  srl r1,13                   ; just keep error bits
0497 6B36 1604  14         jne ioerr                   ; handle error
0498 6B38 0380  30         rtwp
0499 6B3A 02E0  18 nodsr   lwpi dsrlws                 ; no dsr, restore workspace
     6B3C A158     
0500 6B3E 04C1  22 lnkerr  clr r1                      ; clear flag for error 0 = bad device name
0501 6B40 06C1  22 ioerr   swpb r1                     ; put error in hi byte
0502 6B42 D741  38         movb r1,*r13                ; store error flags in callers r0
0503 6B44 F3E0  42         socb @h20,r15               ; set equal bit to indicate error
     6B46 6B4E     
0504 6B48 0380  30         rtwp
0505               
0506 6B4A 0008     data8   data >8                     ; just to compare. 8 is the data that
0507                                                   ; usually follows a blwp @dsrlnk
0508 6B4C 2E       decmal  text '.'                    ; for finding end of device name
0509                       even
0510 6B4E 2000     h20     data >2000
0511               ;]
0512               
0513               ;[ restore code to scratch-pad ram
0514               ; accessing the disk via the disk DSR destroys some code in scratch pad
0515               ; restore the code in scratch pad before returning
0516 6B50 0200  24 rstsp   li r0,toram                 ; address of 1st source block
     6B52 7F6C     
0517 6B54 0201  24         li r1,docol                 ; destination
     6B56 8320     
0518 6B58 CC70  62 rstsp1  mov *r0+,*r1+               ; copy a cell
0519 6B5A 0280  26         ci r0,__dup
     6B5C 7FBA     
0520 6B5E 1602  14         jne rstsp3
0521 6B60 0201  24         li r1,_dup
     6B62 8382     
0522 6B64 0280  26 rstsp3  ci r0,padend                ; hit end of first block of code?
     6B66 7FF8     
0523 6B68 16F7  14         jne rstsp1                  ; loop if not
     **** ****     > RT
0001 6B6A 045B  24        b * r11
                   < 1-06-Blocks.asm
0525               ;]
                   < build.asm
0044                   copy "./bank1/1-07-Double.asm"
     **** ****     > ./bank1/1-07-Double.asm
0001               
0002               ; Double Number Words - removed and included in the 32-bit library
0003               
0004               ;[ 2DROP ( d -- )
0005               ;_drop2 dect stack               ; move back up the stack 4 bytes
0006               ;       dect stack
0007               ;drop2x b @retB0
0008               ;]
0009               
0010               ;[ 2DUP ( d -- d d )
0011 6B6C C914  54 _dup2   mov *stack,@-4(stack)       ; copy tos
     6B6E FFFC     
0012 6B70 0644  22         dect stack
0013 6B72 C524  54         mov @4(stack),*stack
     6B74 0004     
0014 6B76 0644  22         dect stack
0015 6B78 0460  24         b @retB0
     6B7A 833A     
0016               ;]
0017               
                   < build.asm
0045                   copy "./bank1/1-08-Parsing.asm"
     **** ****     > ./bank1/1-08-Parsing.asm
0001               ;  _____                _              __          __            _
0002               ; |  __ \              (_)             \ \        / /           | |
0003               ; | |__) |__ _ _ __ ___ _ _ __   __ _   \ \  /\  / /___  _ __ __| |___
0004               ; |  ___// _` | '__/ __| | '_ \ / _` |   \ \/  \/ // _ \| '__/ _` / __|
0005               ; | |   | (_| | |  \__ \ | | | | (_| |    \  /\  /| (_) | | | (_| \__ \
0006               ; |_|    \__,_|_|  |___/_|_| |_|\__, |     \/  \/  \___/|_|  \__,_|___/
0007               ;                                __/ |
0008               ;                               |___/
0009               ; Dictionary lookup and associated parsing words
0010               
0011               ;[ WORD ( delimiter address -- address length )
0012               ;
0013               ; Moves through TIB in VDP memory, discarding leading delimiters,
0014               ; looking for a word. A word is identified when a trailing delimiter is
0015               ; detected. The identified word is copied from VDP to a buffer in CPU memory.
0016               ; Pushes the start address of the word (in CPU memory), and the length of
0017               ; the word to the stack. If no word is found (for example if we hit the
0018               ; end of the TIB without detecting a word then 0 0 is pushed on the
0019               ; stack.
0020 6B7C C014  38 _word   mov *stack,r0               ; buffer address
0021 6B7E A020  42         a @in,r0                    ; add offset
     6B80 A044     
0022 6B82 C0A4  46         mov @2(stack),r2            ; delimeter
     6B84 0002     
0023 6B86 0A82  48         sla r2,8                    ; move to high-byte
0024 6B88 0206  24         li r6,wrdbuf+1              ; address of cpu word buffer
     6B8A A1D3     
0025 6B8C C906  46         mov r6,@2(stack)            ; push it to stack
     6B8E 0002     
0026 6B90 04C8  22         clr r8                      ; length counter
0027 6B92 C1E0  42         mov @_span,r7               ; number of chars in buffer
     6B94 A04E     
0028 6B96 131F  14         jeq noword                  ; if 0 then there's no word
0029 6B98 8820  50         c @in,@_span                ; hit end of buffer?
     6B9A A044     
     6B9C A04E     
0030 6B9E 141B  14         jhe noword                  ; if yes then exit
0031               
0032 6BA0 06A0  36 wrd1    bl @wrdgb                   ; read a character and advance along input
     6BA2 6BE8     
0033 6BA4 05A0  34         inc @in                     ; advance >IN
     6BA6 A044     
0034 6BA8 9081  26         cb r1,r2                    ; was the character a delimiter?
0035 6BAA 13FA  14         jeq wrd1                    ; if yes then get another character
0036 6BAC 8820  50         c @in,@_span                ; hit end of buffer?
     6BAE A044     
     6BB0 A04E     
0037 6BB2 150F  14         jgt wrdfin                  ; if yes then quit
0038 6BB4 DD81  44 wrd2    movb r1,*r6+                ; move character to word buffer
0039 6BB6 0588  22         inc r8                      ; increment length
0040 6BB8 8808  38         c r8,@tibsiz                ; have we fully populated the word buffer?
     6BBA A04C     
0041 6BBC 130A  14         jeq wrdfin                  ; if yes then exit
0042 6BBE 06A0  36         bl @wrdgb                   ; read a character and advance along input
     6BC0 6BE8     
0043 6BC2 05A0  34         inc @in                     ; advance >in
     6BC4 A044     
0044 6BC6 8820  50         c @in,@_span                ; hit end of buffer?
     6BC8 A044     
     6BCA A04E     
0045 6BCC 1502  14         jgt wrdfin                  ; if yes then quit
0046 6BCE 9081  26         cb r1,r2                    ; was the character a delimeter?
0047 6BD0 16F1  14         jne wrd2                    ; if not then get another character
0048 6BD2 C508  38 wrdfin  mov r8,*stack               ; push length to stack
0049 6BD4 1004  14         jmp wrdxit1                 ; exit
0050 6BD6 04D4  30 noword  clr *stack                  ; no word found, push 0 length
0051 6BD8 04E4  38         clr @2(stack)               ; zero address
     6BDA 0002     
0052 6BDC 04C8  22         clr r8
0053 6BDE 06C8  22 wrdxit1 swpb r8                     ; populate length byte (for packed string)
0054 6BE0 D808  42         movb r8,@wrdbuf
     6BE2 A1D2     
0055 6BE4 0460  24 wrdxit2 b @retB0
     6BE6 833A     
0056               
0057 6BE8 C3E0  42 wrdgb   mov @source,r15             ; check source
     6BEA A05A     
0058 6BEC 1302  14         jeq vread                   ; if 0 then read from vdp
0059                   ; special case: if EVALUATE is active then the evaluation string will be in
0060                   ; CPU RAM
0061 6BEE D070  44         movb *r0+,r1                ; otherwise read from cpu and advance buffer
     **** ****     > RT
0001 6BF0 045B  24        b * r11
                   < 1-08-Parsing.asm
0063 6BF2 C38B  30 vread   mov r11,r14                 ; save return address
0064 6BF4 06A0  36 vread1  bl @_vsbr                   ; read from vdp
     6BF6 7816     
0065 6BF8 0580  22 vread2  inc r0                      ; advance input buffer address
0066 6BFA 045E  24         b *r14                      ; return to caller
0067               ;]
0068               
0069               ;[ code for processing \ type comments
0070               ; assembly equivalent of : \ >IN @ 64 + -64 AND >IN ! ; IMMEDIATE
0071 6BFC C020  42 _trcom  mov @blknum,r0              ; loading a block?
     6BFE A1B4     
0072 6C00 1309  14         jeq trcom1                  ; jump if not
0073 6C02 C020  42         mov @in,r0
     6C04 A044     
0074 6C06 0220  30         ai r0,64
     6C08 0040     
0075 6C0A 0240  30         andi r0,-64
     6C0C FFC0     
0076 6C0E C800  42         mov r0,@in
     6C10 A044     
0077 6C12 10E8  14         jmp wrdxit2                 ; exit (jump is smaller than a branch!)
0078 6C14 C820  54 trcom1  mov @tibsiz,@in             ; set >IN to the end of the line
     6C16 A04C     
     6C18 A044     
0079 6C1A 10E4  14 comxit  jmp wrdxit2                 ; exit (jump is smaller than a branch!)
0080               ;]
0081               
0082               ;[ NUMBER ( address length -- (numberMSW) numberLSW error )
0083               ; Attempts to convert the string at cpu address address into a number.
0084               ; If fully successful, the number is placed on the stack and flag will be 0.
0085               ; If it fails (for example contains an illegal character) then a partial number
0086               ; will be placed on the stack (the value computed up until the failure) and
0087               ; flag will be -1. This allows neat trapping with ABORT""
0088               ; Thus, if flag<>0 the string failed to parse fully as a number.
0089               ; A minus sign is permitted for negative numbers.
0090               ; This routine uses BASE to parse numbers in the current BASE.
0091               ; Eg. If BASE=16 then digits 0-9 and A-F are considered legal and will be
0092               ; parsed properly.
0093               ; A facility also exists called 'quick hex' that allows a number to be entered
0094               ; in base 16, by placing a $ symbol at the beginning of the string. This avoids
0095               ; the need to change BASE to enter a number. E.g. instead of HEX FEED DECIMAL
0096               ; you can simply do $FEED. The number will be parsed as a HEX number without the
0097               ; need to change BASE.
0098               ; The same facility also exists for binary numbers: use a % symbol.
0099               ; E.g. %1001 = 9 decimal
0100               ; The numbers returned are (by default) singles (16 bits). NUMBER can can also
0101               ; return a double (32-bit (2 stack cells)) value by including a period in the
0102               ; number string. E.g. 100. 1.00 10.0 .100 will all return 100 decimal as a
0103               ; double.
0104               ; The various facilities can be mixed. For example, -$.F means -15 as a double.
0105 6C1C C074  46 _numbr  mov *stack+,r1              ; pop length
0106 6C1E C014  38         mov *stack,r0               ; get address from stack
0107                      ; parse the number string...
0108 6C20 04C6  22 parsnm  clr r6                      ; initialise MSW
0109 6C22 04C8  22         clr r8                      ; initialise LSW
0110 6C24 04CD  22         clr r13                     ; clear negative flag
0111 6C26 04CC  22         clr r12                     ; clear 'double required' flag
0112 6C28 0720  34         seto @dpl                   ; assume single precision
     6C2A A056     
0113                   ; begin ugly hack - check the end of the number for a period character
0114                   ; if found, set double indicator (R12) to on and reduce length of string
0115                   ; by 1. Added for TF V1.1 double precision library support
0116 6C2C C3C0  30         mov r0,r15                  ; copy string address
0117 6C2E A001  30         a r1,0                      ; add length
0118 6C30 0600  22         dec r0                      ; point to last character in the buffer
0119 6C32 D0B0  44         movb *r0+,r2                ; get character from buffer
0120 6C34 0982  48         srl r2,8                    ; move it to low byte
0121 6C36 0282  26         ci r2,'.'                   ; is it a period character?
     6C38 002E     
0122 6C3A 1604  14         jne xugly                   ; if not then skip
0123 6C3C 070C  22         seto r12                    ; otherwise set the double flag to on
0124 6C3E 0601  22         dec r1                      ; and reduce the length for the string so
0125                                                   ; that the period will not be seen by the
0126                                                   ; number parser
0127 6C40 0720  34         seto @dpl                   ; double integer
     6C42 A056     
0128                   ; end ugly hack
0129 6C44 C00F  30 xugly   mov r15,r0
0130 6C46 C3A0  42         mov @base,r14               ; get base
     6C48 A05E     
0131 6C4A 060E  22         dec r14                     ; base-1=highest legal digital for base
0132 6C4C D0B0  44 num0    movb *r0+,r2                ; get character from buffer
0133 6C4E 0982  48         srl r2,8                    ; move it to low byte
0134 6C50 0282  26 num4    ci r2,'%'                   ; is it a % sign (binary)
     6C52 0025     
0135 6C54 1603  14         jne num5
0136 6C56 020E  24         li r14,1                    ; set binary base
     6C58 0001     
0137 6C5A 1017  14         jmp num3                    ; do next character
0138 6C5C 0282  26 num5    ci r2,'.'                   ; is it a dot?
     6C5E 002E     
0139 6C60 160A  14         jne num1                    ; skip if not
0140                   ; double detected - set r12 as flag, and calculate value for DPL
0141 6C62 070C  22         seto r12                    ; else double is required - set flag
0142 6C64 C3E4  46         mov @2(stack),r15           ; get string length
     6C66 0002     
0143 6C68 C1CF  30         mov r15,r7                  ;
0144 6C6A 61C1  30         s r1,r7                     ; subtract current position from length
0145 6C6C 63C7  30         s r7,r15                    ; get length to the right of the dec. point
0146 6C6E 060F  22         dec r15                     ; correcty length due to decimal point
0147 6C70 C80F  42         mov r15,@dpl                ; store in DPL
     6C72 A056     
0148 6C74 100A  14         jmp num3                    ; do next character
0149 6C76 0282  26 num1    ci r2,'$'                   ; is it a dollar sign?
     6C78 0024     
0150 6C7A 1603  14         jne num2                    ; skip if not
0151 6C7C 020E  24         li r14,15                   ; force base temporarily to 16-1 for hex
     6C7E 000F     
0152 6C80 1004  14         jmp num3                    ; check next character
0153 6C82 0282  26 num2    ci r2,'-'                   ; is it a negative sign?
     6C84 002D     
0154 6C86 1603  14         jne numlz                   ; skip if not
0155 6C88 070D  22         seto r13                    ; else set negative flag
0156 6C8A 0601  22 num3    dec r1                      ; decrement counter
0157 6C8C 10DF  14         jmp num0                    ; get next character
0158               
0159                   ; digit range checks...
0160 6C8E 0282  26 numlz   ci r2,'0'                   ; check if ascii code < "0"
     6C90 0030     
0161 6C92 1A17  14         jl ohshit                   ; error if yes
0162 6C94 0282  26         ci r2,'z'                   ; check if ascii code > "z"
     6C96 007A     
0163 6C98 1B14  14         jh ohshit                   ; error if yes
0164               
0165                   ; check if is numeric digit
0166 6C9A 0282  26         ci r2,'9'
     6C9C 0039     
0167 6C9E 1216  14         jle numisd                  ; it IS a digit
0168               
0169                   ; check if is upper case digit
0170 6CA0 0282  26         ci r2,'A'
     6CA2 0041     
0171 6CA4 1401  14         jhe numt1
0172 6CA6 100D  14         jmp ohshit
0173 6CA8 0282  26 numt1   ci r2,'Z'
     6CAA 005A     
0174 6CAC 120C  14         jle numisl                  ;
0175               
0176                   ; check if is lower case digit
0177 6CAE 0282  26         ci r2,'a'
     6CB0 0061     
0178 6CB2 1401  14         jhe numt2
0179 6CB4 1006  14         jmp ohshit
0180 6CB6 0282  26 numt2   ci r2,'z'
     6CB8 007A     
0181 6CBA 1403  14         jhe ohshit
0182 6CBC 0222  30         ai r2,-87                   ; convert to number
     6CBE FFA9     
0183 6CC0 1007  14         jmp numgo
0184               
0185                   ; illegal digit
0186 6CC2 0700  22 ohshit  seto r0                     ; else illegal digit was detected
0187 6CC4 1018  14         jmp nexit                   ; indicate error
0188               
0189 6CC6 0222  30 numisl  ai r2,-55                   ; convert from upper case to number
     6CC8 FFC9     
0190                                                   ; ("A" (65) becomes 10)
0191 6CCA 1002  14         jmp numgo                   ; start the conversion
0192 6CCC 0222  30 numisd  ai r2,-48                   ; convert from ascii to decimal
     6CCE FFD0     
0193                                                   ; ("0" (48) becomes 0)
0194               ; parse the string into a 32 bit number...
0195 6CD0 8382  26 numgo   c r2,r14                    ; compare to base
0196 6CD2 1BF7  14         jh ohshit                   ; if digit outside current base's legal
0197                                                   ; range then exit
0198 6CD4 A202  30         a r2,r8                     ; add digit to LSW
0199 6CD6 0601  22         dec r1                      ; finished?
0200 6CD8 1309  14         jeq numend                  ; jump if yes
0201 6CDA C08E  30         mov r14,r2                  ; base-1 to r2
0202 6CDC 0582  22         inc r2                      ; correct to base
0203 6CDE C1C8  30         mov r8,r7                   ; get our lsw in r7
0204 6CE0 39C2  74         mpy r2,r7                   ; multiply it by current base
0205 6CE2 C246  30         mov r6,r9                   ; get our MSW
0206 6CE4 3A42  74         mpy r2,r9                   ; multiply it by current base
0207 6CE6 C18A  30         mov r10,r6                  ; move it back
0208 6CE8 A187  30         a r7,r6                     ; add MSW from MPY to *our* MSW
0209 6CEA 10B0  14         jmp num0                    ; do next digit
0210 6CEC 04C0  22 numend  clr r0                      ; finished with no errors, clear error flag
0211 6CEE C34D  30         mov r13,r13                 ; and check negative flag
0212 6CF0 1302  14         jeq nexit                   ; jump if not set (positive number)
0213 6CF2 0546  22         inv r6                      ; else two's complement the 32 bit word
0214 6CF4 0508  22         neg r8
0215 6CF6 C508  38 nexit   mov r8,*stack               ; push least sig word
0216 6CF8 0644  22         dect stack                  ; advance stack
0217 6CFA C80C  42         mov r12,@isdbl              ; was a double returned?
     6CFC A054     
0218 6CFE 1302  14         jeq pusher                  ; if not, skip
0219 6D00 C506  38         mov r6,*stack               ; push most sig word
0220 6D02 0644  22         dect stack                  ; advance stack
0221 6D04 C500  38 pusher  mov r0,*stack               ; push error flag
0222 6D06 020C  24         li r12,_next                ; restore r12
     6D08 8326     
0223 6D0A 1087  14         jmp comxit                  ; exit
0224                                                   ; (a jump is 2 bytes shorter than a branch)
0225               ;]
0226               
0227 6D0C 2000     _space  data >2000
                   < build.asm
0046                   copy "./bank1/1-09-Compilation.asm"
     **** ****     > ./bank1/1-09-Compilation.asm
0001               ;   _____                       _ _ _              __          __            _
0002               ;  / ____|                     (_) (_)             \ \        / /           | |
0003               ; | |      ___  _ __ ___  _ __  _| |_ _ __   __ _   \ \  /\  / /___  _ __ __| |___
0004               ; | |     / _ \| '_ ` _ \| '_ \| | | | '_ \ / _` |   \ \/  \/ // _ \| '__/ _` / __|
0005               ; | |____| (_) | | | | | | |_) | | | | | | | (_| |    \  /\  /| (_) | | | (_| \__ \
0006               ;  \_____|\___/|_| |_| |_| .__/|_|_|_|_| |_|\__, |     \/  \/  \___/|_|  \__,_|___/
0007               ;                        | |                 __/ |
0008               ;                        |_|                |___/
0009               ; Compilation words...
0010               
0011               ;[ HEADER ( address length -- )
0012               ; creates a dictionary entry starting at HERE, and links it to the previous
0013               ; dictionary entry.
0014 6D0E C074  46 _headr  mov *stack+,r1              ; length in r1
0015 6D10 0241  30         andi r1,15                  ; restrict length to 15
     6D12 000F     
0016 6D14 C181  30 hdr0    mov r1,r6                   ; copy length of word to use as a counter
0017                   ;    mov @blknum,r0              ; get 'are we loading?' flag
0018 6D16 C020  42         mov @lstblk,r0              ; get 'are we loading?' flag
     6D18 A1B6     
0019 6D1A 1303  14         jeq hdr1                    ; if not then skip
0020 6D1C 0600  22         dec r0                      ; decrement by 1 to give room for 0 to 1023
0021 6D1E 0A40  40         sla r0,4                    ; shift into position
0022 6D20 E040  30         soc r0,r1                   ; OR into length word
0023 6D22 C034  46 hdr1    mov *stack+,r0              ; pop address of word to r0
0024 6D24 C0A0  42         mov @here,r2                ; here to r2
     6D26 A048     
0025 6D28 C4A0  50         mov @latest,*r2             ; create link to previous dictionary entry
     6D2A A046     
0026 6D2C C802  42         mov r2,@latest              ; update latest to point to this entry
     6D2E A046     
0027 6D30 05C2  22         inct r2                     ; move forward in memory
0028 6D32 CC81  46         mov r1,*r2+                 ; append length of word to dictionary entry
0029 6D34 DCB0  58 crtlp   movb *r0+,*r2+              ; get a character
0030 6D36 0606  22         dec r6                      ; finished copying name?
0031 6D38 16FD  14         jne crtlp                   ; repeat if not
0032 6D3A 0582  22         inc r2                      ; we're gonna force r2 to an even address...
0033 6D3C 0242  30         andi r2,>fffe               ; force to even address
     6D3E FFFE     
0034 6D40 C802  42         mov r2,@here                ; update here
     6D42 A048     
0035 6D44 C802  42         mov r2,@patch               ; update most recent CFA locaation
     6D46 A06C     
0036 6D48 C002  30         mov r2,r0                   ; copy to r0 for memory pointer adjust rtn.
0037 6D4A 1005  14         jmp mpadj                   ; update memory free pointers and exit
0038               ;]
0039               
0040               ;[ , (COMMA) ( value -- )
0041               ; appends 16 bit word on TOS to the user memory addressed by HERE and updates
0042               ; HERE to point to next word
0043 6D4C C020  42 _comma  mov @here,r0                ; get next free address in r0
     6D4E A048     
0044 6D50 CC34  62         mov *stack+,*r0+            ; pop value to HERE
0045 6D52 C800  42         mov r0,@here                ; update HERE
     6D54 A048     
0046 6D56 0280  26 mpadj   ci r0,>a000                 ; are we in high memory?
     6D58 A000     
0047 6D5A 1A03  14         jl  lomadj                  ; no, take the jump
0048 6D5C C800  42         mov r0,@ffaihm              ; we must be writing in low ram. update low
     6D5E A01E     
0049                                                   ; mem pointer
0050 6D60 1002  14         jmp commax
0051 6D62 C800  42 lomadj  mov r0,@ffailm              ; update high memory pointer
     6D64 A01C     
0052 6D66 0460  24 commax  b @retB0
     6D68 833A     
0053               ;]
0054               
0055               ;[ C, (COMMA) ( value -- )
0056               ; appends an 8 bit value, from the least significant byte of TOS to HERE.
0057               ; Here is incremented by ONE BYTE, not one WORD.
0058               ; For safety, use ALIGN to align HERE to a word boundary afterwards.
0059 6D6A C020  42 _comab  mov @here,r0                ; get next free address in r0
     6D6C A048     
0060 6D6E C074  46         mov *stack+,r1              ; get stack value in r1
0061 6D70 06C1  22         swpb r1                     ; get TOS in most significant byte
0062 6D72 DC01  44         movb r1,*r0+                ; mov data in TOS to HERE and increment by
0063                                                   ; one byte
0064 6D74 C800  42         mov r0,@here                ; update HERE
     6D76 A048     
0065 6D78 10EE  14         jmp mpadj                   ; update memory pointers
0066               ;]
0067               
0068               ;[ ALIGN ( -- )
0069               ; Aligns HERE to an even word boundary by rounding up if required
0070               ; Call it after using C!
0071 6D7A C020  42 _align  mov @here,r0                ; get HERE
     6D7C A048     
0072 6D7E 0580  22         inc r0                      ; add 1
0073 6D80 0240  30         andi r0,>fffe               ; round up if required
     6D82 FFFE     
0074 6D84 C800  42         mov r0,@here                ; store it
     6D86 A048     
0075 6D88 10E6  14         jmp mpadj                   ; update memory pointers
0076               ;]
0077               
0078               ;[ HIDDEN ( dictionary_address -- )
0079               ; toggles the hidden attribute on the dictionary entry
0080               ; normally you would hide a word after defining it with: LATEST @ HIDDEN
0081 6D8A C034  46 _hide   mov *stack+,r0              ; pop address of dictionary entry to r0
0082 6D8C 05C0  22         inct r0                     ; point to length entry
0083 6D8E C050  38         mov *r0,r1                  ; get the length entry
0084 6D90 2860  36         xor @_bit1,r1               ; toggle hidden bit (weight >4000)
     6D92 78E8     
0085 6D94 C401  38         mov r1,*r0                  ; store it
0086 6D96 10E7  14         jmp commax
0087               ;]
0088               
0089               ;[ IMMEDIATE ( -- )
0090               ; toggles the immediate bit in the dictionary entry pointed to by LATEST.
0091 6D98 C020  42 _imm    mov @latest,r0              ; get address of latest dictionary entry
     6D9A A046     
0092 6D9C 05C0  22         inct r0                     ; point to length entry
0093 6D9E C050  38         mov *r0,r1                  ; get the length entry
0094 6DA0 2860  36         xor @_bit0,r1               ; toggle immediate bit (weight >8000)
     6DA2 78E6     
0095 6DA4 C401  38         mov r1,*r0                  ; store it
0096 6DA6 10DF  14         jmp commax
0097               ;]
0098               
0099               ;[ ALLOT ( n -- )
0100               ; reserves n BYTES of memory, staring from HERE
0101 6DA8 A834  58 _allot  a *stack+,@here             ; pop and add n to HERE
     6DAA A048     
0102 6DAC C020  42         mov @here,r0                ; get HERE in r0 for mpadj routine
     6DAE A048     
0103 6DB0 10D2  14         jmp mpadj                   ; adjust memory pointers
0104               ;]
0105               
0106               ;[ COMPILE ( -- )
0107               ; Used in colon definitiona. Compiles the next word into the current definition
0108               ; the word is not executed. E.g. COMPILE DROP compiles DROP to HERE. DROP is not
0109               ; actually executed
0110               ; important note: see COMPILE in 0-10-Compilation.a99
0111 6DB2 C020  42 _compil mov @here,r0                ; get HERE
     6DB4 A048     
0112 6DB6 CC01  46         mov r1,*r0+                 ; compile next word to HERE & increase HERE
0113 6DB8 C800  42         mov r0,@here                ; save HERE
     6DBA A048     
0114 6DBC 10CC  14         jmp mpadj                   ; adjust memory pointers
0115               ;]
                   < build.asm
0047                   copy "./bank1/1-10-Strings.asm"
     **** ****     > ./bank1/1-10-Strings.asm
0001               ;   _____ _        _              __          __            _
0002               ;  / ____| |      (_)             \ \        / /           | |
0003               ; | (___ | |_ _ __ _ _ __   __ _   \ \  /\  / /___  _ __ __| |___
0004               ;  \___ \| __| '__| | '_ \ / _` |   \ \/  \/ // _ \| '__/ _` / __|
0005               ;  ____) | |_| |  | | | | | (_| |    \  /\  /| (_) | | | (_| \__ \
0006               ; |_____/ \__|_|  |_|_| |_|\__, |     \/  \/  \___/|_|  \__,_|___/
0007               ; string related words      __/ |
0008               ;                          |___/
0009               
0010               ;[ RND ( limit -- n)
0011               ; pushes a pseudo random number between 0 and limit-1 (rnd MOD limit)
0012               ; For the full range (0-65535) use a limit of 0
0013 6DBE C060  42 _rnd    mov @seed,r1
     6DC0 A078     
0014 6DC2 0200  24         li r0,>6fe5                 ; multiplier
     6DC4 6FE5     
0015 6DC6 3840  74         mpy r0,r1                   ; mpultiply r1 by r0
0016 6DC8 0222  30         ai r2,>7ab9                 ; add 7ab9 to r2
     6DCA 7AB9     
0017 6DCC 0B52  34         src r2,5                    ; rotate r2 5 bits right
0018 6DCE C802  42         mov r2,@seed
     6DD0 A078     
0019 6DD2 04C1  22         clr r1                      ; msw of dividend
0020 6DD4 3C54 156         div *stack,r1               ; divide R1 by # on stack
0021 6DD6 C502  38         mov r2,*stack               ; copy remainder, R2, to stack
0022 6DD8 0460  24 rndx    b @retb0
     6DDA 833A     
0023               ;]
0024               
0025               ;[ COUNT ( addr1 -- addr2 len )
0026               ; addr2 is addr1+1 and len is the length of the counted string at addr1.
0027               ; The byte at addr1 contains the byte count len. Range of len is {0.255}
0028 6DDC C014  38 _count  mov *stack,r0               ; get addr1
0029 6DDE D1D0  38         movb *r0,r7                 ; get length byte from addr1
0030 6DE0 0987  48         srl r7,8                    ; move to low byte
0031 6DE2 0594  30         inc *stack                  ; increment addr1 to make addr2
0032 6DE4 0644  22 PAE     dect stack                  ; make space on stack
0033 6DE6 C507  38         mov r7,*stack               ; push length
0034 6DE8 10F7  14         jmp rndx
0035               ;]
0036               
0037               ;[ -TRAILING ( addr len -- addr len )
0038               ; modifies len such that trailing spaces are excluded from the string
0039 6DEA C514  46 _trail  mov *stack,*stack           ; check length
0040 6DEC 1308  14         jeq trlout                  ; if 0 then exit
0041 6DEE 1107  14         jlt trlout                  ; if negative then exit
0042 6DF0 C024  46         mov @2(stack),r0            ; address
     6DF2 0002     
0043 6DF4 A014  38         a *stack,r0                 ; move to end of string+1
0044 6DF6 0600  22         dec r0                      ; correct to point to last character
0045 6DF8 9810  46 trail2  cb *r0,@_space              ; compare to a space
     6DFA 6D0C     
0046 6DFC 1301  14         jeq trail1                  ; if a space, reduce length
0047 6DFE 10EC  14 trlout  jmp rndx                    ; else exit
0048 6E00 0614  30 trail1  dec *stack                  ; reduce length
0049 6E02 13EA  14         jeq rndx                    ; if we get to 0 then exit
0050 6E04 0600  22         dec r0                      ; else check next address
0051 6E06 10F8  14         jmp trail2
0052               ;]
0053               
0054               ;[ S" Compile time:( -- ) Immediate:( -- address length )
0055               ; When Compiling:
0056               ; compiles: (S")<length><string>
0057               ; e.g S" HELLO" compiles (S") 5 H E L L O
0058               ; At the end of string compilation, HERE is aligned to an even address.
0059               ; At run time, (S") (see below) pushes the address of the beginning of
0060               ; the string and the length to the stack.
0061               ;
0062               ; When Interpreting:
0063               ; Compiles the string to the address PAD, as above, and pushes the address and
0064               ; length to the stack.
0065 6E08 C020  42 _strin  mov @_state,r0              ; check state
     6E0A A04A     
0066 6E0C 160B  14         jne _stri1                  ; jump if compiling
0067               
0068                   ; not compiling, move string to PAD and adjust address
0069 6E0E C034  46         mov *stack+,r0              ; get pad address
0070 6E10 C180  30         mov r0,r6                   ; copy it
0071 6E12 C094  38         mov *stack,r2               ; get length
0072 6E14 C064  46         mov @2(stack),r1            ; get source address
     6E16 0002     
0073               
0074 6E18 DC31  58 strc1   movb *r1+,*r0+              ; copy to pad
0075 6E1A 0602  22         dec r2
0076 6E1C 16FD  14         jne strc1
0077 6E1E C906  46         mov r6,@2(stack)            ; put PAD address in place of original
     6E20 0002     
0078                                                   ; address
0079 6E22 10DA  14         jmp rndx
0080               
0081                   ; compiling. compile (S") <length_byte> <string>
0082 6E24 C034  46 _stri1  mov *stack+,r0              ; discard pad address on stack
0083 6E26 C020  42         mov @here,r0                ; compilation address
     6E28 A048     
0084 6E2A 0201  24         li r1,str                   ; CFA of (S")
     6E2C 790E     
0085 6E2E CC01  46         mov r1,*r0+                 ; compile (S")
0086 6E30 C0B4  46         mov *stack+,r2              ; get length
0087 6E32 06C2  22         swpb r2                     ; move to high byte
0088 6E34 DC02  44         movb r2,*r0+                ; compile length byte
0089               
0090 6E36 06C2  22         swpb r2                     ; restore length
0091 6E38 C074  46         mov *stack+,r1              ; address of string in cpu memory
0092 6E3A DC31  58 _stri2  movb *r1+,*r0+              ; copy string to definition
0093 6E3C 0602  22         dec r2                      ; finished?
0094 6E3E 16FD  14         jne _stri2
0095 6E40 0580  22         inc r0                      ; round up HERE
0096 6E42 0240  30         andi r0,>fffe               ; mask off LSB
     6E44 FFFE     
0097 6E46 C800  42         mov r0,@here                ; store it
     6E48 A048     
0098 6E4A 1085  14         jmp mpadj                   ; adjust memory pointers and exit via mpadj
0099               ;]
0100               
0101               ;[ (S") ( -- cpu_addr len )
0102               ; pushes the address and length of the string (compiled by S") onto the stack
0103               ; On entry, PC is actually pointing at the length byte. The address of the
0104               ; string is actually the address of the length byte+1. The length is just the
0105               ; value of the length byte. PC is adjusted to resume execution at the first even
0106               ; cell following the string.
0107 6E4C D033  44 _str    movb *pc+,r0                ; get length
0108 6E4E 0644  22         dect stack                  ; make space on stack
0109 6E50 C503  38         mov pc,*stack               ; move address of string to stack
0110 6E52 0644  22         dect stack                  ; make space on stack
0111 6E54 0980  48         srl r0,8                    ; place length in low byte
0112 6E56 C500  38         mov r0,*stack               ; place length on stack
0113 6E58 A0C0  30         a r0,pc                     ; advance program counter
0114 6E5A 0223  30         ai pc,1                     ; round up PC...
     6E5C 0001     
0115 6E5E 0243  30         andi pc,>fffe               ; ...to an even value
     6E60 FFFE     
0116 6E62 0460  24         b @retB0
     6E64 833A     
0117               ;]
0118               
0119               ;[ NUMBER TO STRING ( num -- addr len )
0120               ; Takes a number off the stack and converts it to a signed string equivalent,
0121               ; with respect to the current number base. Number base may be between
0122               ; 2 and 36. The routine checks location DOSIGN, and if 0, the
0123               ; number is treated as signed, else its unsigned. The routine also checks
0124               ; location LZI, and, if zero, leading zero's will be supressed.
0125               ; This is quite a bitch of a routine. Since any number base (between 2 and 36)
0126               ; can be employed this routine is rather complex. The routine must first
0127               ; determine the appropriate powers of the number base so we can divide the
0128               ; target number later. Obviously this is expensive, so the routine remembers
0129               ; what the active number base was the last time it was called, and ONLY
0130               ; re-computes the exponents if the base has changed since the last time it was
0131               ; called.
0132               ; This first part computes the column values.
0133               ; So, if the base is 10, you end up with 1,10,100,1000,10000
0134 6E66 C385  30 _nts    mov rstack,r14              ; save rstack 'cos we're using it
0135 6E68 C254  38         mov *stack,r9               ; get number off stack
0136 6E6A 0207  24         li r7,2                     ; exponent counter (base^0 and base^1 are
     6E6C 0002     
0137                                                   ; easy to compute ;-)
0138                                                   ; used as a word offset into workbuffer so
0139                                                   ; counts in multiples of 2.
0140 6E6E 8820  50         c @base,@lbase              ; check if base has chaged since the last
     6E70 A05E     
     6E72 A060     
0141                                                   ; time we were called
0142 6E74 1314  14         jeq dodiv                   ; base hasn't changed, no need to compute
0143                                                   ; powers of the base.
0144 6E76 C820  54         mov @base,@lbase            ; base has changed, store it in 'last base'
     6E78 A05E     
     6E7A A060     
0145 6E7C 0200  24         li r0,1                     ; base^0 is always 1 - easy ;-)
     6E7E 0001     
0146 6E80 0201  24         li r1,wrkbuf                ; place to store the powers of our base
     6E82 A224     
0147                   ; determine base^x until result > 65535
0148 6E84 CC40  46         mov r0,*r1+                 ; store base^0 and move forward in buffer
0149 6E86 C460  50         mov @base,*r1               ; base^1 is always base ;-) store it
     6E88 A05E     
0150 6E8A C171  46 pwr     mov *r1+,r5                 ; get previous exponent
0151 6E8C 3960  86         mpy @base,r5                ; multiply it by base - lower 16 bit result
     6E8E A05E     
0152                                                   ; in r6
0153 6E90 C145  30         mov r5,r5                   ; see if the result overflowed into upper
0154                                                   ; 16 bits
0155 6E92 1603  14         jne pwrout                  ; there was an overflow, exit loop
0156 6E94 C446  38         mov r6,*r1                  ; otherwise store result
0157 6E96 05C7  22         inct r7                     ; and increment exponent counter
0158 6E98 10F8  14         jmp pwr                     ; and repeat
0159                   ; Ok we have computed the 'column values' (powers) for our base. Now we
0160                   ; sucessively divide the number down until nothing is left, building
0161                   ; the string equivalent as we compute each digit. Just to make life
0162                   ; harder for ourselves, we will optionally allow leading zero's to be
0163                   ; supressed. If the word at LZI<>0 then leading zero's are suppressed.
0164 6E9A C807  42 pwrout  mov r7,@expcnt              ; save exponent count for next time routine
     6E9C A062     
0165                                                   ; is run
0166 6E9E C1E0  42 dodiv   mov @expcnt,r7              ; entry point when exponents arent computed.
     6EA0 A062     
0167                                                   ; restore exponent count
0168 6EA2 0200  24         li r0,strbuf                ; address of string buffer where we build
     6EA4 A244     
0169                                                   ; the string
0170 6EA6 04C1  22         clr r1                      ; buffer length counter
0171 6EA8 C220  42         mov @dosign,r8              ; check if producing an unsigned number
     6EAA A066     
0172 6EAC 1609  14         jne ninn                    ; skip if we are
0173 6EAE C209  30         mov r9,r8                   ; else, check if number is negative and if
0174                                                   ; so, add "-" character
0175 6EB0 0248  30         andi r8,>8000               ; is it negative
     6EB2 8000     
0176 6EB4 1305  14         jeq ninn                    ; its not negative, jump
0177 6EB6 0208  24         li r8,'-'*256               ; the number is negative, add a minus sign
     6EB8 2D00     
0178                                                   ; to the string buffer
0179 6EBA DC08  44         movb r8,*r0+                ; place it in the buffer
0180 6EBC 0581  22         inc r1                      ; increment length counter
0181 6EBE 0509  22         neg r9                      ; change the number to positive
0182 6EC0 04C8  22 ninn    clr r8                      ; div instruction uses 32 bit dividend, our
0183                                                   ; 16 bit argument is in r9
0184 6EC2 C2A0  42         mov @lzi,r10                ; leading zero indicator 0=suppress
     6EC4 A064     
0185 6EC6 3E27 164 nxtdig  div @wrkbuf(r7),r8          ; divide our number by exponent value.
     6EC8 A224     
0186                                                   ; result=r8, remainder=r9
0187 6ECA C208  30         mov r8,r8                   ; was the result 0?
0188 6ECC 1312  14         jeq testlz                  ; if yes then check if ignoring leading
0189                                                   ; zeros
0190 6ECE 070A  22         seto r10                    ; not zero, so reset leading zero indicator
0191 6ED0 DC28  60 dodig   movb @tlut(r8),*r0+         ; lookup digit value, move it to string
     6ED2 6EF8     
0192                                                   ; buffer and advance buffer address
0193 6ED4 04C8  22         clr r8                      ; clear result for next interation
0194 6ED6 0581  22         inc r1                      ; increment length counter
0195 6ED8 0647  22 iglz    dect r7                     ; done all our columns/exponents?
0196 6EDA 16F5  14         jne nxtdig                  ; loop if not
0197 6EDC DC29  60         movb @tlut(r9),*r0+         ; lookup digit value, move it to string
     6EDE 6EF8     
0198                                                   ; buffer and advance buffer address
0199                   ; we've done our division, push address & length to the stack and exit
0200 6EE0 0200  24         li r0,strbuf                ; address of string buffer
     6EE2 A244     
0201 6EE4 C500  38         mov r0,*stack               ; move address to stack
0202 6EE6 0644  22         dect stack                  ; new stack entry
0203 6EE8 0581  22         inc r1                      ; adjust length for remainder
0204 6EEA C501  38         mov r1,*stack               ; move length to stack
0205 6EEC C14E  30         mov r14,rstack              ; restore return stack pointer
0206 6EEE 0460  24         b @retB0
     6EF0 833A     
0207                   ; we're looking for leading zero's and ignoring them
0208 6EF2 C28A  30 testlz  mov r10,r10                 ; are we ignoring leading zero's?
0209 6EF4 13F1  14         jeq iglz                    ; 0=ignore leading digit
0210 6EF6 10EC  14         jmp dodig                   ; else do digit normally
0211                   ; character lookup table for printing numbers between bases 2 to 36
0212 6EF8 3031     tlut    text '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
     6EFA 3233     
     6EFC 3435     
     6EFE 3637     
     6F00 3839     
     6F02 4142     
     6F04 4344     
     6F06 4546     
     6F08 4748     
     6F0A 494A     
     6F0C 4B4C     
     6F0E 4D4E     
     6F10 4F50     
     6F12 5152     
     6F14 5354     
     6F16 5556     
     6F18 5758     
     6F1A 595A     
0213               ;]
                   < build.asm
0048                   copy "./bank1/1-11-Editor.asm"
     **** ****     > ./bank1/1-11-Editor.asm
0001               
0002               ;  ______     _ _ _               __          __            _
0003               ; |  ____|   | (_) |              \ \        / /           | |
0004               ; | |__    __| |_| |_  ___  _ __   \ \  /\  / /___  _ __ __| |___
0005               ; |  __|  / _` | | __|/ _ \| '__|   \ \/  \/ // _ \| '__/ _` / __|
0006               ; | |____| (_| | | |_| (_) | |       \  /\  /| (_) | | | (_| \__ \
0007               ; |______|\__,_|_|\__|\___/|_|        \/  \/  \___/|_|  \__,_|___/
0008               ; block editor
0009               
0010      FF83     keyCC   equ -125                    ; key code for ctrl c (copy line)
0011      FF96     keyCV   equ -106                    ; key code for ctrl v (paste line)
0012      FF89     keyCI   equ -119                    ; key code for ctrl i (insert line)
0013      FF84     keyCD   equ -124                    ; key code for ctrl d (delete line)
0014      FF8F     keyCO   equ -113                    ; key code for ctrl o (previous block)
0015      FF90     keyCP   equ -112                    ; key code for ctrl p (next block)
0016      000F     keyF9   equ 15                      ; key code for function 9 (back)
0017               
0018      0001     keyF7   equ 1                       ; key code for function 7 (tab)
0019      0002     keyF4   equ 2                       ; key code for function 4 (escape)
0020      0007     keyF3   equ 7                       ; key code for function 3 (erase line)
0021      0004     keyF2   equ 4                       ; key code for function 2 (insert/overwrite)
0022      0003     keyF1   equ 3                       ; key code for function 1 (del)
0023      000B     keyFE   equ 11                      ; cursor up keycode
0024      0008     keyFS   equ 8                       ; cursor left keycode
0025      0009     keyFD   equ 9                       ; cursor right keycode
0026      000A     keyFX   equ 10                      ; cursor down keycode
0027      0005     keyFeq  equ 5                       ; keycode for function = (quit)
0028      000D     keyRET  equ 13                      ; keycode for ENTER key
0029               
0030      A02A     savkey  equ scrx                    ; borrow scrX memory location for saving
0031                                                   ; keypresses
0032               
0033 6F1C 04E0  34 _edit   clr @csrflg                 ; clear shared cursor flash flag
     6F1E A082     
0034                                                   ; (shared with forcnt)
0035 6F20 04E0  34         clr @temp2                  ; next block to load
     6F22 A074     
0036 6F24 C014  38         mov *stack,r0               ; get address from BLOCK
0037 6F26 C1C0  30         mov r0,r7                   ; copy it
0038 6F28 1603  14         jne _edit1                  ; if not zero then continue
0039               
0040 6F2A 05C4  22         inct stack                  ; else BLOCK failed to load block.
0041 6F2C 0460  24         b @retB0                    ; Remove vdp address from stack and exit
     6F2E 833A     
0042               
0043                   ; determine if block is dirty or clean:
0044                   ; display * next to block number if dirty otherwise display a space
0045 6F30 1504  14 _edit1  jgt _edit4                  ; jump if dirty bit not set
0046 6F32 0206  24         li r6,_edit4                ; load return address
     6F34 6F3A     
0047 6F36 06A0  36         bl @disupd                  ; write CHANGED to screen
     6F38 768A     
0048               
0049 6F3A 0247  30 _edit4  andi r7,>7fff               ; remove dirty bit if set
     6F3C 7FFF     
0050 6F3E C507  38         mov r7,*stack               ; write it back, we'll use it further on...
0051 6F40 06A0  36         bl @csrdef                  ; define cursor udg
     6F42 7660     
0052 6F44 04E0  34         clr @epage                  ; set page to first page
     6F46 A07C     
0053 6F48 04E0  34         clr @temp                   ; initialise insert/overwrite mode
     6F4A A072     
0054 6F4C 06A0  36         bl @draws                   ; draw static parts of the display
     6F4E 7476     
0055 6F50 06A0  36         bl @drawd                   ; draw dynamic parts of the display
     6F52 7424     
0056 6F54 06A0  36         bl @insovr                  ; display mode
     6F56 73AE     
0057 6F58 04E0  34         clr @csrx                   ; used for cursor x
     6F5A A07E     
0058 6F5C 04E0  34         clr @csry                   ; used for cursor y
     6F5E A080     
0059 6F60 04E0  34         clr @cursrd                 ; reset cursor delay
     6F62 A026     
0060               
0061 6F64 06A0  36         bl @delay                   ; small delay to give the user time to
     6F66 7658     
0062 6F68 7530             data 30000                  ; release the enter key!
0063               
0064               ; editor main loop
0065               ; keyboard scanning and auto-repeat
0066 6F6A 06A0  36 edml2   bl @scnkey                  ; get key in r7
     6F6C 762C     
0067 6F6E C807  42 edml4   mov r7,@savkey              ; save the keypress
     6F70 A02A     
0068 6F72 0287  26         ci r7,>ffff                 ; nothing pressed?
     6F74 FFFF     
0069 6F76 1316  14         jeq docfl                   ; if nothing pressed then do cursor flash
0070 6F78 020D  24         li r13,edml3                ; set something pressed - set return point
     6F7A 6F7E     
0071                                                   ; for post keypress processing
0072 6F7C 1021  14         jmp chkent                  ; process the key press
0073 6F7E C020  42 edml3   mov @kdel,r0                ; get keyboard repeat delay from kdel
     6F80 A00A     
0074 6F82 0980  48         srl r0,8                    ; upper byte to lower byte
0075 6F84 0A10  34         sla r0,1                    ; move right one. multiplied by 2
0076 6F86 06A0  36 edml5   bl @scnkey                  ; scan again
     6F88 762C     
0077 6F8A 8807  38         c r7,@savkey                ; same key as last time?
     6F8C A02A     
0078 6F8E 1301  14         jeq edml6                   ; if yes then decrement delay
0079 6F90 10EE  14         jmp edml4                   ; different key - go process it
0080 6F92 0600  22 edml6   dec r0                      ; decrement counter
0081 6F94 16F8  14         jne edml5                   ; check again
0082 6F96 020D  24         li r13,edml7                ; counter expired. set return point
     6F98 6F9C     
0083 6F9A 1012  14         jmp chkent                  ; go process key
0084 6F9C D020  42 edml7   movb @kdel+1,r0             ; get short delay from kdel low-byte
     6F9E A00B     
0085 6FA0 0980  48         srl r0,8                    ; to low byte
0086 6FA2 10F1  14         jmp edml5                   ; repeat
0087               
0088               
0089               
0090               ; do cursorflash
0091 6FA4 0200  24 docfl   li r0,>0100
     6FA6 0100     
0092 6FA8 A800  42         a r0,@cursrd
     6FAA A026     
0093 6FAC 16DE  14         jne edml2                   ; time to flash cursor? loop if not
0094 6FAE 0560  34         inv @csrflg                 ; invert the cursor flag
     6FB0 A082     
0095 6FB2 1303  14         jeq oncsr                   ; if 0 do cursor on
0096 6FB4 06A0  36         bl @csroff                  ; else do cursor off
     6FB6 73E8     
0097 6FB8 10D8  14         jmp edml2
0098 6FBA 06A0  36 oncsr   bl @csron
     6FBC 73E2     
0099 6FBE 10D5  14         jmp edml2
0100               
0101               
0102               ; check for enter key
0103 6FC0 0287  26 chkent  ci r7,keyRET                ; return/enter pressed?
     6FC2 000D     
0104 6FC4 1610  14         jne keycor                  ; skip if not
0105 6FC6 04E0  34         clr @csrx                   ; move to left most column
     6FC8 A07E     
0106 6FCA 04E0  34         clr @epage                  ; move to left page
     6FCC A07C     
0107 6FCE 05A0  34         inc @csry                   ; move down a line
     6FD0 A080     
0108 6FD2 C020  42         mov @csry,r0                ; check y
     6FD4 A080     
0109 6FD6 0280  26         ci r0,16                    ; 16?
     6FD8 0010     
0110 6FDA 1602  14         jne keyen1                  ; skip if not
0111 6FDC 04E0  34         clr @csry                   ; clip to 15
     6FDE A080     
0112 6FE0 06A0  36 keyen1  bl @drawd                   ; render display
     6FE2 7424     
0113 6FE4 045D  24         b *r13                      ; continue
0114               
0115               
0116               ; check control keys
0117               ;    ; check CTRL O (previous block)
0118 6FE6 0287  26 keycor  ci r7,keyCO
     6FE8 FF8F     
0119 6FEA 160A  14         jne keycpr
0120 6FEC C820  54         mov @lstblk,@temp2
     6FEE A1B6     
     6FF0 A074     
0121 6FF2 0620  34         dec @temp2                  ; decrement block number to load
     6FF4 A074     
0122 6FF6 05C4  22 rt4th   inct stack                  ; remove BLOCK address from stack
0123 6FF8 020C  24         li r12,_next                ; restore pointer to NEXT
     6FFA 8326     
0124 6FFC 0460  24         b @retB0                    ; return to forth
     6FFE 833A     
0125               
0126               
0127               ;    ; check CTRL P (next block)
0128 7000 0287  26 keycpr  ci r7,keyCP
     7002 FF90     
0129 7004 1606  14         jne keycdr
0130 7006 C820  54         mov @lstblk,@temp2
     7008 A1B6     
     700A A074     
0131 700C 05A0  34         inc @temp2                  ; increment block number to load
     700E A074     
0132 7010 10F2  14         jmp rt4th                   ; return to forth
0133               
0134               
0135               ;    ; check CTRL D (delete line)
0136 7012 0287  26 keycdr  ci r7,keyCD                 ; ctrl d pressed?
     7014 FF84     
0137 7016 1628  14         jne keycir                  ; skip if not
0138 7018 06A0  36         bl @needud                  ; set this blocks' status to dirty
     701A 7674     
0139                   ; calculate end address of buffer
0140 701C C194  38         mov *stack,r6               ; vdp buffer address
0141 701E 0226  30         ai r6,1023                  ; point to last byte of buffer
     7020 03FF     
0142                   ; calculate start point
0143 7022 C020  42         mov @csry,r0                ; get current line
     7024 A080     
0144 7026 0580  22         inc r0                      ; move down a line
0145 7028 0A60  44         sla r0,6                    ; multiply by buffer line length
0146 702A A014  38         a *stack,r0                 ; add vdp buffer start address
0147 702C 0202  24 keycd1  li r2,64                    ; read a line...
     702E 0040     
0148 7030 C060  42         mov @here,r1                ; ...into scroll buffer
     7032 A048     
0149 7034 06A0  36         bl @_vmbr                   ; read the line
     7036 7838     
0150 7038 0220  30         ai r0,-64                   ; move up one line
     703A FFC0     
0151 703C C060  42         mov @here,r1                ; source
     703E A048     
0152 7040 0202  24         li r2,64                    ; count
     7042 0040     
0153 7044 06A0  36         bl @_vmbw0                  ; write the line
     7046 7886     
0154 7048 0220  30         ai r0,128                   ; move down 2 lines
     704A 0080     
0155 704C 8180  26         c r0,r6                     ; done all?
0156 704E 11EE  14         jlt keycd1                  ; loop if not
0157                   ; blank the last line... r6 points to last byte, so...
0158 7050 C006  30         mov r6,r0                   ; place in r0 for VDP
0159 7052 0220  30         ai r0,-63                   ; move to start of last line in buffer
     7054 FFC1     
0160 7056 0201  24         li r1,>2000                 ; space character
     7058 2000     
0161 705A 0202  24         li r2,64                    ; line length
     705C 0040     
0162 705E 06A0  36         bl @vsbwmi                  ; write spaces
     7060 78B2     
0163 7062 06A0  36         bl @rsrc                    ; render source
     7064 754A     
0164 7066 045D  24         b *r13                      ; continue
0165               
0166               
0167               ;    ; check CTRL I (insert line)
0168 7068 0287  26 keycir  ci r7,keyCI                 ; ctrl i pressed?
     706A FF89     
0169 706C 1628  14         jne keyccr                  ; skip if not
0170 706E 06A0  36         bl @needud                  ; set this blocks' status to dirty
     7070 7674     
0171                   ; get current line address
0172 7072 C1A0  42         mov @csry,r6                ; current y
     7074 A080     
0173 7076 0286  26         ci r6,15                    ; on the last line?
     7078 000F     
0174 707A 1317  14         jeq keyci2                  ; if so, just erase last line
0175 707C 0A66  44         sla r6,6                    ; multiply by line length
0176 707E A194  38         a *stack,r6                 ; add vdp buffer address
0177                   ; find last line of buffer
0178 7080 C014  38         mov *stack,r0               ; buffer start address
0179 7082 0220  30         ai r0,14*64                 ; move to last line but 1 (15th line)
     7084 0380     
0180 7086 C060  42 keyci1  mov @here,r1                ; buffer address
     7088 A048     
0181 708A 0202  24         li r2,64                    ; count
     708C 0040     
0182 708E 06A0  36         bl @_vmbr                   ; read into buffer
     7090 7838     
0183 7092 0220  30         ai r0,64                    ; move down a line
     7094 0040     
0184 7096 C060  42         mov @here,r1                ; buffer address
     7098 A048     
0185 709A 0202  24         li r2,64                    ; count
     709C 0040     
0186 709E 06A0  36         bl @_vmbw0                  ; write the line
     70A0 7886     
0187 70A2 0220  30         ai r0,-128                  ; move up 2 lines
     70A4 FF80     
0188 70A6 8180  26         c r0,r6                     ; finished?
0189 70A8 14EE  14         jhe keyci1                  ; repeat if not
0190                   ; erase current line, address is in r6
0191 70AA C006  30 keyci2  mov r6,r0                   ; for vdp
0192 70AC 0201  24         li r1,>2000                 ; space
     70AE 2000     
0193 70B0 0202  24         li r2,64                    ; count
     70B2 0040     
0194 70B4 06A0  36         bl @vsbwmi                  ; write 64 spaces
     70B6 78B2     
0195 70B8 06A0  36         bl @rsrc                    ; render source window
     70BA 754A     
0196 70BC 045D  24         b *r13                      ; continue
0197               
0198               
0199               ;    ; check CTRL C (copy)
0200 70BE 0287  26 keyccr  ci r7,keyCC                 ; ctrl C pressed?
     70C0 FF83     
0201 70C2 160E  14         jne keyCVr                  ; skip if not
0202 70C4 0200  24         li r0,64                    ; buffer pitch
     70C6 0040     
0203 70C8 C060  42         mov @csry,r1                ; get cursor y
     70CA A080     
0204 70CC 3840  74         mpy r0,r1                   ; multiply them (result in r2)
0205 70CE A094  38         a *stack,r2                 ; add vdp buffer address
0206 70D0 C002  30         mov r2,r0                   ; move to r0 for vdp actions
0207 70D2 0201  24         li r1,tib                   ; destination
     70D4 3420     
0208 70D6 0202  24         li r2,64                    ; number of bytes to read
     70D8 0040     
0209 70DA 06A0  36         bl @_vmbr                   ; read them into scroll buffer
     70DC 7838     
0210 70DE 045D  24         b *r13                      ; continue
0211               
0212               
0213               ;    ; check CTRL V (paste)
0214 70E0 0287  26 keyCVr  ci r7,keyCV                 ; ctrl V pressed?
     70E2 FF96     
0215 70E4 1615  14         jne keyf1r                  ; skip if not
0216 70E6 C020  42         mov @tib,r0                 ; check buffer contents
     70E8 3420     
0217 70EA 1311  14         jeq nopast                  ; if 0, nothing to paste
0218 70EC 0200  24         li r0,64                    ; buffer pitch
     70EE 0040     
0219 70F0 C060  42         mov @csry,r1                ; get cursor y
     70F2 A080     
0220 70F4 3840  74         mpy r0,r1                   ; multiply them (result in r2)
0221 70F6 A094  38         a *stack,r2                 ; add vdp buffer address
0222 70F8 C002  30         mov r2,r0                   ; move to r0 for vdp actions
0223 70FA 0201  24         li r1,tib                   ; source
     70FC 3420     
0224 70FE 0202  24         li r2,64                    ; number of bytes to write
     7100 0040     
0225 7102 06A0  36         bl @_vmbw0                  ; write them into source buffer
     7104 7886     
0226 7106 06A0  36         bl @rsrc                    ; render window
     7108 754A     
0227 710A 06A0  36         bl @needud                  ; mark block for update
     710C 7674     
0228 710E 045D  24 nopast  b *r13                      ; continue
0229               
0230               
0231               ; check function keys
0232               ;    ; check f1 (del)
0233 7110 0287  26 keyf1r  ci r7,keyF1                 ; f1 pressed?
     7112 0003     
0234 7114 162F  14         jne keyf9r                  ; skip if not
0235 7116 06A0  36         bl @needud                  ; set this blocks' status to dirty
     7118 7674     
0236                   ; calculate endpoint
0237 711A C060  42         mov @csry,r1                ; get y
     711C A080     
0238 711E 0581  22         inc r1                      ; move down one line
0239 7120 0A61  44         sla r1,6                    ; multiply by buffer line length (64)
0240 7122 0601  22         dec r1                      ; point to last char on current line
0241 7124 A054  38         a *stack,r1                 ; add in vdp buffer address
0242 7126 C181  30         mov r1,r6                   ; save it
0243                   ; calculate start point
0244 7128 C0A0  42         mov @csry,r2                ; get y
     712A A080     
0245 712C 0A62  44         sla r2,6                    ; multiply by buffer line length (64)
0246 712E A0A0  42         a @csrx,r2                  ; add x
     7130 A07E     
0247 7132 A094  38         a *stack,r2                 ; add in vdp address
0248 7134 C020  42         mov @epage,r0               ; check page
     7136 A07C     
0249 7138 1302  14         jeq keyf1s                  ; skip if 0
0250 713A 0222  30         ai r2,30                    ; account for page offset
     713C 001E     
0251 713E C002  30 keyf1s  mov r2,r0                   ; set start point for vdp read
0252 7140 6042  30         s r2,r1                     ; calculate length
0253 7142 C081  30         mov r1,r2                   ; put in r2 for vmbr
0254 7144 0582  22         inc r2
0255 7146 C200  30         mov r0,r8                   ; save buffer address
0256 7148 C242  30         mov r2,r9                   ; save length
0257                   ; read from source buffer
0258 714A C060  42         mov @here,r1                ; cpu buffer
     714C A048     
0259 714E 06A0  36         bl @_vmbr                   ; read into buffer
     7150 7838     
0260 7152 C008  30         mov r8,r0                   ; restore addresds
0261 7154 C089  30         mov r9,r2                   ; restore count
0262 7156 0602  22         dec r2                      ; reduce by 1
0263 7158 1305  14         jeq f1eol                   ; if on last column then skip
0264 715A C060  42         mov @here,r1                ; move forward...
     715C A048     
0265 715E 0581  22         inc r1                      ; ...1 char in the buffer
0266 7160 06A0  36         bl @_vmbw0                  ; write it
     7162 7886     
0267 7164 C006  30 f1eol   mov r6,r0                   ; end of line address
0268 7166 0201  24         li r1,>2000                 ; write a space character to end of line
     7168 2000     
0269 716A 06A0  36         bl @_vsbw0
     716C 785E     
0270 716E 06A0  36         bl @rsrc                    ; render source to window
     7170 754A     
0271 7172 045D  24         b *r13                      ; continue
0272               
0273               
0274               ;    ; check f9 (back)
0275 7174 0287  26 keyf9r  ci r7,keyF9
     7176 000F     
0276 7178 1604  14         jne keyf3r
0277 717A 04E0  34         clr @tib                    ; clr length byte in TIB to stop Forth from
     717C 3420     
0278                                                   ; trying to process the copy/paste buffer as
0279                                                   ; input!
0280 717E 0460  28 ret4th  b @rt4th                    ; return to forth
     7180 6FF6     
0281               
0282               
0283               ;    ; check f3 (erase line)
0284 7182 0287  26 keyf3r  ci r7,keyF3
     7184 0007     
0285 7186 1616  14         jne keyf7r
0286 7188 0200  24         li r0,64                    ; buffer pitch
     718A 0040     
0287 718C C060  42         mov @csry,r1                ; get cursor y
     718E A080     
0288 7190 3840  74         mpy r0,r1                   ; multiply them (result in r2)
0289 7192 A094  38         a *stack,r2                 ; add vdp buffer address
0290 7194 C002  30         mov r2,r0                   ; move to r0 for vdp actions
0291 7196 0201  24         li r1,>2000                 ; space character
     7198 2000     
0292 719A 0202  24         li r2,64                    ; 64 bytes to erase
     719C 0040     
0293 719E 06A0  36         bl @vsbwmi                  ; erase them
     71A0 78B2     
0294 71A2 04E0  34         clr @csrx                   ; move to leftmost column
     71A4 A07E     
0295 71A6 04E0  34         clr @epage                  ; left page
     71A8 A07C     
0296 71AA 06A0  36         bl @rsrc                    ; render source in window
     71AC 754A     
0297 71AE 06A0  36         bl @needud                  ; set block for update
     71B0 7674     
0298 71B2 045D  24         b *r13                      ; continue
0299               
0300               
0301               ;    ; check f7 key
0302 71B4 0287  26 keyf7r  ci r7,keyF7                 ; F7 pressed?
     71B6 0001     
0303 71B8 160A  14         jne keyfqr                  ; skip if not
0304 71BA 06A0  36         bl @is80c                   ; 80 column mode?
     71BC 769C     
0305 71BE 1306  14         jeq f7exit                  ; dump the keypress if yes - f7 key not used
0306                                                   ; in 80 column mode
0307 71C0 06A0  36         bl @csroff                  ; restore character under cursor
     71C2 73E8     
0308 71C4 0560  34         inv @epage                  ; switch page
     71C6 A07C     
0309 71C8 06A0  36         bl @drawd                   ; re-draw screen
     71CA 7424     
0310 71CC 045D  24 f7exit  b *r13
0311               
0312               
0313               ;    ; check quit key
0314 71CE 0287  26 keyfqr  ci r7,keyFeq                ; quit pressed?
     71D0 0005     
0315 71D2 160D  14         jne keyf2r                  ; skip if not
0316 71D4 C020  42 edF4    mov @lstblk,r0              ; get current block
     71D6 A1B6     
0317 71D8 06A0  36         bl @scnblk                  ; locate it (blk address in r0)
     71DA 6A02     
0318 71DC 04D1  30         clr *r1                     ; un-assign this buffer
0319 71DE 05C1  22         inct r1                     ; point to VDP address pointer
0320 71E0 C011  38         mov *r1,r0                  ; get the VDP address
0321 71E2 0240  30         andi r0,>7fff               ; reset dirty bit
     71E4 7FFF     
0322 71E6 C440  38         mov r0,*r1                  ; write it back
0323 71E8 04E0  34         clr @tib                    ; clr length byte in TIB to stop Forth from
     71EA 3420     
0324                                                   ; trying to process the copy/paste buffer as
0325                                                   ; input!
0326 71EC 10C8  14         jmp ret4th                  ; return to Forth
0327               
0328               
0329               ;    ; check f2 key
0330 71EE 0287  26 keyf2r  ci r7,keyF2                 ; F2 pressed?
     71F0 0004     
0331 71F2 1603  14         jne keyd                    ; skip if not
0332 71F4 06A0  36         bl @insovr
     71F6 73AE     
0333 71F8 045D  24         b *r13
0334               
0335               
0336               ;    ; check for fctn + d
0337 71FA 0287  26 keyd    ci r7,keyFD                 ; fctn & d?
     71FC 0009     
0338 71FE 1621  14         jne keys                    ; skip if not
0339 7200 06A0  36         bl @csroff                  ; restore character currently under cursor
     7202 73E8     
0340 7204 06A0  36         bl @is80c
     7206 769C     
0341 7208 1605  14         jne keyd1
0342 720A C020  42         mov @csrx,r0
     720C A07E     
0343 720E 0280  26         ci r0,63
     7210 003F     
0344 7212 1004  14         jmp keyd2
0345 7214 C020  42 keyd1   mov @csrx,r0                ; get cursor x
     7216 A07E     
0346 7218 0280  26         ci r0,33                    ; check limit
     721A 0021     
0347 721C 1306  14 keyd2   jeq clipxh                  ; clip if on limit
0348 721E 0580  22         inc r0                      ; otherwise increment
0349 7220 C800  42         mov r0,@csrx                ; write it back
     7222 A07E     
0350 7224 06A0  36         bl @csron                   ; set cursor to on state
     7226 73E2     
0351 7228 045D  24         b *r13
0352 722A 04E0  34 clipxh  clr @csrx                   ; clip cursor
     722C A07E     
0353 722E 06A0  36 clipxg  bl @is80c                   ; 80 column?
     7230 769C     
0354 7232 1306  14         jeq keydx
0355 7234 0560  34         inv @epage                  ; change page
     7236 A07C     
0356 7238 06A0  36         bl @drawd                   ; draw window contents
     723A 7424     
0357 723C 06A0  36         bl @csron                   ; set cursor to on state
     723E 73E2     
0358 7240 045D  24 keydx   b *r13
0359               
0360               
0361               ;    ; check for fctn + s
0362 7242 0287  26 keys    ci r7,keyFS                 ; fctn & s
     7244 0008     
0363 7246 1618  14         jne keye                    ; skip if not
0364 7248 06A0  36         bl @csroff                  ; restore character currently under cursor
     724A 73E8     
0365 724C C020  42         mov @csrx,r0                ; get cursor x
     724E A07E     
0366 7250 1306  14         jeq clipxl                  ; clip if on limit
0367 7252 0600  22         dec r0                      ; otherwise decrement
0368 7254 C800  42         mov r0,@csrx                ; write it back
     7256 A07E     
0369 7258 06A0  36         bl @csron                   ; set cursor on
     725A 73E2     
0370 725C 045D  24         b *r13
0371 725E 06A0  36 clipxl  bl @is80c                   ; 80 column?
     7260 769C     
0372 7262 1305  14         jeq clipx2
0373 7264 0200  24         li r0,33                    ; set cursor to the other end
     7266 0021     
0374 7268 C800  42         mov r0,@csrx                ; write it
     726A A07E     
0375 726C 10E0  14         jmp clipxg                  ; change page and render
0376 726E 0200  24 clipx2  li r0,63                    ; set cursor to other end (80 col mode)
     7270 003F     
0377 7272 C800  42         mov r0,@csrx
     7274 A07E     
0378 7276 045D  24         b *r13
0379               
0380               
0381               ;    ; check for fctn + e
0382 7278 0287  26 keye    ci r7,keyFE                 ; fctn & e
     727A 000B     
0383 727C 1610  14         jne keyx                    ; skip if not
0384 727E 06A0  36         bl @csroff                  ; restore character currently under cursor
     7280 73E8     
0385 7282 C020  42         mov @csry,r0                ; get cursor y
     7284 A080     
0386 7286 0600  22         dec r0                      ; decrement
0387 7288 C800  42         mov r0,@csry                ; write it back
     728A A080     
0388 728C 1103  14         jlt clipyl                  ; clip if on limit
0389 728E 06A0  36 clipyg  bl @csron                   ; set cursor on
     7290 73E2     
0390 7292 045D  24         b *r13
0391 7294 0200  24 clipyl  li r0,15                    ; set cursor to the other end
     7296 000F     
0392 7298 C800  42         mov r0,@csry                ; write it
     729A A080     
0393 729C 10F8  14         jmp clipyg
0394               
0395               
0396               ;    ; check for fctn + x
0397 729E 0287  26 keyx    ci r7,keyFX                 ; fctn & x?
     72A0 000A     
0398 72A2 160F  14         jne genkey                  ; skip if not
0399 72A4 06A0  36         bl @csroff                  ; restore character currently under cursor
     72A6 73E8     
0400 72A8 C020  42         mov @csry,r0                ; get cursor y
     72AA A080     
0401 72AC 0580  22         inc r0                      ; increment it
0402 72AE C800  42         mov r0,@csry                ; write it back
     72B0 A080     
0403 72B2 0280  26         ci r0,16                    ; compare to limit
     72B4 0010     
0404 72B6 1301  14         jeq clipyh                  ; clip if on limit
0405 72B8 10EA  14         jmp clipyg
0406 72BA 04C0  22 clipyh  clr r0                      ; set cursor to the other end
0407 72BC C800  42         mov r0,@csry                ; write it
     72BE A080     
0408 72C0 10E6  14         jmp clipyg
0409               
0410               
0411               ; process general keypress
0412 72C2 06A0  36 genkey  bl @needud                  ; mark the block for update
     72C4 7674     
0413 72C6 06A0  36         bl @doins                   ; do insert if insert mode is selected
     72C8 7358     
0414 72CA 0200  24         li r0,64                    ; buffer pitch
     72CC 0040     
0415 72CE C060  42         mov @csry,r1                ; current y
     72D0 A080     
0416 72D2 3840  74         mpy r0,r1                   ; calculate buffer address
0417 72D4 A0A0  42         a @csrx,r2                  ; add x
     72D6 A07E     
0418 72D8 C020  42         mov @epage,r0               ; check page
     72DA A07C     
0419 72DC 1302  14         jeq gkno                    ; skip if on page 0
0420 72DE 0222  30         ai r2,30                    ; else account for page offset
     72E0 001E     
0421 72E2 C002  30 gkno    mov r2,r0                   ; move to r0 for vdp address
0422 72E4 A014  38         a *stack,r0                 ; add vdp buffer address
0423 72E6 C047  30         mov r7,r1                   ; get keypress
0424 72E8 06C1  22         swpb r1                     ; move to high byte
0425 72EA 06A0  36         bl @_vsbw0                  ; write it into vdp
     72EC 785E     
0426 72EE 06A0  36         bl @csroff                  ; display it
     72F0 73E8     
0427 72F2 C020  42         mov @csrx,r0                ; get x
     72F4 A07E     
0428 72F6 0580  22         inc r0                      ; move to the right
0429 72F8 C800  42         mov r0,@csrx                ; store it
     72FA A07E     
0430 72FC C060  42         mov @xmax,r1                ; get xmax
     72FE A02E     
0431 7300 0281  26         ci r1,80                    ; 80 column
     7302 0050     
0432 7304 1304  14         jeq chk80                   ; jump if in 80 column mode
0433 7306 0280  26         ci r0,34                    ; need to clip? (40 column mode check)
     7308 0022     
0434 730A 1625  14         jne upkey                   ; jump if not
0435 730C 100D  14         jmp gkeycx                  ; else do clip
0436 730E 0280  26 chk80   ci r0,64                    ; limit for 80 column mode
     7310 0040     
0437 7312 1621  14         jne upkey                   ; jump if clip not required
0438 7314 04E0  34         clr @csrx                   ; zero x
     7316 A07E     
0439 7318 C020  42         mov @csry,r0                ; get y
     731A A080     
0440 731C 0580  22         inc r0                      ; add 1
0441 731E 0240  30         andi r0,15                  ; clip to 16th line
     7320 000F     
0442 7322 C800  42         mov r0,@csry                ; store y again
     7324 A080     
0443 7326 1017  14         jmp upkey                   ; and continue
0444                       ; clip x and change page
0445 7328 04E0  34 gkeycx  clr @csrx                   ; zero x
     732A A07E     
0446 732C 0560  34         inv @epage                  ; change page
     732E A07C     
0447 7330 1304  14         jeq ncos                    ; no cursor offset required if page=0
0448 7332 0200  24         li r0,4                     ; cursor position
     7334 0004     
0449 7336 C800  42         mov r0,@csrx                ; set it
     7338 A07E     
0450 733A C020  42 ncos    mov @epage,r0               ; get page
     733C A07C     
0451 733E 1609  14         jne ncos1                   ; skip if page=1
0452 7340 05A0  34 incyc   inc @csry                   ; move down to next line
     7342 A080     
0453 7344 C020  42         mov @csry,r0                ; check y
     7346 A080     
0454 7348 0280  26         ci r0,16                    ; need to clip y
     734A 0010     
0455 734C 1602  14         jne ncos1                   ; skip if no need
0456 734E 0620  34         dec @csry                   ; else reset to 15th line
     7350 A080     
0457 7352 06A0  36 ncos1   bl @drawd                   ; draw window and rulers etc
     7354 7424     
0458 7356 045D  24 upkey   b *r13
0459               
0460               
0461               
0462               ; insert mode
0463               ; move everything *on the current line only* forward, from the cursor
0464 7358 C28B  30 doins   mov r11,r10
0465 735A C020  42         mov @temp,r0                ; check insert mode
     735C A072     
0466 735E 1626  14         jne doinsx                  ; if not 0 then exit
0467                   ; calculate endpoint address in vdp buffer...
0468 7360 C0A0  42         mov @csry,r2                ; get y
     7362 A080     
0469 7364 0582  22         inc r2                      ; move to next line
0470 7366 0A62  44         sla r2,6                    ; multiply by 64
0471 7368 0602  22         dec r2                      ; point to last byte on current line
0472 736A A094  38         a *stack,r2                 ; add in vdp buffer address
0473                   ; calculate startpoint address in vdp buffer...
0474 736C C020  42         mov @csry,r0                ; current line
     736E A080     
0475 7370 0A60  44         sla r0,6                    ; multiply by block line length (64)
0476 7372 A020  42         a @csrx,r0                  ; add x
     7374 A07E     
0477 7376 C060  42         mov @epage,r1               ; check page
     7378 A07C     
0478 737A 1302  14         jeq doins1                  ; skip if page=0
0479 737C 0220  30         ai r0,30                    ; else add offset
     737E 001E     
0480 7380 A014  38 doins1  a *stack,r0                 ; add in vdp buffer address
0481 7382 6080  30         s r0,r2                     ; calculate length
0482 7384 1313  14         jeq doinsx                  ; exit if 0
0483                   ; read buffer contents into temporary buffer and write them out again,
0484                   ; forward by 1 character...
0485 7386 C060  42         mov @here,r1                ; buffer to store the data in
     7388 A048     
0486 738A C240  30         mov r0,r9                   ; save address
0487 738C C202  30         mov r2,r8                   ; save length
0488 738E 06A0  36         bl @_vmbr                   ; read data into buffer
     7390 7838     
0489 7392 C009  30         mov r9,r0                   ; restore address
0490 7394 0580  22         inc r0                      ; move forward 1
0491 7396 C088  30         mov r8,r2                   ; restore length
0492 7398 C060  42         mov @here,r1                ; source for vdp write
     739A A048     
0493 739C 06A0  36         bl @_vmbw0                  ; write the characters
     739E 7886     
0494 73A0 C807  42         mov r7,@temp3               ; save keypress
     73A2 A076     
0495 73A4 06A0  36         bl @rsrc                    ; render source window
     73A6 754A     
0496 73A8 C1E0  42         mov @temp3,r7               ; restore keypress for handling by keypress
     73AA A076     
0497                                                   ; routine
0498 73AC 045A  24 doinsx  b *r10
0499               
0500               
0501               
0502               ; set insert/overwrite mode
0503 73AE C1CB  30 insovr  mov r11,r7                  ; save return address
0504 73B0 05A0  34         inc @temp                   ; advance to next mode
     73B2 A072     
0505 73B4 8820  50         c @temp,@modmax             ; compare to maximum allowed value
     73B6 A072     
     73B8 73E0     
0506 73BA 1602  14         jne ins1                    ; if <= to max then ok
0507 73BC 04E0  34         clr @temp                   ; else reset to 0
     73BE A072     
0508 73C0 06A0  36 ins1    bl @xya                     ; set screen address
     73C2 75EE     
0509 73C4 2200             data >2200
0510 73C6 C060  42         mov @temp,r1                ; get mode
     73C8 A072     
0511 73CA 1605  14         jne ovr                     ; set insert mode if 1
0512 73CC 06A0  36         bl @wstr                    ; else insert mode 0
     73CE 7620     
0513 73D0 7721             data instxt,6
     73D2 0006     
0514 73D4 0457  24         b *r7
0515 73D6 06A0  36 ovr     bl @wstr                    ; overwrite (1)
     73D8 7620     
0516 73DA 7727             data ovrtxt,6
     73DC 0006     
0517 73DE 0457  24         b *r7
0518 73E0 0002     modmax  data 2
0519               
0520               
0521               
0522               ; cursor blinking routines
0523                   ; display cursor character
0524 73E2 C18B  30 csron   mov r11,r6
0525 73E4 04C7  22         clr r7
0526 73E6 100F  14         jmp calcsr                  ; calculate cursor position and display r7
0527               
0528                   ; restore character under cursor
0529 73E8 C18B  30 csroff  mov r11,r6                  ; save return address
0530 73EA C020  42         mov @csry,r0                ; cursor y
     73EC A080     
0531 73EE 0A60  44         sla r0,6                    ; multiply by block line pitch (64)
0532 73F0 A020  42         a @csrx,r0                  ; add x
     73F2 A07E     
0533 73F4 A014  38         a *stack,r0                 ; add buffer address
0534 73F6 C060  42         mov @epage,r1               ; check page
     73F8 A07C     
0535 73FA 1302  14         jeq csr1                    ; skip if on page 0
0536 73FC 0220  30         ai r0,30                    ; else add page offset
     73FE 001E     
0537 7400 06A0  36 csr1    bl @_vsbr                   ; read byte from buffer
     7402 7816     
0538 7404 D1C1  30         movb r1,r7                  ; save character
0539 7406 C020  42 calcsr  mov @csry,r0                ; cursor y
     7408 A080     
0540 740A 0220  30         ai r0,3                     ; account for editor window
     740C 0003     
0541 740E 3820  86         mpy @xmax,r0                ; multiply by screen pitch (result in r1)
     7410 A02E     
0542 7412 C020  42         mov @csrx,r0                ; get x
     7414 A07E     
0543 7416 0220  30         ai r0,3                     ; account for editor window
     7418 0003     
0544 741A A001  30         a r1,r0                     ; sum to r0 for vdp address
0545 741C C047  30         mov r7,r1                   ; get the character we saved
0546 741E 06A0  36         bl @_vsbw0                  ; write it
     7420 785E     
0547 7422 0456  24         b *r6                       ; return to caller
0548               
0549               
0550               
0551               ; screen handling routines
0552               ; draw dynamic parts of the screen
0553 7424 C28B  30 drawd   mov r11,r10                 ; save return address
0554                   ; draw left vertical line
0555 7426 06A0  36         bl @lftlin
     7428 759C     
0556                   ; draw right vertical line
0557 742A 06A0  36         bl @rtlin
     742C 75BE     
0558                   ; draw top ruler
0559 742E 06A0  36         bl @is80c                   ; 80 column mode?
     7430 769C     
0560 7432 1310  14         jeq ru80c                   ; jump if yes
0561 7434 06A0  36         bl @xya
     7436 75EE     
0562 7438 0301             data >0301                  ; get screen address for x=3 y=1
0563 743A C060  42         mov @epage,r1
     743C A07C     
0564 743E 1605  14         jne trul1
0565 7440 06A0  36         bl @wstr                    ; write string
     7442 7620     
0566 7444 76A6             data txt0,31                ; source,length
     7446 001F     
0567 7448 1013  14         jmp ednext
0568 744A 06A0  36 trul1   bl @wstr                    ; write string
     744C 7620     
0569 744E 76C5             data txt1,31                ; source,length
     7450 001F     
0570 7452 100E  14         jmp ednext
0571                   ; render ruler (80 column mode)
0572 7454 06A0  36 ru80c   bl @xya
     7456 75EE     
0573 7458 0301             data >0301                  ; get screen address for x=3 y=1
0574 745A 06A0  36         bl @wstr                    ; write string
     745C 7620     
0575 745E 76A6             data txt0,30                ; source,length
     7460 001E     
0576 7462 06A0  36         bl @xya
     7464 75EE     
0577 7466 2101             data >2101                  ; get screen address for x=33 y=1
0578 7468 06A0  36         bl @wstr                    ; write string
     746A 7620     
0579 746C 76C5             data txt1,31                ; source,length
     746E 001F     
0580               
0581                   ; render block text into editor window
0582                   ; vdp address is on the stack
0583 7470 06A0  36 ednext  bl @rsrc                    ; render source into window
     7472 754A     
0584 7474 045A  24         b *r10                      ; return to caller
0585               
0586               
0587               ; draw static parts of the screen
0588 7476 C28B  30 draws   mov r11,r10                 ; save return address
0589                   ; write block text
0590 7478 06A0  36         bl @xya
     747A 75EE     
0591 747C 0000             data >0000
0592 747E 06A0  36         bl @wstr
     7480 7620     
0593 7482 7716             data blktxt,6
     7484 0006     
0594                   ; write mode text
0595 7486 06A0  36         bl @xya
     7488 75EE     
0596 748A 1D00             data >1d00
0597 748C 06A0  36         bl @wstr
     748E 7620     
0598 7490 771C             data modtxt,5
     7492 0005     
0599                   ; draw 2nd ruler line
0600 7494 06A0  36         bl @xya
     7496 75EE     
0601 7498 0302             data >0302                  ; get screen address for x=3 y=2
0602 749A 06A0  36         bl @wstr                    ; write string
     749C 7620     
0603 749E 76E4             data txt2,34                ; source,length
     74A0 0022     
0604 74A2 06A0  36         bl @is80c                   ; running 80 column?
     74A4 769C     
0605 74A6 1607  14         jne lhl                     ; jump if not
0606 74A8 06A0  36         bl @xya
     74AA 75EE     
0607 74AC 2502             data >2502                  ; x=37 y=2
0608 74AE 06A0  36         bl @wstr
     74B0 7620     
0609 74B2 76E8             data txt2+4,30
     74B4 001E     
0610                   ; draw lower horizontal line
0611 74B6 06A0  36 lhl     bl @is80c                   ; in 80 column mode?
     74B8 769C     
0612 74BA 1608  14         jne lhl1
0613 74BC 06A0  36         bl @xya
     74BE 75EE     
0614 74C0 0313             data >0313                  ; x=3 y=19
0615 74C2 06A0  36         bl @hline
     74C4 7614     
0616 74C6 0100             data 1*256,64
     74C8 0040     
0617 74CA 1007  14         jmp rownum
0618 74CC 06A0  36 lhl1    bl @xya
     74CE 75EE     
0619 74D0 0313             data >0313                  ; x=3 y=19
0620 74D2 06A0  36         bl @hline
     74D4 7614     
0621 74D6 0100             data 1*256,35
     74D8 0023     
0622               
0623                   ; place row numbers
0624 74DA 06A0  36 rownum  bl @xya
     74DC 75EE     
0625 74DE 0103             data >0103                  ; get screen address for x=1 y=3
0626 74E0 0202  24         li r2,16                    ; count
     74E2 0010     
0627 74E4 0206  24         li r6,rowtxt                ; source
     74E6 7706     
0628 74E8 D076  44 rl1     movb *r6+,r1                ; get source character
0629 74EA 06A0  36         bl @_vsbw0                  ; write a character
     74EC 785E     
0630 74EE 0581  22         inc r1                      ; next source character
0631 74F0 A020  42         a @xmax,r0                  ; move down a line
     74F2 A02E     
0632 74F4 0602  22         dec r2                      ; finished?
0633 74F6 16F8  14         jne rl1                     ; loop if not
0634 74F8 06A0  36         bl @xya
     74FA 75EE     
0635 74FC 000D             data >000d                  ; x=0 y=13
0636 74FE 06A0  36         bl @vline
     7500 7600     
0637 7502 3100             data '1'*256,6
     7504 0006     
0638               
0639                   ; place corner peices
0640 7506 0207  24         li r7,4                     ; count
     7508 0004     
0641 750A 0206  24         li r6,cnrdat                ; address of corner data
     750C 753A     
0642 750E 06A0  36         bl @is80c                   ; 80 column?
     7510 769C     
0643 7512 1602  14         jne corner                  ; jump if not
0644 7514 0226  30         ai r6,8                     ; else point to 80 column data
     7516 0008     
0645 7518 0201  24 corner  li r1,4*256                 ; ascii 4 in msb
     751A 0400     
0646 751C C036  46 crnlp   mov *r6+,r0                 ; get address
0647 751E 06A0  36         bl @_vsbw0                  ; write to screen
     7520 785E     
0648 7522 0221  30         ai r1,>0100                 ; increment ascii character
     7524 0100     
0649 7526 0607  22         dec r7                      ; decrement counter
0650 7528 16F9  14         jne crnlp                   ; loop if not finished
0651               
0652                   ; draw help text
0653 752A 06A0  36         bl @xya
     752C 75EE     
0654 752E 0014             data >0014
0655 7530 06A0  36         bl @wstr
     7532 7620     
0656 7534 7775             data help,4*40
     7536 00A0     
0657 7538 045A  24         b *r10                      ; return to caller
0658               
0659               ; location data for corner UDGs - 40 column mode
0660 753A 0052     cnrdat  data 2*40+2                 ; top left
0661 753C 0075             data 2*40+37                ; top right
0662 753E 02FA             data 19*40+2                ; bottom left
0663 7540 031D             data 19*40+37               ; bottom right
0664               
0665               ; location data for corner UDGs - 80 column mode
0666 7542 00A2             data 2*80+2                 ; top left
0667 7544 00E3             data 2*80+67                ; top right
0668 7546 05F2             data 19*80+2                ; bottom left
0669 7548 0633             data 19*80+67               ; bottom right
0670               
0671               
0672               ; render source subroutine
0673      0023     pitch   equ 35
0674 754A C38B  30 rsrc    mov r11,r14                 ; save return address
0675 754C 020F  24         li r15,pitch                ; load pitch for 40 column mode
     754E 0023     
0676 7550 06A0  36         bl @is80c
     7552 769C     
0677 7554 1602  14         jne rsrc_
0678 7556 020F  24         li r15,65                   ; load pitch for 80 column mode
     7558 0041     
0679 755A 06A0  36 rsrc_   bl @xya
     755C 75EE     
0680 755E 0303             data >0303                  ; screen address
0681 7560 C240  30         mov r0,r9                   ; save it
0682 7562 C194  38         mov *stack,r6               ; source vdp address
0683 7564 C220  42         mov @epage,r8               ; check page
     7566 A07C     
0684 7568 1302  14         jeq rsrc1
0685 756A 0226  30         ai r6,30                    ; calculate page offset
     756C 001E     
0686 756E 020C  24 rsrc1   li r12,16                   ; line count
     7570 0010     
0687 7572 C006  30 rloop   mov r6,r0                   ; source
0688 7574 C060  42         mov @here,r1                ; destination
     7576 A048     
0689 7578 C08F  30         mov r15,r2                  ; count
0690 757A 0602  22         dec r2
0691 757C 06A0  36         bl @_vmbr                   ; read a line
     757E 7838     
0692 7580 C009  30         mov r9,r0                   ; destination address
0693 7582 C060  42         mov @here,r1                ; source
     7584 A048     
0694 7586 C08F  30         mov r15,r2                  ; count
0695 7588 0602  22         dec r2
0696 758A 06A0  36         bl @_vmbw0                  ; write it
     758C 7886     
0697 758E A260  42         a @xmax,r9                  ; down a line
     7590 A02E     
0698 7592 0226  30         ai r6,64                    ; next line in source
     7594 0040     
0699 7596 060C  22         dec r12                     ; finished?
0700 7598 16EC  14         jne rloop                   ; loop if not
0701 759A 045E  24         b *r14                      ; return
0702               
0703               
0704               ; draw left hand vertical line (dependant on which page we're on)
0705 759C C1CB  30 lftlin  mov r11,r7                  ; save return addressd
0706 759E 06A0  36         bl @xya
     75A0 75EE     
0707 75A2 0203             data >0203                  ; get screen address for x=2 y=3
0708 75A4 C060  42         mov @epage,r1               ; get page
     75A6 A07C     
0709 75A8 1605  14         jne lft1                    ; do if page=1
0710 75AA 06A0  36         bl @vline
     75AC 7600     
0711 75AE 0300             data 3*256,16
     75B0 0010     
0712 75B2 0457  24         b *r7
0713 75B4 06A0  36 lft1    bl @vline
     75B6 7600     
0714 75B8 9C00             data >9c00,16
     75BA 0010     
0715 75BC 0457  24         b *r7
0716               
0717               
0718               ; draw right hand vertical line (dependant on which page we're on)
0719 75BE C1CB  30 rtlin   mov r11,r7                  ; save return address
0720 75C0 06A0  36         bl @is80c                   ; 80 column?
     75C2 769C     
0721 75C4 1310  14         jeq rt2
0722 75C6 06A0  36         bl @xya
     75C8 75EE     
0723 75CA 2503             data >2503                  ; get screen address for x=37 y=3
0724 75CC C060  42         mov @epage,r1               ; get page
     75CE A07C     
0725 75D0 1605  14         jne rt1                     ; do if page=1
0726 75D2 06A0  36         bl @vline
     75D4 7600     
0727 75D6 9E00             data >9e00,16
     75D8 0010     
0728 75DA 0457  24         b *r7                       ; return
0729 75DC 06A0  36 rt1     bl @vline
     75DE 7600     
0730 75E0 0300             data 3*256,16
     75E2 0010     
0731 75E4 0457  24         b *r7                       ; return
0732 75E6 06A0  36 rt2     bl @xya                     ; 80 column mode only: place vertical bar on
     75E8 75EE     
0733                                                   ; rhs of screen
0734 75EA 4303             data >4303
0735 75EC 10F7  14         jmp rt1
0736               
0737               
0738               ; calculate screen address from XY coordinates
0739 75EE C03B  46 xya     mov *r11+,r0                ; get xy
0740 75F0 C040  30         mov r0,r1                   ; copy
0741 75F2 0A81  48         sla r1,8                    ; get y (move x out)
0742 75F4 0881  40         sra r1,8                    ; adjust to correct position
0743 75F6 0880  40         sra r0,8                    ; get x (move y out)
0744 75F8 3860  86         mpy @xmax,r1                ; do y multiply (result in r2)
     75FA A02E     
0745 75FC A002  30         a r2,r0                     ; screen address in r0
     **** ****     > RT
0001 75FE 045B  24        b * r11
                   < 1-11-Editor.asm
0747               
0748               
0749               ; draw a vertical line subroutine
0750               ; r0=screen address
0751               ; character and length follow as DATA directives in caller code
0752 7600 C07B  46 vline   mov *r11+,r1
0753 7602 C0BB  46         mov *r11+,r2
0754 7604 C18B  30         mov r11,r6
0755 7606 06A0  36 vline1  bl @_vsbw0
     7608 785E     
0756 760A A020  42         a @xmax,r0
     760C A02E     
0757 760E 0602  22         dec r2
0758 7610 16FA  14         jne vline1
0759 7612 0456  24         b *r6
0760               
0761               
0762               ; draw a horizontal line subroutine
0763               ; r0=screen address
0764               ; character and length follow as DATA directives in caller code
0765 7614 C07B  46 hline   mov *r11+,r1
0766 7616 C0BB  46         mov *r11+,r2
0767 7618 C18B  30         mov r11,r6
0768 761A 06A0  36         bl @vsbwmi
     761C 78B2     
0769 761E 0456  24         b *r6
0770               
0771               
0772               ; write string subroutine
0773               ; r0=screen address
0774               ; source and length follow as DATA directives in caller code
0775 7620 C07B  46 wstr    mov *r11+,r1                ; source
0776 7622 C0BB  46         mov *r11+,r2                ; count
0777 7624 C18B  30         mov r11,r6                  ; return address
0778 7626 06A0  36         bl @_vmbw0                  ; write the string
     7628 7886     
0779 762A 0456  24         b *r6                       ; return
0780               
0781               
0782               
0783               
0784               ; scan keyboard
0785 762C D820  46 scnkey  movb @keybd,@>8374          ; set keyboard to scan
     762E 7656     
     7630 8374     
0786 7632 02E0  18         lwpi >83e0                  ; use gpl workspace
     7634 83E0     
0787 7636 06A0  28         bl @>000e                   ; call keyboard scanning routine
     7638 000E     
0788                   ; ########## added for V1.2 ###########
0789                       ; restore TF workspace
0790                       ; load a program into r0,r1,r2 & r3 as follows:
0791                       ; R0=LWPI
0792                       ; R1=<address of workspace (argument to LWPI instruction>
0793                       ; R2=BRANCH
0794                       ; R3=<branch address>
0795                   ; ########## added for V1.2 ###########
0796 763A 0200  20         li r0,>02e0     ; lwpi instruction
     763C 02E0     
0797 763E C060  34         mov @wp,r1      ; lwpi operand
     7640 A012     
0798 7642 0202  20         li r2,>0460     ; branch opcode
     7644 0460     
0799 7646 0203  20         li r3,scnky1    ; operand for branch instruction
     7648 764C     
0800 764A 0440  12         b r0            ; execute the code in workspace memory
0801 764C 04C7  14 scnky1  clr r7
0802 764E D1E0  30         movb @keyin,r7              ; a new key was pressed: get ascii code
     7650 8375     
0803 7652 0887  32         sra r7,8                    ; move to low byte
     **** ****     > RT
0001 7654 045B  20        b * r11
                   < 1-11-Editor.asm
0805 7656 0500     keybd   data >0500                  ; all keys
0806               
0807               
0808               
0809               ; miscellaneous routines
0810               ; delay routine
0811 7658 C03B  30 delay   mov *r11+,r0
0812 765A 0600  14 dlylop  dec r0
0813 765C 16FE  14         jne dlylop                  ; Dave Westwood would be proud
     **** ****     > RT
0001 765E 045B  20        b * r11
                   < 1-11-Editor.asm
0815               
0816               
0817               ; define cursor characters and corner edges etc
0818 7660 C18B  18 csrdef  mov r11,r6                  ; save return address
0819 7662 0200  20         li r0,>800                  ; ascii 1 address
     7664 0800     
0820 7666 0201  20         li r1,ascii0                ; source
     7668 7735     
0821 766A 0202  20         li r2,8*8
     766C 0040     
0822 766E 06A0  32         bl @_vmbw0
     7670 7886     
0823 7672 0456  20         b *r6
0824               
0825               
0826               ; set block status to dirty
0827 7674 C18B  18 needud  mov r11,r6
0828 7676 C020  34         mov @lstblk,r0              ; get current block
     7678 A1B6     
0829 767A 06A0  32         bl @scnblk                  ; locate it (blk address in r1)
     767C 6A02     
0830 767E 05C1  14         inct r1                     ; point to VDP address pointer
0831 7680 C011  26         mov *r1,r0                  ; get the VDP address
0832 7682 110B  14         jlt skipud                  ; skip if already set
0833 7684 0260  22         ori r0,>8000                ; set dirty bit
     7686 8000     
0834 7688 C440  30         mov r0,*r1                  ; write it back
0835 768A 0200  20 disupd  li r0,12                    ; screen address
     768C 000C     
0836 768E 0201  20         li r1,cngtxt                ; address of changed text
     7690 772D     
0837 7692 0202  20         li r2,7                     ; count
     7694 0007     
0838 7696 06A0  32         bl @_vmbw0                  ; write it
     7698 7886     
0839 769A 0456  20 skipud  b *r6
0840               
0841               
0842               
0843               ; check if 80 column mode is on or not...
0844 769C C020  34 is80c   mov @xmax,r0    ; get xmax
     769E A02E     
0845 76A0 0280  22         ci r0,80        ; compare to 80 (80-column)
     76A2 0050     
     **** ****     > RT
0001 76A4 045B  20        b * r11
                   < 1-11-Editor.asm
0847               
0848               
0849 76A6 3020     txt0    text '0         1         2         3'
     76A8 2020     
     76AA 2020     
     76AC 2020     
     76AE 2020     
     76B0 3120     
     76B2 2020     
     76B4 2020     
     76B6 2020     
     76B8 2020     
     76BA 3220     
     76BC 2020     
     76BE 2020     
     76C0 2020     
     76C2 2020     
     76C4 33       
0850 76C5   33     txt1    text '3         4         5         6'
     76C6 2020     
     76C8 2020     
     76CA 2020     
     76CC 2020     
     76CE 2034     
     76D0 2020     
     76D2 2020     
     76D4 2020     
     76D6 2020     
     76D8 2035     
     76DA 2020     
     76DC 2020     
     76DE 2020     
     76E0 2020     
     76E2 2036     
0851 76E4 0101     txt2    byte 1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1
     76E6 0101     
     76E8 0102     
     76EA 0101     
     76EC 0101     
     76EE 0101     
     76F0 0101     
     76F2 0102     
     76F4 0101     
     76F6 0101     
     76F8 0101     
     76FA 0101     
     76FC 0102     
     76FE 0101     
     7700 0101     
     7702 01       
0852 7703   01             byte 1,1,1
     7704 0101     
0853               
0854 7706 3031     rowtxt  text '0123456789012345'
     7708 3233     
     770A 3435     
     770C 3637     
     770E 3839     
     7710 3031     
     7712 3233     
     7714 3435     
0855 7716 426C     blktxt  text 'Block '
     7718 6F63     
     771A 6B20     
0856 771C 4D6F     modtxt  text 'Mode:'
     771E 6465     
     7720 3A       
0857 7721   49     instxt  text 'INSERT'
     7722 4E53     
     7724 4552     
     7726 54       
0858 7727   4F     ovrtxt  text 'OVER  '
     7728 5645     
     772A 5220     
     772C 20       
0859 772D   43     cngtxt  text 'CHANGED '
     772E 4841     
     7730 4E47     
     7732 4544     
     7734 20       
0860               
0861 7735   FC     ascii0  byte >fc,>fc,>fc,>fc,>fc,>fc,>fc,0      ; solid cursor character
     7736 FCFC     
     7738 FCFC     
     773A FCFC     
     773C 00       
0862 773D   00     ascii1  byte 0,0,0,255,255,0,0,0                ; straight line
     773E 0000     
     7740 FFFF     
     7742 0000     
     7744 00       
0863 7745   10     ascii2  byte 16,16,16,255,255,0,0,0             ; straight line with marker
     7746 1010     
     7748 FFFF     
     774A 0000     
     774C 00       
0864 774D   30     ascii3  byte >30,>30,>30,>30,>30,>30,>30,>30    ; vertical line
     774E 3030     
     7750 3030     
     7752 3030     
     7754 30       
0865 7755   00     ascii4  byte 0,0,0,>3f,>3f,>30,>30,>30          ; top left corner
     7756 0000     
     7758 3F3F     
     775A 3030     
     775C 30       
0866 775D   00     ascii5  byte 0,0,0,>f0,>f0,>30,>30,>30          ; top right corner
     775E 0000     
     7760 F0F0     
     7762 3030     
     7764 30       
0867 7765   30     ascii6  byte >30,>30,>30,>3f,>3f,0,0,0          ; bottom left corner
     7766 3030     
     7768 3F3F     
     776A 0000     
     776C 00       
0868 776D   30     ascii7  byte >30,>30,>30,>f0,>f0,0,0,0          ; bottom right corner
     776E 3030     
     7770 F0F0     
     7772 0000     
     7774 00       
0869               
0870 7775   46     help    text 'F1:Delete F2:Mode F3:Erase Line  F7:Page'
     7776 313A     
     7778 4465     
     777A 6C65     
     777C 7465     
     777E 2046     
     7780 323A     
     7782 4D6F     
     7784 6465     
     7786 2046     
     7788 333A     
     778A 4572     
     778C 6173     
     778E 6520     
     7790 4C69     
     7792 6E65     
     7794 2020     
     7796 4637     
     7798 3A50     
     779A 6167     
     779C 65       
0871 779D   46             text 'F9:Exit F=:Quit ESDX:Cursor ENT:New Line'
     779E 393A     
     77A0 4578     
     77A2 6974     
     77A4 2046     
     77A6 3D3A     
     77A8 5175     
     77AA 6974     
     77AC 2045     
     77AE 5344     
     77B0 583A     
     77B2 4375     
     77B4 7273     
     77B6 6F72     
     77B8 2045     
     77BA 4E54     
     77BC 3A4E     
     77BE 6577     
     77C0 204C     
     77C2 696E     
     77C4 65       
0872 77C5   5E             text '^C:Copy Line  ^V:Paste Line  ^I:Ins Line'
     77C6 433A     
     77C8 436F     
     77CA 7079     
     77CC 204C     
     77CE 696E     
     77D0 6520     
     77D2 205E     
     77D4 563A     
     77D6 5061     
     77D8 7374     
     77DA 6520     
     77DC 4C69     
     77DE 6E65     
     77E0 2020     
     77E2 5E49     
     77E4 3A49     
     77E6 6E73     
     77E8 204C     
     77EA 696E     
     77EC 65       
0873 77ED   5E             text '^D:Del Line ^O:Prev Block  ^P:Next block'
     77EE 443A     
     77F0 4465     
     77F2 6C20     
     77F4 4C69     
     77F6 6E65     
     77F8 205E     
     77FA 4F3A     
     77FC 5072     
     77FE 6576     
     7800 2042     
     7802 6C6F     
     7804 636B     
     7806 2020     
     7808 5E50     
     780A 3A4E     
     780C 6578     
     780E 7420     
     7810 626C     
     7812 6F63     
     7814 6B       
0874                       even
                   < build.asm
0049                   copy "./bank1/1-12-VDP.asm"
     **** ****     > ./bank1/1-12-VDP.asm
0001               ; __      _______  _____    _    _ _   _ _ _ _   _
0002               ; \ \    / /  __ \|  __ \  | |  | | | (_) (_) | (_)
0003               ;  \ \  / /| |  | | |__) | | |  | | |_ _| |_| |_ _  ___ ___
0004               ;   \ \/ / | |  | |  ___/  | |  | | __| | | | __| |/ _ | __|
0005               ;    \  /  | |__| | |      | |__| | |_| | | | |_| |  __|__ \
0006               ;     \/   |_____/|_|       \____/ \__|_|_|_|\__|_|\___|___/
0007               ; VDP access utility routines
0008               
0009               ;[ vdp single byte read
0010               ; inputs: r0=address in vdp to read, r1(msb), the byte read from vdp
0011               ; side effects: none
0012 7816 06C0  14 _vsbr   swpb r0
0013 7818 D800  30         movb r0,@vdpa
     781A 8C02     
0014 781C 06C0  14         swpb r0
0015 781E D800  30         movb r0,@vdpa
     7820 8C02     
     **** ****     > NOP
0001 7822 1000  14        jmp $+2
                   < 1-12-VDP.asm
0017 7824 D060  30         movb @vdpr,r1
     7826 8800     
     **** ****     > RT
0001 7828 045B  20        b * r11
                   < 1-12-VDP.asm
0019               ;]
0020               
0021               ;[ vdp multiple byte read
0022               ; inputs: r0=vdp source address, r1=cpu ram destination address
0023               ; r2=number of bytes to read
0024               ; side effects: r1, r2 & r13 changed
0025 782A C820  54 _vmbri  mov @bank1_,@retbnk         ; return to bank 1
     782C 606A     
     782E A070     
0026 7830 0300  22 _vmbr2  limi 2
     7832 0002     
0027 7834 0300  22         limi 0
     7836 0000     
0028                   ; entry point for no interrupts:
0029 7838 06C0  14 _vmbr   swpb r0
0030 783A D800  30         movb r0,@vdpa
     783C 8C02     
0031 783E 06C0  14         swpb r0
0032 7840 D800  30         movb r0,@vdpa
     7842 8C02     
     **** ****     > NOP
0001 7844 1000  14        jmp $+2
                   < 1-12-VDP.asm
0034 7846 DC60  44 _vmbr1  movb @vdpr,*r1+
     7848 8800     
0035 784A 0602  14         dec r2
0036 784C 16FC  14         jne _vmbr1
     **** ****     > RT
0001 784E 045B  20        b * r11
                   < 1-12-VDP.asm
0038               ;]
0039               
0040               ;[ vdp single byte write
0041               ; inputs: r0=address in vdp to write to, r1(msb)=the byte to write
0042               ; side effects: none
0043 7850 C820  54 _vsbw   mov @bank1_,@retbnk         ; return to bank 1
     7852 606A     
     7854 A070     
0044 7856 0300  22         limi 2
     7858 0002     
0045 785A 0300  22         limi 0
     785C 0000     
0046                   ; entry point for no interrupts:
0047 785E 0260  22 _vsbw0  ori r0,>4000
     7860 4000     
0048 7862 06C0  14         swpb r0
0049 7864 D800  30         movb r0,@vdpa
     7866 8C02     
0050 7868 06C0  14         swpb r0
0051 786A D800  30         movb r0,@vdpa
     786C 8C02     
0052 786E D801  30         movb r1,@vdpw
     7870 8C00     
0053 7872 2820  36         xor @_bit1,r0               ; reset bit 1
     7874 78E8     
     **** ****     > RT
0001 7876 045B  20        b * r11
                   < 1-12-VDP.asm
0055               ;]
0056               
0057               ;[ vdp multiple byte write
0058               ; r0=destination in vdp, r1=source address in cpu ram, r2=number of bytes
0059               ; side effects: r1, r2 & r13 changed
0060               _vmbw
0061 7878 C820  54         mov @bank1_,@retbnk         ; return to bank 1
     787A 606A     
     787C A070     
0062 787E 0300  22 _vmbw2  limi 2
     7880 0002     
0063 7882 0300  22         limi 0
     7884 0000     
0064                   ; entry point for no interrupts:
0065               _vmbw0  ; mov r2,r2                   ; check for zero length
0066                       ; jeq _vmbwx                  ; if zero then exit
0067 7886 0260  22         ori r0,>4000
     7888 4000     
0068 788A 06C0  14         swpb r0
0069 788C D800  30         movb r0,@vdpa
     788E 8C02     
0070 7890 06C0  14         swpb r0
0071 7892 D800  30         movb r0,@vdpa
     7894 8C02     
0072 7896 D831  40 _vmbw1  movb *r1+,@vdpw
     7898 8C00     
0073 789A 0602  14         dec r2
0074 789C 16FC  14         jne _vmbw1
0075 789E 2820  36         xor @_bit1,r0               ; reset bit 1
     78A0 78E8     
     **** ****     > RT
0076               _vmbwx  .rt
0001 78A2 045B  20        b * r11
                   < 1-12-VDP.asm
0077               ;]
0078               
0079               ;[ vdp single byte write many
0080               ; writes the same bytes multiple times to consequtive VDP address
0081               ; r0=vdp destination address
0082               ; r1=the byte to write (in msb)
0083               ; r2=number of times to write
0084 78A4 C820  54 _vsbwm  mov @bank1_,@retbnk         ; return to bank 1
     78A6 606A     
     78A8 A070     
0085 78AA 0300  22 _vsbwm2 limi 2
     78AC 0002     
0086 78AE 0300  22         limi 0
     78B0 0000     
0087                   ; entry point for no interrupts:
0088 78B2 0260  22 vsbwmi  ori r0,>4000                ; this is a vdp write command
     78B4 4000     
0089 78B6 06C0  14         swpb r0                     ; low byte first
0090 78B8 D800  30         movb r0,@vdpa               ; load low byte into address register
     78BA 8C02     
0091 78BC 06C0  14         swpb r0                     ; get high byte
0092 78BE D800  30         movb r0,@vdpa               ; write high byte
     78C0 8C02     
0093 78C2 D801  30 _vsbm1  movb r1,@vdpw
     78C4 8C00     
0094 78C6 0602  14         dec r2                      ; decrement count
0095 78C8 16FC  14         jne _vsbm1                  ; loop if not finished
0096 78CA 2820  36         xor @_bit1,r0               ; reset bit 1
     78CC 78E8     
     **** ****     > RT
0001 78CE 045B  20        b * r11
                   < 1-12-VDP.asm
0098               ;]
0099               
0100               ;[ vdp write to vdp register
0101               ; inputs: r0(msb)=the register to write to, r0(lsb)=the value to write
0102               ; side effects: none
0103 78D0 0260  22 _vwtr   ori r0,>8000
     78D2 8000     
0104 78D4 06C0  14         swpb r0
0105 78D6 D800  30         movb r0,@vdpa
     78D8 8C02     
0106 78DA 06C0  14         swpb r0
0107 78DC D800  30         movb r0,@vdpa
     78DE 8C02     
0108 78E0 2820  36         xor @_bit0,r0               ; reset bit 0
     78E2 78E6     
     **** ****     > RT
0001 78E4 045B  20        b * r11
                   < 1-12-VDP.asm
0110               ;]
0111 78E6 8000     _bit0   data >8000                  ; used for re-setting bits
0112 78E8 4000     _bit1   data >4000
                   < build.asm
0050                   copy "./bank1/1-13-Stack.asm"
     **** ****     > ./bank1/1-13-Stack.asm
0001               ;   _____ _              _     __          __            _
0002               ;  / ____| |            | |    \ \        / /           | |
0003               ; | (___ | |_  __ _  ___| | __  \ \  /\  / /___  _ __ __| |___
0004               ;  \___ \| __|/ _` |/ __| |/ /   \ \/  \/ // _ \| '__/ _` / __|
0005               ;  ____) | |_| (_| | (__|   <     \  /\  /| (_) | | | (_| \__ \
0006               ; |_____/ \__|\__,_|\___|_|\_\     \/  \/  \___/|_|  \__,_|___/
0007               ; Core words pertaining to data and return stack manipulation
0008               
0009               ;[ PICK ( x1 x2 x3 x4 n -- x1 x2 x3 x4 x5 )
0010               ; picks the nth value from the data stack and places a copy of it on the top
0011               ; of the data stack.
0012               ; note: parameters start from 0. 0 PICK is equivalent to DUP.
0013               ; 1 PICK is equivalent to OVER
0014 78EA C194  26 _pick   mov *stack,r6               ; get required stack parameter number
0015 78EC 0586  14         inc r6                      ; adjust for parameter n on stack
0016 78EE 0A16  26         sla r6,1                    ; convert to byte offset
0017 78F0 A184  18         a stack,r6                  ; add stack address to offset
0018 78F2 C516  38         mov *r6,*stack              ; read that address and place on stack
0019 78F4 0460  24 pickx   b @retB0                    ; NEXT
     78F6 833A     
0020               ;]
0021               
0022               ;[ ROLL ( +n -- n )
0023               ; The +nth stack value, not counting +n itself is first removed and then
0024               ; transferred to the top of the stack, moving the remaining values into the
0025               ; vacated position.  {0..the number of elements on the stack-1}
0026               ; 2 ROLL is equivalent to ROT. 0 ROLL is a null operation
0027 78F8 C234  30 _roll   mov *stack+,r8              ; pop roll value in r8
0028 78FA C208  18         mov r8,r8                   ; test for zero value
0029 78FC 13FB  14         jeq pickx                   ; if zero, take no action
0030 78FE C284  18         mov stack,r10               ; copy stack pointer
0031 7900 C248  18         mov r8,r9                   ; copy roll value
0032 7902 0A18  26         sla r8,1                    ; multiply by two, to get the offset into
0033                                                   ; the stack
0034 7904 A288  18         a r8,r10                    ; compute stack address to start from
0035 7906 C01A  26         mov *r10,r0                 ; store stack value, this will go to TOS
0036 7908 C04A  18         mov r10,r1                  ; move everything above this stack entry
0037                                                   ; back one
0038 790A 064A  14         dect r10                    ; source
0039 790C C45A  38 rolllp  mov *r10,*r1                ; move source back one word
0040 790E 064A  14         dect r10
0041 7910 0641  14         dect r1
0042 7912 0609  14         dec r9                      ; decrement counter. finished?
0043 7914 16FB  14         jne rolllp                  ; loop if not
0044 7916 C500  30         mov r0,*stack               ; place earlier saved value to TOS
0045 7918 10ED  14 exroll  jmp pickx                   ; NEXT
0046               ;]
0047               
0048               ;[ DEPTH ( -- depth )
0049               ; depth is the number of 16-bit values contained in the data stack before depth
0050               ; was placed on the stack.
0051 791A C1C4  18 _depth  mov stack,r7                ; copy address of TOS
0052 791C 05C7  14         inct r7
0053 791E C1A0  34         mov @s0,r6                  ; base of stack
     7920 A020     
0054 7922 6187  18         s r7,r6                     ; subtract tos from base of stack
0055 7924 0816  18         sra r6,1                    ; convert to cells
0056 7926 0644  14         dect stack                  ; new stack entry
0057 7928 C506  30         mov r6,*stack               ; push depth
0058 792A 10E4  14         jmp pickx                   ; NEXT
0059               ;]
                   < build.asm
0051                   copy "./bank1/1-14-File-IO.asm"
     **** ****     > ./bank1/1-14-File-IO.asm
0001               ;  ______ _ _         _____     ______
0002               ; |  ____(_) |       |_   _|   / / __ \
0003               ; | |__   _| | ___     | |    / / |  | |
0004               ; |  __| | | |/ _ \    | |   / /| |  | |
0005               ; | |    | | |  __/   _| |_ / / | |__| |
0006               ; |_|    |_|_|\___|  |_____/_/   \____/
0007               ; File IO implementation
0008               
0009               ;[ FILE ( s-addr  s-len  buf-addr -- )
0010               ; Builds a PAB in the buffer whose address is passed as buf_addr using the data
0011               ; in the string represented by s_addr and s_len.
0012               ; For example:
0013               ;     FBUF: PRINTER
0014               ;     S" PIO.CR DV80O" PRINTER FILE
0015               ; The above builds a PAB in the buffer called PRINTER which references the PIO
0016               ; device. Subsequent file IO words that wish to send data to the PIO shall use
0017               ; the buffer name to reference it:
0018               ; e.g.
0019               ;     PRINTER #OPEN DROP ( open PIO and drop success/fail flag)
0020               ;     S" HELLO WORLD" PRINTER #PUT DROP
0021               ;     ( write HELLO WORLD to the PIO and drop success/fail flag)
0022               ;
0023               ; Internally, FILE builds a PAB in the buffer which will be used by #OPEN and
0024               ; all file IO words.
0025               ; Word 0 of the reserved memory is used to point to the actual PAB in VDP
0026               ; memory. Enough space should be reserved (with ALLOT) in the buffer to hold the
0027               ; PAB and the filename.
0028               ;
0029               ; The string which specifies the file name and file characteristics is defined
0030               ; as below.
0031               ; The filename *must* come first followed by a space character. After that, the
0032               ; file options can be specified in any order.
0033               ;
0034               ; File Options:
0035               ;  F=Fixed      - Fixed record type
0036               ;  V=Variable   - Variable record type
0037               ;
0038               ;  D=Display    - Display data type
0039               ;  L=InternaL   - Internal data type
0040               ;
0041               ;  U=Update     - Update file mode
0042               ;  O=Output     - Output file mode
0043               ;  I=Input      - Inoput file mode
0044               ;  A=Append     - Append file mode
0045               ;
0046               ;  S=Sequential - Sequential file type
0047               ;  R=Relative   - Relative file type
0048               ;
0049               ; Note that Internal type files require L
0050               ; this is because I is used to specify INPUT
0051 792C 04C8  14 _file   clr r8                      ; zero the record length accumulator
0052 792E C2B4  30         mov *stack+,r10             ; pop buffer address from stack
0053                   ; zero the first 10 bytes of the alloted buffer
0054                   ; (holds the PAB data - no need to zero the filename length byte or the
0055                   ; file, as they'll be populated later)
0056 7930 C34A  18         mov r10,r13                 ; copy buffer address
0057 7932 0201  20         li r1,10                    ; number of bytes to clear
     7934 000A     
0058 7936 04FD  30 _ficll  clr *r13+                   ; clear two bytes in buffer
0059 7938 0641  14         dect r1                     ; decrement counter
0060 793A 16FD  14         jne _ficll                  ; repeat if not finished
0061                   ; transfer filename to PAB...
0062 793C 04C6  14         clr r6                      ; byte ops
0063 793E C024  34         mov @2(stack),r0            ; address of string in pad
     7940 0002     
0064 7942 C04A  18         mov r10,r1                  ; copy buffer address
0065 7944 0221  22         ai r1,12                    ; point to 1st filename byte
     7946 000C     
0066 7948 04C2  14         clr r2                      ; filename length
0067 794A D1B0  28 tfnl    movb *r0+,r6                ; get a character
0068 794C 0614  26         dec *stack                  ; decrement string length
0069 794E 0286  22         ci r6,' '*256               ; space?
     7950 2000     
0070 7952 1303  14         jeq wfnlb                   ; jump if yes
0071 7954 DC46  32         movb r6,*r1+                ; otherwise copy the byte
0072 7956 0582  14         inc r2                      ; increment length count
0073 7958 10F8  14         jmp tfnl                    ; and repeat
0074                   ; write filename length byte...
0075 795A 06C2  14 wfnlb   swpb r2                     ; get length in high byte
0076 795C DA82  38         movb r2,@11(r10)            ; move length byte into length byte position
     795E 000B     
0077                   ; process file options...
0078 7960 D1B0  28 fdochr  movb *r0+,r6                ; get a character
0079 7962 0614  26         dec *stack                  ; end of string?
0080 7964 1127  14         jlt fdone                   ; jump if yes
0081 7966 0286  22         ci r6,' '*256               ; is it a space?
     7968 2000     
0082 796A 13FA  14         jeq fdochr                  ; if yes then ignore it
0083 796C 0286  22         ci r6,'9'*256               ; found a digit?
     796E 3900     
0084 7970 120A  14         jle fdodig                  ; if so then do digit
0085                   ; the option is a character.
0086                   ; process it against the allowed list of characters
0087 7972 0207  20         li r7,foopts                ; pointer to options list
     7974 79D2     
0088 7976 020D  20         li r13,10                   ; 10 options in the list
     7978 000A     
0089 797A 95C6  26 fnxtop  cb r6,*r7                   ; compare a character
0090 797C 130E  14         jeq ffopt                   ; jump if match detected
0091 797E 0587  14         inc r7                      ; move to next charater in list
0092 7980 060D  14         dec r13                     ; decrement count
0093 7982 16FB  14         jne fnxtop                  ; check next option
0094 7984 10ED  14         jmp fdochr                  ; check next character
0095                   ; process numeric digit
0096 7986 C248  18 fdodig  mov r8,r9                   ; copy accumulator
0097 7988 0A38  30         sla r8,3                    ; multiply accumulator by 8
0098 798A 0A19  26         sla r9,1                    ; multiply copy by 2
0099 798C A209  18         a r9,r8                     ; add them - we just did a multiply by 10
0100                       ; (MPY needs consecutive registers, and sometimes its just too much
0101                       ; like hard work, know what I mean?)
0102 798E 0986  40         srl r6,8                    ; shift byte into low byte
0103 7990 0226  22         ai r6,-48                   ; remove ascii offset
     7992 FFD0     
0104 7994 A206  18         a r6,r8                     ; add to accumulator
0105 7996 04C6  14         clr r6                      ; byte ops
0106 7998 10E3  14         jmp fdochr                  ; process next character
0107                   ; set file option...
0108 799A 0227  22 ffopt   ai r7,-20                   ; point to appropriate mask byte (the bits
     799C FFEC     
0109                                                   ; to reset)
0110 799E D06A  34         movb @3(r10),r1             ; get flag byte from PAB
     79A0 0003     
0111 79A2 5057  26         szcb *r7,r1                 ; reset appropriate bit(s)
0112 79A4 0227  22         ai r7,10                    ; point to bits table (the bits to set)
     79A6 000A     
0113 79A8 F057  26         socb *r7,r1                 ; set appropriate bit(s)
0114 79AA DA81  38         movb r1,@3(r10)             ; write it back
     79AC 0003     
0115 79AE 0227  22         ai r7,10                    ; restore pointer
     79B0 000A     
0116 79B2 10D6  14         jmp fdochr                  ; process next character in the string
0117 79B4 06C8  14 fdone   swpb r8                     ; get record length in msb
0118 79B6 DA88  38         movb r8,@6(r10)             ; move it into the pab
     79B8 0006     
0119                   ;    dect stack                  ; pop length
0120                   ;    dect stack                  ; pop address
0121 79BA 8D34  42         c *stack+,*stack+           ; pop length & address
0122 79BC 1051  14         jmp _fcxit
0123               
0124 79BE 1010     fomask  byte >10,>10                ; F & V mask
0125 79C0 0808             byte >08,>08                ; D & I mask
0126 79C2 0606             byte >06,>06,>06,>06        ; U O I & A masks
     79C4 0606     
0127 79C6 0101             byte >01,>01                ; S & R masks
0128               
0129 79C8 0010     bitmsk  byte >00,>10                ; F & V bits
0130 79CA 0008             byte >00,>08                ; D & I bits
0131 79CC 0002             byte >00,>02,>04,>06        ; U O I & A bits
     79CE 0406     
0132 79D0 0001             byte >00,>01                ; S & R bits
0133 79D2 4656     foopts  text 'FVDLUOIASR'           ; file options (L=internaL)
     79D4 444C     
     79D6 554F     
     79D8 4941     
     79DA 5352     
0134               ;]
0135               
0136               ;[ #OPEN ( file_addr -- t|f )
0137               ; Opens a file with the file name and attributes specified in the buffer
0138               ; starting at file_addr.
0139               ; The buffer (actually a PAB) is set-up with FILE.
0140               ; E.g. FBUF: SERIAL
0141               ;      S" RS232.BA=9600 DV80SO" SERIAL FILE
0142               ;      SERIAL #OPEN
0143               ; The above shall attempt to open the serial port for output as a Display
0144               ; Variable 80 type file.
0145               ;
0146               ; #OPEN leaves a FALSE on the stack if the file was opened sucessfully.
0147               ; If the file could not be opened then it leaves a TRUE on the stack.
0148               ; This allows easy trapping with ABORT" as shown below:
0149               ; SERIAL #OPEN ABORT" Could not open serial port"
0150               ;
0151               ; In the event of a file error, IOERR can be read to get the DSR error code.
0152               ; If IOERR returns -1 (>FFFF) then this means that no free file IO slots were
0153               ; found. A maximum of 3 open files is supported (2 if block files are also to
0154               ; be used). Note that block files are immediately closed after they are accessed
0155               ; for either reading or writing, so 3 generic file io streams are available
0156               ; when no blocks files are being used.
0157               
0158                   ; find a free file slot...
0159 79DC 0200  20 _fopen  li r0,falloc                ; address of file allocation table
     79DE A1AC     
0160 79E0 0202  20         li r2,3                     ; three slots
     79E2 0003     
0161 79E4 C050  26 nxtslt  mov *r0,r1                  ; first slot address
0162 79E6 1508  14         jgt foend                   ; if msb is not set then the slot is empty
0163 79E8 05C0  14         inct r0                     ; otherwise move to next slot address
0164 79EA 0602  14         dec r2                      ; and try it
0165 79EC 16FB  14         jne nxtslt
0166                   ; no free slots... sorry, no can do...
0167 79EE 0720  34         seto @errnum                ; set ioerr to -1 (no available files)
     79F0 A03A     
0168 79F2 0714  26         seto *stack                 ; leave a TRUE on the stack
0169 79F4 0460  24         b @retB0
     79F6 833A     
0170                   ; ok, the slot is free...
0171 79F8 C294  26 foend   mov *stack,r10              ; cpu pab address
0172 79FA C681  30         mov r1,*r10                 ; store vdp address of the free PAB in word
0173                                                   ; 0 of CPU RAM PAB
0174 79FC C081  18         mov r1,r2                   ; copy the vdp address
0175 79FE 0262  22         ori r2,>8000                ; set its most-sig bit to indicate this slot
     7A00 8000     
0176                                                   ; is in use
0177 7A02 C402  30         mov r2,*r0                  ; write it back falloc table
0178 7A04 0221  22         ai r1,40                    ; record buffer in vdp is 40 bytes after PAB
     7A06 0028     
0179 7A08 CA81  38         mov r1,@4(r10)              ; store it in bytes 2 & 3 of the PAB
     7A0A 0004     
0180 7A0C 0221  22         ai r1,-40                   ; restore r1 to point to PAB address in VDP
     7A0E FFD8     
0181                   ; transfer the PAB in CPU RAM to the appropriate place in VDP
0182 7A10 C001  18         mov r1,r0                   ; get in r0 for VMBW
0183 7A12 C200  18         mov r0,r8                   ; keep a copy
0184 7A14 C04A  18         mov r10,r1                  ; source address
0185 7A16 05C1  14         inct r1                     ; move past word 0 in CPU PAB (vdp address
0186                                                   ; pointer)
0187 7A18 0202  20         li r2,40                    ; byte count
     7A1A 0028     
0188 7A1C 06A0  32         bl @_vmbw0                  ; write it to VDP
     7A1E 7886     
0189 7A20 0228  22         ai r8,9                     ; adjust vdp address copy to point to
     7A22 0009     
0190                                                   ; filename length byte
0191 7A24 C808  30         mov r8,@namptr              ; store in >8356 as per DSR requirements
     7A26 8356     
0192 7A28 0420  50         blwp @dsrlnk                ; call dos
     7A2A 6A40     
0193 7A2C 0008             data 8                      ; disk op parameter, level 3 command
0194 7A2E 1304  14         jeq _foerr                  ; jump if an error
0195 7A30 04D4  26         clr *stack                  ; set top of stack to FALSE (success)
0196 7A32 04E0  34         clr @errnum                 ; clear io error
     7A34 A03A     
0197 7A36 1031  14         jmp fexit
0198                   ; the file could not be opened
0199 7A38 0980  40 _foerr  srl r0,8                    ; move error code to lower byte
0200 7A3A C800  38         mov r0,@errnum              ; set disk io error number
     7A3C A03A     
0201 7A3E 0714  26         seto *stack                 ; set true flag (failure)
0202 7A40 102C  14         jmp fexit
0203               ;]
0204               
0205               ;[ #CLOSE ( fid -- )
0206               ; closes a file
0207               ; Where a file is opened thus: S" DSK1.README DV80IS" #OPEN MYFILE
0208               ; the following will close the same file: MYFILE #CLOSE
0209 7A42 06A0  32 _fclos  bl @dodcmd
     7A44 7B92     
0210 7A46 0100             data close*256
0211                   ; now reset the pab pointer in the file allocation table...
0212                   ; r13 holds the vdp address of the start of the pab
0213 7A48 0201  20         li r1,falloc                ; address of file allocation table
     7A4A A1AC     
0214 7A4C 0202  20         li r2,3                     ; 3 entries in the table
     7A4E 0003     
0215 7A50 C191  26 _fclop  mov *r1,r6                  ; get an entry
0216 7A52 0246  22         andi r6,>7fff               ; remove msb
     7A54 7FFF     
0217 7A56 8346  18         c r6,r13                    ; found the entry?
0218 7A58 1304  14         jeq _fcfnd                  ; jump if yes
0219 7A5A 05C1  14         inct r1                     ; try next word
0220 7A5C 0602  14         dec r2                      ; decrement counter
0221 7A5E 16F8  14         jne _fclop                  ; repeat if not finished
0222 7A60 101C  14 _fcxit  jmp fexit
0223 7A62 C44D  30 _fcfnd  mov r13,*r1                 ; move address (with msb reset) back into
0224                                                   ; file allocation table
0225 7A64 10FD  14         jmp _fcxit
0226               ;]
0227               
0228               ;[ #GET ( buff_addr fid -- t|f )
0229               ; reads a line of input from the file specified by fid.
0230               ; The address of an appropriately sized buffer must be supplied.
0231               ; If the read is successful, the buffer is filled with the data read from the
0232               ; input device, with the first cell being the length count of the data
0233               ; immediately following it.
0234               ; This can be converted into a address/length pair with COUNT.
0235               ; Returns:
0236               ;  False if successful
0237               ;  True if not successful
0238               ; This allows trapping with ABORT" as follows:
0239               ; <address> MYFILE #GET ABORT" Could not read from the file"
0240               ; If the read fails, IOERR is set to the error code, otherwise it is zero'd
0241 7A66 06A0  32 _fget    bl @dodcmd                 ; read from disk
     7A68 7B92     
0242 7A6A 0200             data read*256
0243 7A6C 1312  14         jeq _fgerr                  ; jump if error
0244                       ; r13 holds the vdp address of the start of the pab
0245 7A6E C00D  18         mov r13,r0                  ; transfer to r0 for vdp access
0246 7A70 0220  22         ai r0,5                     ; point to character count
     7A72 0005     
0247 7A74 06A0  32         bl @_vsbr                   ; read the length of the returned record
     7A76 7816     
0248 7A78 C254  26         mov *stack,r9               ; get cpu ram buffer address from stack
0249 7A7A DE41  32         movb r1,*r9+                ; move length of record to the buffer
0250 7A7C D081  18         movb r1,r2                  ; copy length byte to r2 for vdp counter in
0251                                                   ; vmbr
0252 7A7E 0982  40         srl r2,8                    ; move length byte to low byte of r2
0253 7A80 1306  14         jeq recln0                  ; jump if the record read had a length of 0
0254 7A82 C00D  18         mov r13,r0                  ; start of pab
0255 7A84 0220  22         ai r0,40                    ; point to associated data buffer
     7A86 0028     
0256 7A88 C049  18         mov r9,r1                   ; cpu ram buffer address
0257 7A8A 06A0  32         bl @_vmbr                   ; transfer from the buffer in vdp to the
     7A8C 7838     
0258                                                   ; buffer in CPU
0259 7A8E 04D4  26 recln0  clr *stack                  ; place false on stack (succeeded)
0260 7A90 1004  14 _fgxit  jmp fexit
0261                   ; an error occurred
0262 7A92 0980  40 _fgerr  srl r0,8                    ; move error code to lower byte
0263 7A94 C800  38         mov r0,@errnum              ; set disk io error number
     7A96 A03A     
0264 7A98 0714  26         seto *stack                 ; set stack to true (failed)
0265                       ; fall down into fexit...
0266               ;]
0267               
0268               
0269               
0270 7A9A 06A0  32 fexit   bl @rstsp                   ; restore code in scratchpad
     7A9C 6B50     
0271                                                   ; (destroyed by DSR access)
0272 7A9E 0460  24         b @retB0
     7AA0 833A     
0273               
0274               
0275               
0276               ;[ #PUT ( buff_addr len  fid - t|f )
0277               ; Places a string from buffer_addr with length len to the file represented by
0278               ; fid.
0279               ; Returns false if successful, else returns true.
0280               ; This can be trapped with ABORT"
0281 7AA2 C014  26 _fput   mov *stack,r0               ; get fid
0282 7AA4 C010  26         mov *r0,r0                  ; get vdp pab address
0283 7AA6 C064  34         mov @2(stack),r1            ; get length from stack
     7AA8 0002     
0284 7AAA 06C1  14         swpb r1                     ; move to high byte
0285 7AAC 0220  22         ai r0,5                     ; point to length byte in pab
     7AAE 0005     
0286 7AB0 06A0  32         bl @_vsbw0                  ; write the length byte to the pab
     7AB2 785E     
0287 7AB4 C1A0  34         mov @blknum,r6              ; processing a block?
     7AB6 A1B4     
0288 7AB8 1620  14         jne _fpvdp                  ; if so then the data we want to write is
0289                                                   ; aleady in vdp
0290 7ABA 0220  22         ai r0,-3                    ; else back up to point data buffer address
     7ABC FFFD     
0291 7ABE C054  26         mov *stack,r1               ; pointer to vdp pab address in r1
0292 7AC0 C051  26         mov *r1,r1                  ; get the vdp pab address
0293 7AC2 0221  22         ai r1,40                    ; compute vdp buffer address(pab address+40)
     7AC4 0028     
0294 7AC6 06A0  32         bl @_vsbw0                  ; write msb of address
     7AC8 785E     
0295 7ACA 0580  14         inc r0                      ; advance vdp address
0296 7ACC 06C1  14         swpb r1                     ; get lsb
0297 7ACE 06A0  32         bl @_vsbw0                  ; write it
     7AD0 785E     
0298 7AD2 C014  26 _fp1    mov *stack,r0               ; get vdp address of pab again
0299 7AD4 C010  26         mov *r0,r0                  ; get vdp pab address
0300 7AD6 0220  22         ai r0,40                    ; point to record buffer
     7AD8 0028     
0301 7ADA C0A4  34         mov @2(stack),r2            ; length
     7ADC 0002     
0302 7ADE C064  34         mov @4(stack),r1            ; cpu source address
     7AE0 0004     
0303 7AE2 06A0  32         bl @_vmbw0                  ; write to vdp
     7AE4 7886     
0304 7AE6 06A0  32 _fp2    bl @dodcmd
     7AE8 7B92     
0305 7AEA 0300             data write*256
0306 7AEC 1303  14         jeq _fperr                  ; jump if error
0307 7AEE 05C4  14         inct stack                  ; pop length
0308 7AF0 04D4  26         clr *stack                  ; success
0309 7AF2 10D3  14 _fpxit  jmp fexit
0310 7AF4 05C4  14 _fperr  inct stack                  ; pop length
0311 7AF6 0714  26         seto *stack                 ; failed
0312 7AF8 10FC  14         jmp _fpxit
0313 7AFA C014  26 _fpvdp  mov *stack,r0               ; vdp address of pab in r0
0314 7AFC C010  26         mov *r0,r0                  ; get vdp pab address
0315 7AFE 0220  22         ai r0,2                     ; point to data buffer address
     7B00 0002     
0316 7B02 C064  34         mov @-4(stack),r1           ; buffer address
     7B04 FFFC     
0317 7B06 06A0  32         bl @_vsbw0                  ; write msb of address
     7B08 785E     
0318 7B0A 0580  14         inc r0                      ; advance vdp address
0319 7B0C 06C1  14         swpb r1                     ; get lsb
0320 7B0E 06A0  32         bl @_vsbw0                  ; write it
     7B10 785E     
0321 7B12 10E9  14         jmp _fp2
0322               ;]
0323               
0324               ;[ #REC ( record# fid -- )
0325               ; Sets the record number for reading or writing for relative files
0326 7B14 C034  30 _frec   mov *stack+,r0              ; get fid
0327 7B16 C010  26         mov *r0,r0                  ; get vdp address of associated pab
0328 7B18 0220  22         ai r0,6                     ; point to record number in vdp
     7B1A 0006     
0329 7B1C D074  28         movb *stack+,r1             ; get record number high byte
0330 7B1E 06A0  32         bl @_vsbw0                  ; write it
     7B20 785E     
0331 7B22 0580  14         inc r0                      ; point to record# low byte in pab
0332 7B24 D074  28         movb *stack+,r1             ; get low byte of record number
0333 7B26 06A0  32         bl @_vsbw0                  ; write it
     7B28 785E     
0334 7B2A 0460  24         b @retB0
     7B2C 833A     
0335               ;]
0336               
0337               
0338               ;[ #EOF? ( fid -- t|f )
0339               ; returns true if currently positioned at the end of the file referenced by fid
0340 7B2E 06A0  32 _feof   bl @dodcmd
     7B30 7B92     
0341 7B32 0900             data status*256
0342 7B34 C00D  18         mov r13,r0                  ; vdp address of pab to r0
0343 7B36 0220  22         ai r0,8                     ; point to screen offset byte (where status
     7B38 0008     
0344                                                   ; is stored)
0345 7B3A 06A0  32         bl @_vsbr                   ; read the byte
     7B3C 7816     
0346 7B3E 0241  22         andi r1,>0100               ; isolate bit 7 (eof bit)
     7B40 0100     
0347 7B42 0A71  38         sla r1,7                    ; move bit to bit 0 (msb)
0348 7B44 08F1  46         sra r1,15                   ; shift it back to lsb
0349                   ; at this point, if bit 7 was 0 then r1 is 0000000000000000(2) (i.e. false)
0350                   ; if bit 7 was 1 then r1 is 1111111111111111(2) (i.e. true)
0351 7B46 0644  14         dect stack                  ; make space on stack (dodcmd pops the fid)
0352 7B48 C501  30         mov r1,*stack               ; move to stack
0353 7B4A 10A7  14         jmp fexit
0354               ;]
0355               
0356               ;[
0357               _opt5   ; addr len size loadAddr opcode
0358                       ; build a PAB in CPU ram
0359 7B4C C020  34         mov @here,r0                ; get here
     7B4E A048     
0360 7B50 C200  18         mov r0,r8                   ; save a copy
0361 7B52 04C2  14         clr r2
0362 7B54 C074  30         mov *stack+,r1              ; opcode
0363 7B56 CC01  34         mov r1,*r0+                 ; to here       0 1
0364 7B58 CC34  46         mov *stack+,*r0+            ; loadAddr      2 3
0365 7B5A CC02  34         mov r2,*r0+                 ; not used      4 5
0366 7B5C CC34  46         mov *stack+,*r0+            ; size of file  6 7
0367 7B5E C1F4  30         mov *stack+,r7              ; get length of filename
0368 7B60 CC07  34         mov r7,*r0+                 ; to pab        8 9
0369 7B62 0200  20         li r0,>37b8                 ; vdp address of pab
     7B64 37B8     
0370 7B66 C048  18         mov r8,r1                   ; cpu source address
0371 7B68 0202  20         li r2,10                    ; 10 bytes
     7B6A 000A     
0372 7B6C 06A0  32         bl @_vmbw0                  ; write to vdp
     7B6E 7886     
0373                       ; now write filename to vdp
0374 7B70 0200  20         li r0,>37b8+10              ; destination address in vdp
     7B72 37C2     
0375 7B74 C074  30         mov *stack+,r1              ; address of filename
0376 7B76 C087  18         mov r7,r2                   ; length of filename
0377 7B78 06A0  32         bl @_vmbw0                  ; write it
     7B7A 7886     
0378 7B7C 0200  20         li r0,>37b8+9               ; address of length byte
     7B7E 37C1     
0379 7B80 C800  30         mov r0,@>8356               ; ...to >8356
     7B82 8356     
0380               
0381 7B84 0420  50         blwp @dsrlnk                ; witchcraft and wizardry
     7B86 6A40     
0382 7B88 0008             data 8                      ; standard file access
0383 7B8A 06A0  32         bl @rstsp                   ; restore scratchpad
     7B8C 6B50     
0384 7B8E 0460  24         b @retB0                    ; see ya
     7B90 833A     
0385               ;]
0386               
0387               
0388               
0389               
0390               ;[ Do Disk Command subroutine - executes the disk command passed by the caller
0391 7B92 C07B  30 dodcmd  mov *r11+,r1                ; get opcode
0392 7B94 C38B  18         mov r11,r14                 ; save return address
0393 7B96 C034  30         mov *stack+,r0              ; get pointer to cpu ram pab
0394 7B98 C010  26         mov *r0,r0                  ; get vdp address of the pab
0395 7B9A C340  18         mov r0,r13                  ; copy it (used by #CLOSE, #PUT, #EOF etc)
0396 7B9C 06A0  32 docmd1  bl @_vsbw                   ; write the op-code to the pab
     7B9E 7850     
0397                   ; clear bits 0, 1 & 2 of byte 1 of the PAB...
0398 7BA0 0580  14         inc r0                      ; move to byte 1 of the pab
0399 7BA2 06A0  32         bl @_vsbr                   ; read it
     7BA4 7816     
0400 7BA6 0241  22         andi r1,>1f00               ; reset bits 0,1 & 2
     7BA8 1F00     
0401 7BAA 06A0  32         bl @_vsbw                   ; write it back
     7BAC 7850     
0402 7BAE 0220  22         ai r0,8                     ; point to filename length byte
     7BB0 0008     
0403 7BB2 C800  30         mov r0,@namptr              ; load >8356 with pointer to name length as
     7BB4 8356     
0404                                                   ; per DSR requirements
0405                   ; call the DSR...
0406 7BB6 0420  50         blwp @dsrlnk
     7BB8 6A40     
0407 7BBA 0008             data 8
0408 7BBC 045E  20         b *r14                      ; return to caller
0409               ;]
0410               
0411               ; close all open files
0412               ; called by abort in bank 0
0413 7BBE 0206  20 _clall  li r6,6                     ; offset into file allocation table, and
     7BC0 0006     
0414                                                   ; also counter
0415 7BC2 C026  34 _ca1    mov @falloc(r6),r0          ; get address of PAB in vdp from file
     7BC4 A1AC     
0416                                                   ; allocation table
0417 7BC6 C1C0  18         mov r0,r7                   ; copy it
0418 7BC8 0247  22         andi r7,>8000               ; check 'in-use' bit
     7BCA 8000     
0419 7BCC 1309  14         jeq _cart                   ; skip if the entry in the table isn't
0420                                                   ; open/in-use
0421 7BCE 0240  22         andi r0,>7fff               ; reset 'in-use' bit
     7BD0 7FFF     
0422 7BD2 C980  38         mov r0,@falloc(r6)          ; write it back to the file allocation table
     7BD4 A1AC     
0423 7BD6 020E  20         li r14,_cart                ; make #CLOSE return to us ;-)
     7BD8 7BE0     
0424 7BDA 0201  20         li r1,close*256             ; close opcode for #CLOSE
     7BDC 0100     
0425 7BDE 10DE  14         jmp docmd1                  ; borrow part of the DODCMD routine to do
0426                                                   ; the work for us ;-)
0427 7BE0 0646  14 _cart   dect r6                     ; decrement counter
0428 7BE2 0286  22         ci r6,-2                    ; finished?
     7BE4 FFFE     
0429 7BE6 16ED  14         jne _ca1                    ; close next file if not
0430 7BE8 0460  28         b @fexit
     7BEA 7A9A     
                   < build.asm
0052                   copy "./bank1/1-15.Sound.asm"
     **** ****     > ./bank1/1-15.Sound.asm
0001               ;          _____                       _  __          __           _
0002               ;         / ____|                     | | \ \        / /          | |
0003               ;        | (___   ___  _   _ _ __   __| |  \ \  /\  / /__  _ __ __| |___
0004               ;         \___ \ / _ \| | | | '_ \ / _` |   \ \/  \/ / _ \| '__/ _` / __|
0005               ;         ____) | (_) | |_| | | | | (_| |    \  /\  / (_) | | | (_| \__ \
0006               ;        |_____/ \___/ \__,_|_| |_|\__,_|     \/  \/ \___/|_|  \__,_|___/
0007               
0008               
0009               ; SN76489 register writes
0010               ; -----------------------
0011               ; When a byte is written to the SN76489, it processes it as follows:
0012               ;  %1cctdddd
0013               ;    d=data bits
0014               ;    t=type bits
0015               ;    c=channel bits
0016               ;If bit 7 is 1 then the byte is a LATCH/DATA byte.
0017               ;
0018               ; Bits 6 and 5 (cc) give the channel to be latched, ALWAYS.
0019               ; This selects the row in the above table.
0020               ; %00 is channel 0, %01 is channel 1, %10 is channel 2, %11 is channel 3.
0021               ; Bit 4 (t) determines whether to latch volume (1) or tone/noise (0) data.
0022               ; The remaining 4 bits (dddd) are placed into the low 4 bits of the relevant
0023               ; register.
0024               ; For the three-bit noise register, the highest bit is discarded.
0025               ; The latched register is NEVER cleared by a data byte.
0026               ; If bit 7 is 0 then the byte is a DATA byte.
0027               ;
0028               ;  %0-DDDDDD
0029               ;    |``````-- Data
0030               ;    `-------- Unused
0031               ;
0032               ; If the currently latched register is a tone register then the low 6 bits of
0033               ; the byte (DDDDDD) are placed into the high 6 bits of the latched register.
0034               ; If the latched register is less than 6 bits wide (ie. not one of the tone
0035               ; registers), instead the low bits are placed into the corresponding bits of the
0036               ; register, and any extra high bits are discarded.
0037               ; The data have the following meanings (described more fully later):
0038               ;
0039               ; Tone registers
0040               ;    DDDDDDdddd = cccccccccc
0041               ;    DDDDDDdddd gives the 10-bit half-wave counter reset value.
0042               ;
0043               ; Volume registers
0044               ;    (DDDDDD)dddd = (--vvvv)vvvv
0045               ;
0046               ;    dddd gives the 4-bit volume value.
0047               ;    If a data byte is written, the low 4 bits of DDDDDD update the 4-bit volume
0048               ;    value. However, this is unnecessary.
0049               ;
0050               ; Noise register
0051               ;    (DDDDDD)dddd = (---trr)-trr
0052               ;
0053               ;    The low 2 bits of dddd select the shift rate and the next highest bit
0054               ;    (bit 2) selects the mode (white (1) or "periodic" (0)).
0055               ;    If a data byte is written, its low 3 bits update the shift rate and mode
0056               ;    in the same way.
0057               
0058               ; called from bank0 - see 0-20-Sound.a99
0059 7BEC C820  54 sound1  mov @bank1_,@retbnk
     7BEE 606A     
     7BF0 A070     
0060 7BF2 0300  22         limi 2
     7BF4 0002     
0061 7BF6 0300  22         limi 0
     7BF8 0000     
0062 7BFA 0207  20         li r7,>8400                 ; address of sound chip
     7BFC 8400     
0063                   ; set the channel...
0064 7BFE C074  30         mov *stack+,r1              ; pop channel
0065 7C00 C201  18         mov r1,r8                   ; save it
0066 7C02 0200  20         li r0,>9000                 ; set msb and volume latch bit
     7C04 9000     
0067 7C06 0B31  22         src r1,3                    ; move channel into correct bit position
0068 7C08 E040  18         soc r0,r1                   ; combine
0069                   ; set the volume...
0070 7C0A C034  30         mov *stack+,r0              ; pop volume
0071 7C0C 06C0  14         swpb r0                     ; move to high byte
0072 7C0E E040  18         soc r0,r1                   ; combine
0073 7C10 D5C1  30         movb r1,*r7                 ; move to sound chip
0074                   ; get pitch...
0075 7C12 0241  22         andi r1,>e000               ; reset t bit (to latch pitch)
     7C14 E000     
0076 7C16 C034  30         mov *stack+,r0              ; pop pitch
0077 7C18 C080  18         mov r0,r2                   ; copy it
0078 7C1A 0240  22         andi r0,>000f               ; get the low 4 bits
     7C1C 000F     
0079 7C1E 06C0  14         swpb r0                     ; move to high byte
0080 7C20 E040  18         soc r0,r1                   ; combine
0081 7C22 D5C1  30         movb r1,*r7                 ; move to sound chip
0082                   ; process noise channel if ch#=3...
0083 7C24 0288  22         ci r8,3                     ; noise channel?
     7C26 0003     
0084 7C28 1302  14         jeq sndxit                  ; if so then just exit
0085 7C2A 0A42  32         sla r2,4                    ; get upper 6 bits in upper byte
0086 7C2C D5C2  30         movb r2,*r7                 ; send to sound chip
0087 7C2E 0460  24 sndxit  b @retB0
     7C30 833A     
                   < build.asm
0053                   copy "./bank1/1-16-Initialise.asm"
     **** ****     > ./bank1/1-16-Initialise.asm
0001               ;  _____       _ _   _       _ _           _   _
0002               ; |_   _|     (_) | (_)     | (_)         | | (_)
0003               ;   | |  _ __  _| |_ _  __ _| |_ ___  __ _| |_ _  ___  _ __
0004               ;   | | | '_ \| | __| |/ _` | | / __|/ _` | __| |/ _ \| '_ \
0005               ;  _| |_| | | | | |_| | (_| | | \__ \ (_| | |_| | (_) | | | |
0006               ; |_____|_| |_|_|\__|_|\__,_|_|_|___/\__,_|\__|_|\___/|_| |_|
0007               ; this code runs at startup to bring TurboForth to life
0008               
0009               ; general initialisation of RAM variables etc
0010               
0011               init
0012               
0013 7C32 C0E0  34         mov @sumode,r3              ; save graphics startup mode value
     7C34 A07A     
0014               
0015 7C36 0200  20         li r0,>0190                 ; turn the screen off while we set things up
     7C38 0190     
0016 7C3A 06A0  32         bl @_vwtr
     7C3C 78D0     
0017               
0018               
0019               ;[ initialise SAMS card if fitted
0020 7C3E 020C  20         li r12,>1e00                ; sams CRU base
     7C40 1E00     
0021 7C42 1D00  16         sbo 0                       ; enable access to mapper registers
0022 7C44 1E01  16         sbz 1                       ; disable mapping while we set it up
0023 7C46 0200  20         li r0,>4004                 ; register for >2000
     7C48 4004     
0024 7C4A 0201  20         li r1,>f8f8                 ; map bank >f8 into >2000
     7C4C F8F8     
0025 7C4E CC01  34         mov r1,*r0+                 ; do it
0026 7C50 0201  20         li r1,>f9f9                 ; map bank >f9...
     7C52 F9F9     
0027 7C54 CC01  34         mov r1,*r0+                 ; ...into >3000
0028                   ; now set up the banks for high memory...
0029 7C56 0200  20         li r0,>4014                 ; register address
     7C58 4014     
0030 7C5A 0201  20         li r1,>fafa                 ; register value
     7C5C FAFA     
0031 7C5E 0202  20         li r2,6                     ; loop count
     7C60 0006     
0032 7C62 CC01  34 sams    mov r1,*r0+                 ; write to the register
0033 7C64 0221  22         ai r1,>0101                 ; next register value
     7C66 0101     
0034 7C68 0602  14         dec r2                      ; finished?
0035 7C6A 16FB  14         jne sams                    ; loop if not
0036 7C6C 1D01  16         sbo 1                       ; enable mapping
0037 7C6E 1E00  16         sbz 0                       ; lock the mapper registers
0038               ;]
0039               
0040               ;[ clear variables area
0041 7C70 0200  20 cva     li r0,>a000                 ; start address
     7C72 A000     
0042 7C74 0201  20         li r1,prgtop                ; end address
     7C76 A2C8     
0043 7C78 04F0  30 clrlop  clr *r0+                    ; clear a word
0044 7C7A 8040  18         c r0,r1                     ; finished?
0045 7C7C 16FD  14         jne clrlop                  ; repeat if not
0046               ;]
0047               
0048 7C7E C803  38         mov r3,@sumode              ; restore start up graphics mode
     7C80 A07A     
0049 7C82 C820  50         mov @>83c0,@seed            ; initialise random number seed
     7C84 83C0     
     7C86 A078     
0050               
0051               ;[ set up boot file name (DSK1.BLOCKS)
0052 7C88 0200  20         li r0,bootfn                ; address of boot filename
     7C8A 7DEC     
0053 7C8C 0201  20         li r1,pabnln                ; destination
     7C8E A18B     
0054 7C90 0202  20         li r2,12                    ; 12 bytes to copy
     7C92 000C     
0055 7C94 DC70  42 bootlp  movb *r0+,*r1+              ; copy a byte
0056 7C96 0602  14         dec r2                      ; finished?
0057 7C98 16FD  14         jne bootlp                  ; repeat if not
0058               ;]
0059               
0060               ;[ initialise console stuff
0061 7C9A 0200  20         li r0,cursrd                ; address of cursor delay
     7C9C A026     
0062 7C9E 04F0  30         clr *r0+                    ; initialise cursor delay
0063 7CA0 0730  30         seto *r0+                   ; enable screen scrolling
0064 7CA2 04F0  30         clr *r0+                    ; zero current x coordinate
0065 7CA4 04F0  30         clr *r0+                    ; zero current y coordinate
0066               
0067                   ; initialise vdp environment
0068                   ; disable interrupts, sound and sprites...
0069                   ;    li r0,>8000                 ; no sprite motion
0070                   ;                                ; no auto sound
0071                   ;                                ; no quit key
0072                   ;    mov r0,@>83c2               ; see page 4 smart programmer
0073                   ;                                ; oct 86-vol 2 issue 5
0074                   ; note: this has now been moved into the intialisation list, below.
0075               ;]
0076               
0077               ;[ load character sets...
0078               chrset
0079                   ; initialise control characters to something visible
0080                   ; we do this by writing the TF logo to ALL 256 characters
0081                   ; later we define the capital and lower case character sets.
0082 7CA6 0200  20 cclop   li r0,>800                  ; address of ascii 0
     7CA8 0800     
0083 7CAA 0207  20         li r7,123                   ; number of characters to write
     7CAC 007B     
0084 7CAE 0201  20 cclop1  li r1,logo                  ; source (TF logo character)
     7CB0 7EC8     
0085 7CB2 0202  20         li r2,8                     ; bytes to copy
     7CB4 0008     
0086 7CB6 06A0  32         bl @_vmbw0                  ; write them
     7CB8 7886     
0087 7CBA 0220  22         ai r0,8                     ; next character
     7CBC 0008     
0088 7CBE 0607  14         dec r7                      ; decrement count
0089 7CC0 16F6  14         jne cclop1                  ; loop if not finished
0090               
0091                   ; load small ascii character set
0092 7CC2 0200  20         li r0,>08ff                 ; vdp address of upper case A
     7CC4 08FF     
0093 7CC6 C800  30         mov r0,@fac                 ; vdp address for small capitals
     7CC8 834A     
0094 7CCA 0420  50         blwp @gpllnk                ; load small capitals character set
     7CCC 7F08     
0095 7CCE 0018             data >0018                  ; gpl command code
0096               
0097                   ; load true lower case characters
0098 7CD0 0200  20         li r0,>b08                  ; vdp address of lower case a
     7CD2 0B08     
0099 7CD4 0201  20         li r1,lowcas                ; source
     7CD6 7DF8     
0100 7CD8 0202  20         li r2,26*8                  ; count
     7CDA 00D0     
0101 7CDC 06A0  32         bl @_vmbw0                  ; write true lower case char set
     7CDE 7886     
0102               
0103               
0104                   ; load miscellaneous characters from data list
0105 7CE0 0201  20         li r1,lbrace                ; address of list
     7CE2 7ED0     
0106 7CE4 04C0  14 lmiscl  clr r0
0107 7CE6 D031  28         movb *r1+,r0                ; get ascii code
0108 7CE8 1308  14         jeq doinv                   ; exit if end of list
0109 7CEA 0950  34         srl r0,5                    ; move to low byte and multiply by 8
0110 7CEC 0220  22         ai r0,>800                  ; add pattern table base address
     7CEE 0800     
0111 7CF0 0202  20         li r2,8                     ; number of bytes to write
     7CF2 0008     
0112 7CF4 06A0  32         bl @_vmbw0                  ; write to vdp
     7CF6 7886     
0113 7CF8 10F5  14         jmp lmiscl
0114               
0115               
0116                   ; initialise inverse characters
0117                   ; ascii codes 144 to 218 are inverse of 48 to 122
0118 7CFA 020D  20 doinv   li r13,>900                 ; vdp source
     7CFC 0900     
0119 7CFE 0206  20         li r6,>c00                  ; vdp destination
     7D00 0C00     
0120 7D02 020E  20         li r14,728                  ; count
     7D04 02D8     
0121 7D06 C00D  18 invlop  mov r13,r0                  ; get source address in r0 for VDP ops
0122 7D08 06A0  32         bl @_vsbr                   ; go read the vdp data (result in R1)
     7D0A 7816     
0123 7D0C 0541  14         inv r1                      ; invert it
0124 7D0E C006  18         mov r6,r0                   ; load destination address
0125 7D10 06A0  32         bl @_vsbw0                  ; write r1 to destination address
     7D12 785E     
0126 7D14 058D  14         inc r13                     ; advance source address
0127 7D16 0586  14         inc r6                      ; advance destination address
0128 7D18 060E  14         dec r14                     ; decrement counter
0129 7D1A 16F5  14         jne invlop                  ; loop until finished
0130               
0131 7D1C 06A0  32         bl @csrdef                  ; define cursor and edge characters
     7D1E 7660     
0132                                                   ; (see 1-11-Editor.a99)
0133               ;]
0134               
0135               ;[ Copy PAD routines into PAD RAM
0136 7D20 06A0  32 cpypad  bl @rstsp                   ; use the restore routine in 1-06-Blocks.a99
     7D22 6B50     
0137               ;]
0138               
0139               ;[ general initialisation - initialised from an address/data list
0140 7D24 0200  20         li r0,adrlst                ; pointer to address/data table
     7D26 7D48     
0141 7D28 0202  20         li r2,41                    ; number of items to load
     7D2A 0029     
0142 7D2C C070  30 nxtdat  mov *r0+,r1                 ; get address to load
0143 7D2E C470  42         mov *r0+,*r1                ; load the address with data
0144 7D30 0602  14         dec r2                      ; finished?
0145 7D32 16FC  14         jne nxtdat                  ; loop if not
0146               ;]
0147               
0148               ;[ set up data and return stacks...
0149 7D34 0204  20         li stack,dstack             ; data stack pointer
     7D36 A2C8     
0150 7D38 0205  20         li rstack,retstk            ; return stack pointer
     7D3A A28C     
0151               
0152 7D3C 04E0  34         clr @spcsvc                 ; clear speech service routine pointer
     7D3E A040     
0153               
0154 7D40 020C  20         li r12,afteri               ; force return point in bank 0
     7D42 6078     
0155 7D44 0460  24         b @retB0                    ; return to caller in bank 0
     7D46 833A     
0156               ;]
0157               
0158               ;[ initialisation data
0159               adrlst
0160 7D48 A05E             data base, 10             ; default number base
     7D4A 000A     
0161 7D4C A024             data keydev, 50           ; default keyboard scan code
     7D4E 0032     
0162 7D50 A030             data ymax, 24             ; 24 rows
     7D52 0018     
0163 7D54 A046             data latest, lastwd       ; last word in the dictionary
     7D56 7F0E     
0164 7D58 A048             data here, prgtop         ; start of compiled code area
     7D5A A2C8     
0165 7D5C A020             data s0, dstack           ; start of data stack
     7D5E A2C8     
0166 7D60 A022             data rs0, retstk          ; start of return stack
     7D62 A28C     
0167 7D64 A01C             data ffailm, >2000        ; first free address in low memory
     7D66 2000     
0168 7D68 A01E             data ffaihm, himem        ; first free address in high memory
     7D6A A2C8     
0169 7D6C FFFC             data >fffc, wkspc         ; pointer to workspace for load-interrupt
     7D6E 8300     
0170 7D70 FFFE             data >fffe, startB0       ; pointer to start of code for load-interrupt
     7D72 606C     
0171 7D74 A070             data retbnk, >6002        ; return to bank 1
     7D76 6002     
0172 7D78 A04C             data tibsiz, 80           ; 80 characters input buffer length
     7D7A 0050     
0173 7D7C A1D0             data tibadr, tib          ; location of input buffer
     7D7E 3420     
0174                                                 ; (defined in 0-23-System.a99)
0175 7D80 A050             data doboot, 1            ; booting flag (default:on)
     7D82 0001     
0176 7D84 A052             data sdelim, '"'*256      ; default string delimiter character
     7D86 2200     
0177 7D88 A1B2             data totblk, blocks       ; default number of block buffers available
     7D8A 0006     
0178 7D8C A000             data intvec, intgo        ; default vector for interpret
     7D8E 730A     
0179 7D90 A002             data blkvec, block2       ; default vector for block
     7D92 7BA6     
0180 7D94 A004             data numvec, numbr1       ; default vector for number
     7D96 6B84     
0181 7D98 A006             data fndvec, vfind        ; default vector for find
     7D9A 6AE6     
0182 7D9C A1AC             data falloc, f1pab        ; address of pab for 1st file
     7D9E 1800     
0183 7DA0 A1AE             data falloc+2, f2pab      ; address of pab for 2nd file
     7DA2 1928     
0184 7DA4 A1B0             data falloc+4, f3pab      ; address of pab for 3rd file
     7DA6 1A50     
0185 7DA8 A00E             data gplvec, gpllnk       ; pointer to gpllnk
     7DAA 7F08     
0186 7DAC A010             data padvec, rstsp        ; pointer to scratchpad code in bank 1
     7DAE 6B50     
0187 7DB0 A068             data _WARN, -1            ; default value for warn
     7DB2 FFFF     
0188 7DB4 83C4             data isr, runisr          ; pointer to isr launcher in pad
     7DB6 834C     
0189 7DB8 A012             data wp, >8300            ; initial workspace pointer
     7DBA 8300     
0190 7DBC A014             data pnext, _next         ; address of next
     7DBE 8326     
0191 7DC0 A00C             data dsrvec, dsrlnk       ; load pointer to DSRLNK vector
     7DC2 6A40     
0192 7DC4 A016             data pdocon, docon        ; load pointer to DOCON's executable code
     7DC6 700E     
0193 7DC8 A018             data pcreate, crtime      ; load pointer to CREATE's executable code
     7DCA 6FA8     
0194 7DCC A00A             data kdel, >ed1e          ; auto-repeat delay for block editor
     7DCE ED1E     
0195                   ; VDP block buffer addresses for disk block IO...
0196 7DD0 A1BA             data blk0+2, bufadd+>1400 ; vdp address of buffer 0
     7DD2 3020     
0197 7DD4 A1BE             data blk0+6, bufadd+>1000 ; vdp address of buffer 1
     7DD6 2C20     
0198 7DD8 A1C2             data blk0+10,bufadd+>c00  ; vdp address of buffer 2
     7DDA 2820     
0199 7DDC A1C6             data blk0+14,bufadd+>800  ; vdp address of buffer 3
     7DDE 2420     
0200 7DE0 A1CA             data blk0+18,bufadd+>400  ; vdp address of buffer 4
     7DE2 2020     
0201 7DE4 A1CE             data blk0+22,bufadd       ; vdp address of buffer 5
     7DE6 1C20     
0202 7DE8 83C2             data >83c2, 0             ; ISR mask (everything off)
     7DEA 0000     
0203               
0204                   ; boot filename - system looks for this file on startup and attempts to load
0205                   ; from block 1 if found. holding any key supresses this behaviour ala XB.
0206 7DEC 0B       bootfn  byte 11 ; length
0207 7DED   44             text 'DSK1.BLOCKS'        ; file to boot from
     7DEE 534B     
     7DF0 312E     
     7DF2 424C     
     7DF4 4F43     
     7DF6 4B53     
0208                       even
0209               
0210               lowcas
0211                   ; funnelweb editor lower case font:
0212 7DF8 0000             data >0000,>3808,>7848,>7c00
     7DFA 3808     
     7DFC 7848     
     7DFE 7C00     
0213 7E00 4040             data >4040,>7844,>4444,>7800
     7E02 7844     
     7E04 4444     
     7E06 7800     
0214 7E08 0000             data >0000,>3844,>4040,>3c00
     7E0A 3844     
     7E0C 4040     
     7E0E 3C00     
0215 7E10 0404             data >0404,>3c44,>4444,>3c00
     7E12 3C44     
     7E14 4444     
     7E16 3C00     
0216 7E18 0000             data >0000,>3844,>7c40,>3c00
     7E1A 3844     
     7E1C 7C40     
     7E1E 3C00     
0217 7E20 1C20             data >1c20,>7820,>2020,>2000
     7E22 7820     
     7E24 2020     
     7E26 2000     
0218 7E28 0000             data >0000,>3c44,>443c,>0438
     7E2A 3C44     
     7E2C 443C     
     7E2E 0438     
0219 7E30 4040             data >4040,>7844,>4444,>4400
     7E32 7844     
     7E34 4444     
     7E36 4400     
0220 7E38 1000             data >1000,>3010,>1010,>3800
     7E3A 3010     
     7E3C 1010     
     7E3E 3800     
0221 7E40 0800             data >0800,>1808,>0808,>4830
     7E42 1808     
     7E44 0808     
     7E46 4830     
0222 7E48 2020             data >2020,>2428,>3028,>2400
     7E4A 2428     
     7E4C 3028     
     7E4E 2400     
0223 7E50 3010             data >3010,>1010,>1010,>3800
     7E52 1010     
     7E54 1010     
     7E56 3800     
0224 7E58 0000             data >0000,>7854,>5454,>5400
     7E5A 7854     
     7E5C 5454     
     7E5E 5400     
0225 7E60 0000             data >0000,>7844,>4444,>4400
     7E62 7844     
     7E64 4444     
     7E66 4400     
0226 7E68 0000             data >0000,>3844,>4444,>3800
     7E6A 3844     
     7E6C 4444     
     7E6E 3800     
0227 7E70 0000             data >0000,>7844,>4478,>4040
     7E72 7844     
     7E74 4478     
     7E76 4040     
0228 7E78 0000             data >0000,>3c44,>443c,>0404
     7E7A 3C44     
     7E7C 443C     
     7E7E 0404     
0229 7E80 0000             data >0000,>5c60,>4040,>4000
     7E82 5C60     
     7E84 4040     
     7E86 4000     
0230 7E88 0000             data >0000,>3c40,>3804,>7800
     7E8A 3C40     
     7E8C 3804     
     7E8E 7800     
0231 7E90 0020             data >0020,>7820,>2024,>1800
     7E92 7820     
     7E94 2024     
     7E96 1800     
0232 7E98 0000             data >0000,>4444,>4444,>3c00
     7E9A 4444     
     7E9C 4444     
     7E9E 3C00     
0233 7EA0 0000             data >0000,>4444,>2828,>1000
     7EA2 4444     
     7EA4 2828     
     7EA6 1000     
0234 7EA8 0000             data >0000,>4444,>5454,>2800
     7EAA 4444     
     7EAC 5454     
     7EAE 2800     
0235 7EB0 0000             data >0000,>4428,>1028,>4400
     7EB2 4428     
     7EB4 1028     
     7EB6 4400     
0236 7EB8 0000             data >0000,>4424,>1808,>1020
     7EBA 4424     
     7EBC 1808     
     7EBE 1020     
0237 7EC0 0000             data >0000,>7c08,>1020,>7c00
     7EC2 7C08     
     7EC4 1020     
     7EC6 7C00     
0238               
0239 7EC8 00E0     logo    data >00e0,>405c,>5018,>1000    ; represents control characters
     7ECA 405C     
     7ECC 5018     
     7ECE 1000     
0240               
0241                       ; left curly brace  (123) {
0242 7ED0 7B       lbrace  byte '{'
0243 7ED1   18             byte >18,>20,>20,>40,>20,>20,>18,>00
     7ED2 2020     
     7ED4 4020     
     7ED6 2018     
     7ED8 00       
0244               
0245                       ; bar character     (124) |
0246 7ED9   7C             byte '|'
0247 7EDA 1010             byte >10,>10,>10,>00,>10,>10,>10,>00
     7EDC 1000     
     7EDE 1010     
     7EE0 1000     
0248               
0249                       ; right curly brace (125) }
0250 7EE2 7D               byte '}'
0251 7EE3   30             byte >30,>08,>08,>04,>08,>08,>30,>00
     7EE4 0808     
     7EE6 0408     
     7EE8 0830     
     7EEA 00       
0252               
0253                       ; tilde             (126) ~
0254 7EEB   7E             byte '~'
0255 7EEC 0000             byte >00,>00,>20,>54,>08,>00,>00,>00
     7EEE 2054     
     7EF0 0800     
     7EF2 0000     
0256               
0257                       ; slashed zero
0258 7EF4 30               byte '0'
0259 7EF5   38     zerochr byte >38,>4c,>54,>54,>54,>64,>38,>00
     7EF6 4C54     
     7EF8 5454     
     7EFA 6438     
     7EFC 00       
0260               
0261                       ; circular O
0262 7EFD   4F             byte 'O'
0263 7EFE 3844     ochar   byte >38,>44,>44,>44,>44,>44,>38,>00
     7F00 4444     
     7F02 4444     
     7F04 3800     
0264 7F06 00               byte 0 ; end of list
0265                       even
0266               ;]
0267               
0268               ;[ GPLLNK
0269               ; This routine is based on the routine published in the July 1986 edition of
0270               ; Smart Programmer. Modified by yours truly to allow it be executed from ROM.
0271      83E0     gplws   equ >83e0                   ; GPL workspace
0272      83E8     gr4     equ gplws+8                 ; GPL R4
0273      83EC     gr6     equ gplws+12                ; GPL R6
0274      8373     stkpnt  equ >8373                   ; GPL stack pointer
0275      0060     ldgadd  equ >60                     ; load and execute grom address entry point
0276      200E     xtab27  equ >200e                   ; low mem XML table location 27
0277      166C     getstk  equ >166c
0278               
0279               ; cpu register data - this data is copied into >200e onwards, so that it sits
0280               ; in R7 onwards
0281 7F08 2000     gpllnk  data glnkws                 ; [mapped to R7] set up BLWP vectors
0282 7F0A 7F12             data glink1                 ; [mapped to R8]
0283 7F0C 7F44     rtnad   data xmlrtn                 ; [mapped to R9]
0284 7F0E 176C     gxmlad  data >176c                  ; [mapped to R10] GROM address for GPL XML 0F27
0285                                                   ; opcode
0286 7F10 0050             data >50                    ; [mapped to R11] Initialised to >50 where
0287                                                   ; PUTSTK address resides
0288               
0289               ; this routine runs in it's own workspace, starting at >2000
0290      2000     glnkws  equ >2000                   ; GPLLNKs workspace of which only registers
0291                                                   ; R7 thru R15 are used
0292               
0293 7F12 0200  20 glink1  li r0,gpllnk                ; we need to copy the cpu register data
     7F14 7F08     
0294 7F16 0201  20         li r1,>200e                 ; (above) to RAM. R0=Source, R1=Destination
     7F18 200E     
0295 7F1A CC70  46 gpllop  mov *r0+,*r1+               ; copy the data above into r7
0296 7F1C CC70  46         mov *r0+,*r1+               ; copy the data above into r8
0297 7F1E CC70  46         mov *r0+,*r1+               ; copy the data above into r9
0298 7F20 CC70  46         mov *r0+,*r1+               ; copy the data above into r10
0299 7F22 CC70  46         mov *r0+,*r1+               ; copy the data above into r11
0300 7F24 C81B  38         mov *r11,@gr4               ; put PUTSTK address into R4 of GPL WS
     7F26 83E8     
0301 7F28 C83E  42         mov *r14+,@gr6              ; put GPL routine address in r6 of GPL WS
     7F2A 83EC     
0302 7F2C C809  38         mov r9,@xtab27              ; put XMLRTN address into >200e
     7F2E 200E     
0303 7F30 02E0  18         lwpi gplws                  ; load GPL workspace
     7F32 83E0     
0304 7F34 0694  24         bl *r4                      ; save current GROM address on stack
0305 7F36 C920  54         mov @gxmlad,@>8302(r4)      ; push GPL XML address on stack for GPL ret
     7F38 7F0E     
     7F3A 8302     
0306 7F3C 05E0  26         inct @stkpnt                ; adjust the stack pointer
     7F3E 8373     
0307 7F40 0460  24         b @ldgadd                   ; execute our GPL routine
     7F42 0060     
0308 7F44 C120  30 xmlrtn  mov @getstk,r4              ; get GETSTK pointer
     7F46 166C     
0309 7F48 0694  24         bl *r4                      ; restore GROM address off the stack
0310 7F4A 02E0  18         lwpi glnkws                 ; load our ws
     7F4C 2000     
0311 7F4E 0380  30         rtwp                        ; all done - return to caller
0312               ;]
0313               
0314               ;[ Check boot device routine
0315               ; this routine is called from 0-01-Startup.a99 to modify the disk boot device
0316               ; from DSK1 to DSKx where x is the ascii character of the key held down during
0317               ; cartridge boot-up
0318 7F50 C014  38 _cboot  mov *stack,r0               ; get key-code from the stack
0319 7F52 0280  26         ci r0,13                    ; enter pressed?
     7F54 000D     
0320 7F56 1602  14         jne cboot1                  ; jump if not
0321 7F58 04D4  30         clr *stack                  ; enter was pressed. zero top of stack to
0322                                                   ; supress auto loading.
0323 7F5A 1006  14         jmp cbootx                  ; return
0324 7F5C 0280  26 cboot1  ci r0,-1                    ; nothing pressed?
     7F5E FFFF     
0325 7F60 1303  14         jeq cbootx                  ; if nothing pressed then exit routine
0326 7F62 0A80  48         sla r0,8                    ; otherwise move key code move to high byte
0327 7F64 D800  42         movb r0,@pabfil+3           ; place the digit in cpu PAB
     7F66 A18F     
0328 7F68 0460  24 cbootx  b @retB0
     7F6A 833A     
0329               ;]
0330               
0331               ;[
0332               ; ***************************************************
0333               ; The following routines are copied to PAD on startup
0334               ; ***************************************************
0335               ;DOCOL
0336               ; Executes a high-level colon definition.
0337               ; Saves return address on the return stack, loads new execution thread and
0338               ; drops down into NEXT to begin executing the thread.
0339               ; Note: These three routines are actually copied to scratchpad ram for extra
0340               ; speed. See the equates below for their addresses in PAD
0341               
0342      8320     docol   equ >8320                   ; address of this routine in PAD
0343 7F6C 0645  22 toRAM   dect rstack                 ; make space on return stack
0344 7F6E C543  38         mov pc,*rstack              ; save PC to return stack
0345 7F70 C0C6  30         mov r6,pc                   ; place in PC and drop down to NEXT
0346               
0347               ;NEXT
0348               ; loads the next CFA and branches to the address in the CFA.
0349      8326     _next   equ docol+6                 ; 8326 address of this routine in PAD
0350 7F72 C1B3  46         mov *pc+,r6                 ; get CFA in r6
0351 7F74 C1F6  46         mov *r6+,r7                 ; get contents of CFA
0352 7F76 0457  24         b *r7                       ; execute it
0353               
0354               ;EXIT
0355               ; exits from a FORTH high level word (i.e. a word entered with DOCOL)
0356      832C     exit    equ _next+6                 ; 832c address of this routine in PAD
0357 7F78 832E             data exit+2                 ; called by NEXT, so needs a pointer
0358 7F7A C0F5  46         mov *rstack+,pc             ; place saved PC into PC & pop return stack
0359 7F7C 045C  24         b *next                     ; do next instruction
0360               
0361               ;BANK1
0362               ; routine to perform a bank switch and branch
0363      8332     bank1   equ exit+6                  ; 8332 address of this routine in PAD
0364 7F7E C2DB  38         mov *r11,r11                ; get branch address
0365 7F80 04E0  34         clr @>6000                  ; select bank 1
     7F82 6000     
0366 7F84 045B  24         b *r11                      ; branch to the desired address
0367               
0368               ;RETB0
0369               ; routine to return to a calling routine in bank 0
0370      833A     retB0   equ bank1+8                 ; 833a address of this routine in PAD
0371 7F86 04E0  34 cpypnt  clr @>6002                  ; select bank 0
     7F88 6002     
0372 7F8A 045C  24         b *next
0373               
0374               
0375               ; speech synth status routine
0376      8340     spstat  equ retB0+6
0377 7F8C D820  46         movb @spchrd,@spdata        ; 8340 move data from synth to memory
     7F8E 9000     
     7F90 834A     
0378 7F92 0BC0  48         src r0,12                   ; wait 12uS - see editor assembler page 349,
0379                                                   ; paragraph 5.
     **** ****     > RT
0001 7F94 045B  24        b * r11
                   < 1-16-Initialise.asm
0381               ; the speech synth status will be placed into the following memory location:
0382      834A     spdata  equ spstat+10
     **** ****     > NOP
0001 7F96 1000  14        jmp $+2
                   < 1-16-Initialise.asm
0384               
0385               ; routine to call the ISRs in bank1 (actually located 'in' FAC)
0386      834C     runisr  equ spdata+2
0387 7F98 04E0  34         clr @>6000                  ; 834c select bank 1
     7F9A 6000     
0388 7F9C 0460  28         b @isrdes                   ; jump to ISR despatch handler in bank 1
     7F9E 6078     
0389               
0390               ; ISR return code - select appropriate bank and resume
0391      8354     isrxit  equ runisr+8
0392 7FA0 C020  42         mov @retbnk,r0              ; 8354 get bank to return to
     7FA2 A070     
0393 7FA4 04D0  30         clr *r0                     ; select that bank
0394 7FA6 045A  24         b *r10                      ; return to console ISR routine in console
0395                                                   ; ROM
0396               
0397               ; SWAP - runs from high-speed RAM
0398      835C     _swap   equ isrxit+8
0399 7FA8 C1D4  38         mov *stack,r7               ; 835c save TOS
0400 7FAA C524  54         mov @2(stack),*stack        ; move TOS-1 to TOS
     7FAC 0002     
0401 7FAE C907  46         mov r7,@2(stack)            ; move previous TOS to TOS-1
     7FB0 0002     
0402 7FB2 045C  24         b *next                     ;
0403               
0404               ; LIT - runs from high-speed RAM
0405      8368     _lit    equ _swap+12
0406 7FB4 0644  22         dect stack                  ; 8368 create space on the data stack
0407 7FB6 C533  54         mov *pc+,*stack             ; push in-line number to data stack
0408 7FB8 045C  24         b *next
0409               
0410               ; DUP - runs from high-speed RAM
0411      8382     _dup    equ _lit+26 ; >8382         ; (jump over TI reserved PAD locations)
0412 7FBA 0644  22 __dup   dect stack                  ; 8382 create stack entry
0413 7FBC C524  54         mov @2(stack),*stack        ; mov word @ TOS+1 to TOS
     7FBE 0002     
0414 7FC0 045C  24         b *next                     ;
0415               
0416               ; DROP - runs from high-speed RAM
0417      838A     _drop   equ _dup+8 ; >8388
0418 7FC2 05C4  22         inct stack                  ; 8388 pop stack
0419 7FC4 045C  24         b *next                     ; return
0420               
0421               ; OVER - runs from high-speed RAM
0422      838E     _over   equ _drop+4 ; >838c
0423 7FC6 0644  22         dect stack                  ; 838c move forward one stack position
0424 7FC8 C524  54         mov @4(stack),*stack        ; copy x1 to TOS
     7FCA 0004     
0425 7FCC 045C  24         b *next                     ;
0426               
0427               ; 1+ - runs from high-speed RAM
0428      8396     _plus1  equ _over+8 ; >8394
0429 7FCE 0594  30         inc *stack                  ; 8394 increment contents of data stack by 1
0430 7FD0 045C  24         b *next                     ;
0431               
0432               ; 2+ - runs from high-speed RAM
0433      839A     _plus2  equ _plus1+4 ;
0434 7FD2 05D4  30         inct *stack                 ; 839c increment contents of data stack by 2
0435 7FD4 045C  24         b *next                     ;
0436               
0437               ; 2- - runs from high-speed RAM
0438      839E     _sub2   equ _plus2+4 ;
0439 7FD6 0654  30         dect *stack                 ; 83a0 decrement contents of data stack by 2
0440 7FD8 045C  24         b *next                     ;
0441               
0442               ; + - runs from high-speed RAM
0443      83A2     _add    equ _sub2+4 ;
0444 7FDA A534  54         a *stack+,*stack            ; 83a4 pop tos and add to datastack-1
0445 7FDC 045C  24         b *next                     ;
0446               
0447               ; - - runs from high-speed RAM
0448      83A6     _sub    equ _add+4 ;
0449 7FDE 6534  54         s *stack+,*stack            ; 83a8 pop tos and subtract from datastack-1
0450 7FE0 045C  24         b *next                     ;
0451               
0452               ; * - runs from high-speed RAM
0453      83AA     _mul    equ _sub+4 ;
0454 7FE2 C224  46         mov @2(stack),r8            ; 83ac word under TOS into r8
     7FE4 0002     
0455 7FE6 3A34  90         mpy *stack+,r8              ; pop tos and multiply by r8
0456                                                   ; (lsw of result in r9)
0457 7FE8 C509  38         mov r9,*stack               ; place result onto data stack
0458 7FEA 045C  24         b *next
0459               
0460               ; 0BRANCH
0461      83B4     _zbrnch equ _mul+10
0462                       ; at entry, R3 is pointing at the branch address...
0463 7FEC C034  46         mov *stack+,r0              ; 83b6 test and pop flag
0464 7FEE 1602  14         jne zbq                     ; if NOT zero, remove from stack and quit
0465 7FF0 C0D3  38         mov *pc,pc                  ; stack was zero, we're taking the jump...
0466                                                   ; move address to instruction pointer
0467 7FF2 045C  24         b *next
0468 7FF4 05C3  22 zbq     inct pc                     ; otherwise move past address
0469 7FF6 045C  24         b *next
0470               padend                              ; end of secod source block
0471                                                   ; end of copy to PAD section
0472               ;]
                   < build.asm
0054                   copy "./bank1/1-17-End.asm"
     **** ****     > ./bank1/1-17-End.asm
0001               ;  _______ _    _ ______    ______ _   _ _____    _
0002               ; |__   __| |  | |  ____|  |  ____| \ | |  __ \  | |
0003               ;    | |  | |__| | |__     | |__  |  \| | |  | | | |
0004               ;    | |  |  __  |  __|    |  __| | . ` | |  | | | |
0005               ;    | |  | |  | | |____   | |____| |\  | |__| | |_|
0006               ;    |_|  |_|  |_|______|  |______|_| \_|_____/  (_)
0007               
0008                       even
0009               ;        text 'Sheila'
0010                       even
0011      7FF8     endB1   equ $                       ; end of bank 1 marker
0012                       end                         ; so long, and thanks for all the fish
                   < build.asm

    AB0RT............... >7460 :     
    AB0RTH.............. >7456 :     
    ABORT............... >742E :     
    ABORTH.............. >7424 :     
    ABORT_.............. >744E :     
    ABSH................ >63E0 :     
    ABS_................ >63E8 :     
    ABTTXT.............. >7428 :     
    ADD................. >6310 :     
    ADDH................ >630A :     
    ADDTOH.............. >7064 :     
    ADDTOX.............. >707C :     
    ADRLST.............. >7D48 :     
    AFTERI.............. >6078 :     
    AGAIN............... >6692 :     
    AGAINH.............. >6688 :     
    AHEAD............... >6556 :     
    ALIGN............... >70F2 :     
    ALIGNH.............. >70E8 :     
    ALLFIN.............. >71EA :     
    ALLOT............... >70A8 :     
    ALLOTH.............. >709E :     
    ALTCFA.............. >6FAE :     
    AND................. >67C4 :     
    ANDH................ >67BC :     
    ASCII............... >78C8 :     
    ASCII0.............. >7735 :     
    ASCII1.............. >773D :     
    ASCII2.............. >7745 :     
    ASCII3.............. >774D :     
    ASCII4.............. >7755 :     
    ASCII5.............. >775D :     
    ASCII6.............. >7765 :     
    ASCII7.............. >776D :     
    ASCIIH.............. >78BE :     
    ASCIIX.............. >78D6 :     
    AUTORL.............. >A086 :     
    AUTORP.............. >A084 :     
    BACK1............... >6A22 :     
    BACK2............... >6A26 :     
    BADBK1.............. >73B6 :     
    BADBLK.............. >73AA :     
    BALTXT.............. >7582 :     
    BANK0............... >6068 :     
    BANK1............... >8332 :     
    BANK1_.............. >606A :     
    BASE................ >A05E :     
    BASEH............... >76E4 :     
    BASE_............... >76EC :     
    BCLEAN.............. >7CBC :     
    BEGCNT.............. >A088 :     
    BEGERR.............. >71DA :     
    BEGIN............... >6662 :     
    BEGINH.............. >6658 :     
    BEGTXT.............. >756A :     
    BFREE............... >6A00 :     
    BIT1................ >6960 :     
    BITMSK.............. >79C8 :     
    BLCTXT.............. >75A9 :     
    BLH................. >6AC4 :     
    BLK................. >7B50 :     
    BLK0................ >A1B8 :     
    BLK1................ >A1BC :     
    BLK2................ >A1C0 :     
    BLK3................ >A1C4 :     
    BLK4................ >A1C8 :     
    BLK5................ >A1CC :     
    BLKERR.............. >67FC :     
    BLKFB............... >67A2 :     
    BLKH................ >7B48 :     
    BLKMSG.............. >75BD :     
    BLKNIM.............. >679A :     
    BLKNUM.............. >A1B4 :     
    BLKNXT.............. >67CE :     
    BLKQ................ >7CF0 :     
    BLKQH............... >7CE8 :     
    BLKTXT.............. >7716 :     
    BLKVEC.............. >A002 :     
    BLNKLN.............. >6EF6 :     
    BLOAD1.............. >7DE8 :     
    BLOAD2.............. >7E26 :     
    BLOADH.............. >7DDC :     
    BLOCK............... >7B9A :     
    BLOCK2.............. >7BA6 :     
    BLOCKH.............. >7B90 :     
    BLOCKS.............. >0006 :     
    BL_................. >6ACA :     
    BNFB................ >67F2 :     
    BOOTFN.............. >7DEC :     
    BOOTLP.............. >7C94 :     
    BOOTUP.............. >60D4 :     
    BRANCH.............. >65D6 :     
    BREAK............... >6C56 :     
    BREAK1.............. >6C6E :     
    BREAKH.............. >6C4C :     
    BRKMSG.............. >6C70 :     
    BRNCHH.............. >65CC :     
    BSAVE............... >7D76 :     
    BSAVE1.............. >7D80 :     
    BSAVE2.............. >7DBA :     
    BSAVEH.............. >7D6C :     
    BUF................. >7D00 :     
    BUFADD.............. >1C20 :     
    BUFH................ >7CF8 :     
    BUFRPT.............. >691E :     
    BUFXIT.............. >693E :     
    BUMPY............... >6A2C :     
    BYE................. >6F32 :     
    BYEH................ >6F2A :     
    CALCSR.............. >7406 :     
    CASCHK.............. >6B50 :     
    CASCNT.............. >A084 :     
    CASE................ >65F2 :     
    CASEH............... >65EA :     
    CASERR.............. >71BA :     
    CASOUT.............. >6B6C :     
    CASSEN.............. >A058 :     
    CASTXT.............. >7554 :     
    CBA................. >69DA :     
    CBOOT............... >6108 :     
    CBOOT1.............. >7F5C :     
    CBOOTX.............. >7F68 :     
    CCLOP............... >7CA6 :     
    CCLOP1.............. >7CAE :     
    CCOMMA.............. >70E0 :     
    CCOMMH.............. >70DA :     
    CCP................. >6F18 :     
    CELLP............... >62CC :     
    CELLPH.............. >62C2 :     
    CELLS............... >62F8 :     
    CELLSH.............. >62EE :     
    CFA................. >6BF4 :     
    CFAH................ >6BEC :     
    CFLASH.............. >6E1C :     
    CHAR................ >78B4 :     
    CHARH............... >78AC :     
    CHARP............... >62D8 :     
    CHARPH.............. >62CE :     
    CHARS............... >6896 :     
    CHARSH.............. >688C :     
    CHK80............... >730E :     
    CHKCNC.............. >6318 :     
    CHKENT.............. >6FC0 :     
    CHKNUM.............. >734C :     
    CHKROW.............. >630E :     
    CHRFH............... >685A :     
    CHRFTC.............. >6860 :     
    CHRSET.............. >7CA6 :     
    CLC................. >60AA :     
    CLEAN............... >7366 :     
    CLEAN1.............. >738C :     
    CLEANH.............. >7CB2 :     
    CLIPX............... >6DB6 :     
    CLIPX2.............. >726E :     
    CLIPXG.............. >722E :     
    CLIPXH.............. >722A :     
    CLIPXL.............. >725E :     
    CLIPYG.............. >728E :     
    CLIPYH.............. >72BA :     
    CLIPYL.............. >7294 :     
    CLOAD............... >7C60 :     
    CLOAD1.............. >7C70 :     
    CLOADH.............. >7C56 :     
    CLOSE............... >0001 :     
    CLRLOP.............. >7C78 :     
    CLS................. >6D70 :     
    CLSALL.............. >7492 :     
    CLSH................ >6D68 :     
    CMOVE............... >6984 :     
    CMOVEH.............. >697A :     
    CMOVF............... >6996 :     
    CMOVFH.............. >698C :     
    CMOVLP.............. >6616 :     
    CMVEXT.............. >6638 :     
    CMVFLP.............. >662E :     
    CNGTXT.............. >772D :     
    CNRDAT.............. >753A :     
    CNXTCH.............. >6B08 :     
    CODEH............... >714E :     
    CODING.............. >A06A :     
    COINC............... >7A3C :     
    COINCH.............. >7A32 :     
    COINCX.............. >632A :     
    COL32D.............. >622E :     
    COL40D.............. >6224 :     
    COL80D.............. >6238 :     
    COLD................ >6166 :     
    COLDH............... >615C :     
    COLNAM.............. >74C4 :     
    COLNM1.............. >74D8 :     
    COLON............... >711C :     
    COLONH.............. >7116 :     
    COLOR............... >7A4E :     
    COLORH.............. >7A44 :     
    COMBRA.............. >60A2 :     
    COMMA............... >70D2 :     
    COMMAH.............. >70CC :     
    COMMAX.............. >6D66 :     
    COMPIH.............. >7256 :     
    COMPILE............. >7262 :     
    COMXIT.............. >6C1A :     
    CONST............... >7002 :     
    CONSTH.............. >6FF6 :     
    CONT................ >697C :     
    COPYW............... >69C2 :     
    COPYWH.............. >69B8 :     
    COPYWL.............. >6644 :     
    CORNER.............. >7518 :     
    COUNT............... >78E2 :     
    COUNTH.............. >78D8 :     
    CPL................. >7658 :     
    CPLH................ >7650 :     
    CPYPAD.............. >7D20 :     
    CPYPNT.............. >7F86 :     
    CR.................. >6E8C :     
    CREATE.............. >6F9E :     
    CREATH.............. >6F94 :     
    CREXIT.............. >6EA0 :     
    CRH................. >6E86 :     
    CRNLP............... >751C :     
    CRTIME.............. >6FA8 :     
    CRTLP............... >6D34 :     
    CSING............... >73A4 :     
    CSR1................ >7400 :     
    CSRDEF.............. >7660 :     
    CSRFLG.............. >A082 :     
    CSROFF.............. >73E8 :     
    CSRON............... >73E2 :     
    CSRWRT.............. >6E48 :     
    CSRX................ >A07E :     
    CSRY................ >A080 :     
    CSTART.............. >60D2 :     
    CURSRD.............. >A026 :     
    CVA................. >7C70 :     
    DATA1............... >7AE0 :     
    DATA2............... >7AEC :     
    DATA8............... >6B4A :     
    DATAH............... >7AC2 :     
    DATCR............... >6A66 :     
    DCHAR............... >7996 :     
    DCHARH.............. >798C :     
    DECH................ >77C0 :     
    DECI................ >77CC :     
    DECMAL.............. >6B4C :     
    DELAY............... >7658 :     
    DELKEY.............. >0003 :     
    DEPTH............... >623E :     
    DEPTHH.............. >6234 :     
    DFA................. >6C20 :     
    DFA1................ >6C26 :     
    DFAFND.............. >6C48 :     
    DFAH................ >6C16 :     
    DIRTIH.............. >7CD6 :     
    DIRTY............... >7CCE :     
    DIRTYH.............. >7CC4 :     
    DIRTYQ.............. >7CE0 :     
    DISKIO.............. >6A1A :     
    DISUPD.............. >768A :     
    DIV2................ >6300 :     
    DIV2H............... >62FA :     
    DLENTR.............. >6A44 :     
    DLY42............... >611C :     
    DLYLOP.............. >765A :     
    DO.................. >66E8 :     
    DO1................. >66CC :     
    DO1H................ >66C6 :     
    DOBOOT.............. >A050 :     
    DOCFL............... >6FA4 :     
    DOCMD1.............. >7B9C :     
    DOCNT............... >A080 :     
    DOCOL............... >8320 :     
    DOCON............... >700E :     
    DODCMD.............. >7B92 :     
    DODIG............... >6ED0 :     
    DODIV............... >6E9E :     
    DODOES.............. >6FBA :     
    DOERR............... >71AA :     
    DOERTX.............. >754A :     
    DOES................ >6FEA :     
    DOESH............... >6FE0 :     
    DOH................. >66E0 :     
    DOINS............... >7358 :     
    DOINS1.............. >7380 :     
    DOINSX.............. >73AC :     
    DOINV............... >7CFA :     
    DOMARK.............. >6F88 :     
    DOPTO............... >708A :     
    DOSIGN.............. >A066 :     
    DOT................. >782C :     
    DOT1................ >7830 :     
    DOTH................ >7826 :     
    DOTO................ >705C :     
    DOTOH............... >7054 :     
    DOTR................ >7850 :     
    DOTRH............... >784A :     
    DOTS................ >624C :     
    DOTS1............... >625E :     
    DOTSIN.............. >A05C :     
    DOTST............... >6270 :     
    DOTTXT.............. >6276 :     
    DOVAR............... >7746 :     
    DOVDP2.............. >6216 :     
    DPL................. >A056 :     
    DRAWD............... >7424 :     
    DRAWS............... >7476 :     
    DROP................ >6170 :     
    DROP2............... >75D2 :     
    DROP2H.............. >75C8 :     
    DROPH............... >6168 :     
    DSRDT8.............. >6B30 :     
    DSRDTA.............. >6B34 :     
    DSRLNK.............. >6A40 :     
    DSRLWS.............. >A158 :     
    DSRVEC.............. >A00C :     
    DSTACK.............. >A2C8 :     
    DSTYPE.............. >A162 :     
    DUP................. >6184 :     
    DUP0H............... >61F2 :     
    DUP2................ >75E0 :     
    DUP2H............... >75D8 :     
    DUPH................ >617C :     
    ECODE............... >7176 :     
    ECODEH.............. >716C :     
    EDBLK............... >A088 :     
    EDF4................ >71D4 :     
    EDIT................ >7F16 :     
    EDIT0............... >7F2E :     
    EDIT1............... >7F58 :     
    EDIT3............... >7F5C :     
    EDITH............... >7F0E :     
    EDML2............... >6F6A :     
    EDML3............... >6F7E :     
    EDML4............... >6F6E :     
    EDML5............... >6F86 :     
    EDML6............... >6F92 :     
    EDML7............... >6F9C :     
    EDNEXT.............. >7470 :     
    ELSE................ >65BE :     
    ELSEH............... >65B6 :     
    EMIT................ >6D92 :     
    EMITH............... >6D8A :     
    EMITX............... >6DC6 :     
    EMIT_............... >6D9A :     
    ENDB0............... >7FF4 :     
    ENDB1............... >7FF8 :     
    ENDCAH.............. >6632 :     
    ENDCAS.............. >663E :     
    ENDOF............... >6626 :     
    ENDOFH.............. >661C :     
    EPAGE............... >A07C :     
    EQ.................. >646C :     
    EQH................. >6466 :     
    EQZ................. >64C4 :     
    EQZH................ >64BE :     
    ERRNUM.............. >A03A :     
    ERROR............... >751C :     
    ERRTXT.............. >757B :     
    ERRXIT.............. >74F4 :     
    EVAL................ >6B98 :     
    EVALH............... >6B8C :     
    EXECUT.............. >72AA :     
    EXEH................ >729E :     
    EXIT................ >832C :     
    EXITH............... >6110 :     
    EXITT............... >6118 :     
    EXP1................ >6A54 :     
    EXP2................ >6A5C :     
    EXPCNT.............. >A062 :     
    EXPCTH.............. >69CA :     
    EXPECT.............. >69D4 :     
    EXPNXT.............. >69E4 :     
    EXROLL.............. >7918 :     
    F1BUF............... >1828 :     
    F1EOL............... >7164 :     
    F1PAB............... >1800 :     
    F2BUF............... >1950 :     
    F2PAB............... >1928 :     
    F3BUF............... >1A78 :     
    F3PAB............... >1A50 :     
    F7EXIT.............. >71CC :     
    FAC................. >834A :     
    FADDPH.............. >682A :     
    FALLOC.............. >A1AC :     
    FALSE............... >77F0 :     
    FALSEH.............. >77E6 :     
    FBLOCK.............. >7C4A :     
    FBUF................ >7E54 :     
    FBUFH............... >7E4A :     
    FCLOSE.............. >7E7C :     
    FCLOSH.............. >7E72 :     
    FDOCHR.............. >7960 :     
    FDODIG.............. >7986 :     
    FDONE............... >79B4 :     
    FEOF................ >7EF4 :     
    FEOFH............... >7EEA :     
    FETCH............... >6822 :     
    FETCHH.............. >681C :     
    FEXIT............... >7A9A :     
    FFAHH............... >7736 :     
    FFAIH............... >7740 :     
    FFAIHM.............. >A01E :     
    FFAILM.............. >A01C :     
    FFALH............... >774C :     
    FFAML............... >7756 :     
    FFOPT............... >799A :     
    FGET................ >7E8C :     
    FGETH............... >7E84 :     
    FILE1............... >7E42 :     
    FILEH............... >7E3A :     
    FILL................ >6972 :     
    FILLH............... >696A :     
    FILLLP.............. >6606 :     
    FIND................ >6ADA :     
    FIND1............... >6AFA :     
    FIND2............... >6B16 :     
    FINDERR............. >72D0 :     
    FINDH............... >6AD2 :     
    FLERR............... >6894 :     
    FLEXIT.............. >688A :     
    FLGPTR.............. >A156 :     
    FLNEXT.............. >6824 :     
    FLNREC.............. >6856 :     
    FLOOR............... >6438 :     
    FLOOR1.............. >644A :     
    FLUSH............... >7C90 :     
    FLUSH1.............. >6816 :     
    FLUSH2.............. >6876 :     
    FLUSHH.............. >7C86 :     
    FLUSHX.............. >6814 :     
    FNDBLK.............. >6A18 :     
    FNDBUF.............. >6936 :     
    FNDNXT.............. >6AEE :     
    FNDVEC.............. >A006 :     
    FNEXT1.............. >657E :     
    FNXTOP.............. >797A :     
    FOEND............... >79F8 :     
    FOMASK.............. >79BE :     
    FOOPTS.............. >79D2 :     
    FOPEN1.............. >7E6A :     
    FOPENH.............. >7E60 :     
    FOR................. >6568 :     
    FORCNT.............. >A082 :     
    FORG1............... >7404 :     
    FORGET.............. >73EA :     
    FORGTH.............. >73E0 :     
    FORH................ >6560 :     
    FPUT................ >7E9C :     
    FPUTH............... >7E94 :     
    FREBUF.............. >69EA :     
    FREC................ >7EAC :     
    FRECH............... >7EA4 :     
    FREEH............... >699E :     
    FRMDSR.............. >6B20 :     
    FTCHPP.............. >6832 :     
    FVMBR............... >6904 :     
    FVMBW............... >6914 :     
    FWDREW.............. >0004 :     
    GABORT.............. >65F4 :     
    GCHAR............... >7984 :     
    GCHARH.............. >797A :     
    GENKEY.............. >72C2 :     
    GET2................ >65E8 :     
    GET4................ >65E0 :     
    GETI................ >678C :     
    GETIH............... >6786 :     
    GETJ................ >679E :     
    GETJH............... >6798 :     
    GETSTK.............. >166C :     
    GETWORD............. >72BA :     
    GEXIT............... >6252 :     
    GEXIT1.............. >6442 :     
    GEXIT2.............. >655C :     
    GHERE............... >77FE :     
    GKEYCX.............. >7328 :     
    GKNO................ >72E2 :     
    GLINK1.............. >7F12 :     
    GLNKWS.............. >2000 :     
    GMODE............... >794E :     
    GMODEH.............. >7944 :     
    GMODEX.............. >6222 :     
    GOTOXY.............. >6C82 :     
    GOXYH............... >6C78 :     
    GPLLNK.............. >7F08 :     
    GPLLOP.............. >7F1A :     
    GPLST............... >837C :     
    GPLVEC.............. >A00E :     
    GPLWS............... >83E0 :     
    GR4................. >83E8 :     
    GR6................. >83EC :     
    GRMRA............... >9802 :     
    GRMRD............... >9800 :     
    GRMWA............... >9C02 :     
    GRMWD............... >9C00 :     
    GT.................. >647A :     
    GTE................. >6496 :     
    GTEH................ >6490 :     
    GTEZ................ >653A :     
    GTEZH............... >6532 :     
    GTH................. >6474 :     
    GTZ................. >64F0 :     
    GTZH................ >64EA :     
    GXMAX............... >7796 :     
    GXMLAD.............. >7F0E :     
    H20................. >6B4E :     
    HAA................. >A178 :     
    HCHAR............... >7960 :     
    HCHARH.............. >7956 :     
    HDOTH............... >786A :     
    HDR0................ >6D14 :     
    HDR1................ >6D22 :     
    HEADER.............. >6F46 :     
    HEADR............... >6F50 :     
    HEADRH.............. >6F3C :     
    HELP................ >7775 :     
    HERE................ >A048 :     
    HEREH............... >76D6 :     
    HERE_............... >76DC :     
    HEX................. >77B4 :     
    HEXDOT.............. >7870 :     
    HEXH................ >77AC :     
    HFREE............... >6942 :     
    HFREEH.............. >6938 :     
    HHEREH.............. >77F6 :     
    HIDEME.............. >721C :     
    HIDH................ >7212 :     
    HIMEM............... >A2C8 :     
    HLINE............... >7614 :     
    HTIBH............... >7640 :     
    ICOMP............... >727A :     
    ICOMPH.............. >726C :     
    IERR................ >7356 :     
    IF.................. >658E :     
    IFCNT............... >A07E :     
    IFERR............... >7542 :     
    IFH................. >6588 :     
    IGLZ................ >6ED8 :     
    IMM................. >7232 :     
    IMMED............... >8000 :     
    IMMH................ >7224 :     
    IN.................. >A044 :     
    INCYC............... >7340 :     
    INH................. >76F4 :     
    INIT................ >7C32 :     
    INS1................ >73C0 :     
    INSOVR.............. >73AE :     
    INSTXT.............. >7721 :     
    INTERP.............. >72FE :     
    INTGO............... >730A :     
    INTH................ >72F0 :     
    INTLP............... >730C :     
    INTOUT.............. >73A6 :     
    INTVEC.............. >A000 :     
    INTXT............... >7599 :     
    INVH................ >67EA :     
    INVLOP.............. >7D06 :     
    INV_................ >67F2 :     
    IN_................. >76FC :     
    IOERR............... >6B40 :     
    IOERR1.............. >7786 :     
    IOERRH.............. >777C :     
    IS80C............... >769C :     
    ISDBL............... >A054 :     
    ISR................. >83C4 :     
    ISRDES.............. >6078 :     
    ISRNXT.............. >6082 :     
    ISROUT.............. >608A :     
    ISRXIT.............. >8354 :     
    ISSERR.............. >7200 :     
    ISSPCH.............. >66E6 :     
    JOYST............... >6D82 :     
    JOYSTH.............. >6D78 :     
    KDEL................ >A00A :     
    KDELH............... >75FC :     
    KDEL_............... >7604 :     
    KEEPN2.............. >63FE :     
    KEY................. >6DD0 :     
    KEYBD............... >7656 :     
    KEYCC............... >FF83 :     
    KEYCCR.............. >70BE :     
    KEYCD............... >FF84 :     
    KEYCD1.............. >702C :     
    KEYCDR.............. >7012 :     
    KEYCI............... >FF89 :     
    KEYCI1.............. >7086 :     
    KEYCI2.............. >70AA :     
    KEYCIR.............. >7068 :     
    KEYCO............... >FF8F :     
    KEYCOR.............. >6FE6 :     
    KEYCP............... >FF90 :     
    KEYCPR.............. >7000 :     
    KEYCV............... >FF96 :     
    KEYCVR.............. >70E0 :     
    KEYD................ >71FA :     
    KEYD1............... >7214 :     
    KEYD2............... >721C :     
    KEYDEV.............. >A024 :     
    KEYDX............... >7240 :     
    KEYE................ >7278 :     
    KEYEN1.............. >6FE0 :     
    KEYF1............... >0003 :     
    KEYF1R.............. >7110 :     
    KEYF1S.............. >713E :     
    KEYF2............... >0004 :     
    KEYF2R.............. >71EE :     
    KEYF3............... >0007 :     
    KEYF3R.............. >7182 :     
    KEYF4............... >0002 :     
    KEYF7............... >0001 :     
    KEYF7R.............. >71B4 :     
    KEYF9............... >000F :     
    KEYF9R.............. >7174 :     
    KEYFD............... >0009 :     
    KEYFE............... >000B :     
    KEYFEQ.............. >0005 :     
    KEYFQR.............. >71CE :     
    KEYFS............... >0008 :     
    KEYFX............... >000A :     
    KEYIN............... >8375 :     
    KEYQ................ >6E5C :     
    KEYQH............... >6E54 :     
    KEYQSR.............. >6E64 :     
    KEYRET.............. >000D :     
    KEYS................ >7242 :     
    KEYX................ >729E :     
    KMODE............... >770E :     
    KMODH............... >7704 :     
    KSCN................ >6DDC :     
    KSCN1............... >6DDE :     
    KSCN2............... >6E02 :     
    KSCNH............... >6DC8 :     
    L8000............... >6B38 :     
    LAGAIN.............. >673E :     
    LASTWD.............. >7F0E :     
    LATESH.............. >76C4 :     
    LATEST.............. >A046 :     
    LATES_.............. >76CE :     
    LBASE............... >A060 :     
    LBRACE.............. >7ED0 :     
    LBRACK.............. >7100 :     
    LBRAKH.............. >70FA :     
    LDGADD.............. >0060 :     
    LDVDPL.............. >61B8 :     
    LDVDPR.............. >61B0 :     
    LEAVE............... >677A :     
    LEAVEH.............. >6770 :     
    LFREE............... >695C :     
    LFREEH.............. >6952 :     
    LFT1................ >75B4 :     
    LFTLIN.............. >759C :     
    LHL................. >74B6 :     
    LHL1................ >74CC :     
    LINK................ >0000 :     
    LINNUM.............. >75B4 :     
    LIST1............... >7BCA :     
    LISTH............... >7BAE :     
    LIST_............... >7BB6 :     
    LIT................. >70B8 :     
    LIT0................ >6082 :     
    LIT1................ >608A :     
    LIT8................ >6092 :     
    LITERH.............. >70BA :     
    LITH................ >70B0 :     
    LITM1............... >609A :     
    LITRAL.............. >70C6 :     
    LMATCH.............. >6B00 :     
    LMISCL.............. >7CE4 :     
    LNKERR.............. >6B3E :     
    LNKSLN.............. >6A8C :     
    LNKSLP.............. >6A72 :     
    LOAD................ >7C10 :     
    LOAD5............... >7EBE :     
    LOAD5H.............. >7EB4 :     
    LOADH............... >7C08 :     
    LOADLP.............. >6718 :     
    LOCSPH.............. >79E8 :     
    LOCSPR.............. >79F4 :     
    LOGO................ >7EC8 :     
    LOMADJ.............. >6D62 :     
    LOOP................ >6730 :     
    LOOP1............... >670A :     
    LOOP1H.............. >6702 :     
    LOOP2............... >6718 :     
    LOOPCHK............. >6734 :     
    LOOPH............... >6726 :     
    LOOPX............... >6736 :     
    LOWCAS.............. >7DF8 :     
    LSFT................ >67FE :     
    LSFTH............... >67F8 :     
    LSTBLK.............. >A1B6 :     
    LSTXIT.............. >7BF8 :     
    LT.................. >6488 :     
    LTE................. >64A6 :     
    LTEH................ >64A0 :     
    LTEZ................ >6528 :     
    LTEZH............... >6520 :     
    LTH................. >6482 :     
    LTZ................. >64E2 :     
    LTZH................ >64DC :     
    LZI................. >A064 :     
    MAGFY............... >79BC :     
    MAGFYH.............. >79B0 :     
    MARK................ >654C :     
    MARKR............... >6F62 :     
    MARKRH.............. >6F58 :     
    MAX................. >640C :     
    MAXH................ >6404 :     
    MEMPTR.............. >7E2C :     
    MENU................ >600C :     
    MENU40.............. >6026 :     
    MIN................. >63F6 :     
    MINH................ >63EE :     
    MISS................ >6328 :     
    MKBLK............... >7D24 :     
    MKBLKC.............. >7D2C :     
    MKBLKH.............. >7D1A :     
    MKCLSE.............. >69C6 :     
    MKDERR.............. >69D2 :     
    MKDSKL.............. >6980 :     
    MOD................. >63C8 :     
    MODH................ >63C0 :     
    MODMAX.............. >73E0 :     
    MODTXT.............. >771C :     
    MPADJ............... >6D56 :     
    MTBUF............... >7CAA :     
    MTBUFH.............. >7C98 :     
    MTBUFL.............. >68BE :     
    MTEXT............... >602B :     
    MUL................. >6320 :     
    MUL2................ >62E8 :     
    MUL2H............... >62E2 :     
    MUL3................ >62EA :     
    MULH................ >631A :     
    NAMONE.............. >6AFE :     
    NAMPTR.............. >8356 :     
    NAMSTO.............. >A17A :     
    NAMTWO.............. >6B06 :     
    NBLK................ >7B62 :     
    NBLKH............... >7B5A :     
    NBUF................ >7614 :     
    NBUFH............... >760C :     
    NCOS................ >733A :     
    NCOS1............... >7352 :     
    NDIRT............... >68FC :     
    NDSH................ >6246 :     
    NEEDUD.............. >7674 :     
    NEG2................ >63DC :     
    NEGH................ >63D0 :     
    NEG_................ >63DA :     
    NEQ................. >64B6 :     
    NEQHH............... >64B0 :     
    NEQZ................ >64D4 :     
    NEQZH............... >64CC :     
    NEXIT............... >6CF6 :     
    NEXT................ >000C :     
    NEXT1K.............. >69AE :     
    NEXTH............... >6576 :     
    NFERR............... >749A :     
    NFTXT............... >758E :     
    NIMM................ >7344 :     
    NINN................ >6EC0 :     
    NIP................. >61D0 :     
    NIPH................ >61C8 :     
    NOBOOT.............. >73C0 :     
    NOBOOTM............. >7526 :     
    NOCODE.............. >738C :     
    NODBL............... >737C :     
    NODSR............... >6B3A :     
    NOIMM............... >6B46 :     
    NOKEY............... >FF00 :     
    NOMATCH............. >6B4A :     
    NOOFF............... >6AB8 :     
    NOPAST.............. >710E :     
    NOROM............... >6AB2 :     
    NOSCR............... >7628 :     
    NOSCRH.............. >761C :     
    NOSCRL.............. >A028 :     
    NOTFND.............. >7420 :     
    NOTICK.............. >72E4 :     
    NOWORD.............. >6BD6 :     
    NROT................ >61AA :     
    NROTH............... >61A2 :     
    NSPK................ >66AC :     
    NTS................. >788E :     
    NTS1................ >7896 :     
    NTSH................ >7886 :     
    NUM0................ >6C4C :     
    NUM1................ >6C76 :     
    NUM2................ >6C82 :     
    NUM3................ >6C8A :     
    NUM4................ >6C50 :     
    NUM5................ >6C5C :     
    NUMBER.............. >6B78 :     
    NUMBR1.............. >6B84 :     
    NUMBRH.............. >6B6E :     
    NUMEND.............. >6CEC :     
    NUMGO............... >6CD0 :     
    NUMISD.............. >6CCC :     
    NUMISL.............. >6CC6 :     
    NUMLZ............... >6C8E :     
    NUMT1............... >6CA8 :     
    NUMT2............... >6CB6 :     
    NUMVEC.............. >A004 :     
    NXTDAT.............. >7D2C :     
    NXTDIG.............. >6EC6 :     
    NXTFB............... >69F2 :     
    NXTREC.............. >69B2 :     
    NXTSLT.............. >79E4 :     
    OCHAR............... >7EFE :     
    OF.................. >6604 :     
    OFCNT............... >A086 :     
    OFERR............... >71CA :     
    OFH................. >65FE :     
    OFTXT............... >7561 :     
    OHSHIT.............. >6CC2 :     
    OK.................. >7362 :     
    OKTXT............... >6150 :     
    OKX................. >7364 :     
    ONCSR............... >6FBA :     
    OPEN................ >0000 :     
    OPT5................ >7EE2 :     
    OPTVEC.............. >A01A :     
    ORH................. >67CC :     
    OR_................. >67D2 :     
    OVER................ >61C6 :     
    OVERH............... >61BE :     
    OVR................. >73D6 :     
    OVRTXT.............. >7727 :     
    PABBUF.............. >A184 :     
    PABCC............... >A187 :     
    PABFIL.............. >A18C :     
    PABFLG.............. >A183 :     
    PABLOC.............. >1B78 :     
    PABLRL.............. >A186 :     
    PABNLN.............. >A18B :     
    PABOPC.............. >A182 :     
    PABREC.............. >A188 :     
    PABSCO.............. >A18A :     
    PAD................. >7766 :     
    PADEND.............. >7FF8 :     
    PADH................ >775E :     
    PADVEC.............. >A010 :     
    PADX................ >7776 :     
    PAE................. >6DE4 :     
    PANC................ >A038 :     
    PANEL............... >7A84 :     
    PANELH.............. >7A7A :     
    PANR................ >A036 :     
    PANXY............... >A034 :     
    PARSNM.............. >6C20 :     
    PATCH............... >A06C :     
    PC.................. >0003 :     
    PCREATE............. >A018 :     
    PDOCON.............. >A016 :     
    PICK................ >6210 :     
    PICKH............... >6208 :     
    PICKX............... >78F4 :     
    PITCH............... >0023 :     
    PLOOH1.............. >6742 :     
    PLOOP............... >676A :     
    PLOOP1.............. >674C :     
    PLOOPH.............. >675E :     
    PLUS1............... >62AC :     
    PLUS1H.............. >62A6 :     
    PLUS2............... >62C0 :     
    PLUS2H.............. >62BA :     
    PNEXT............... >A014 :     
    PRGTOP.............. >A2C8 :     
    PTOH................ >7080 :     
    PUSHER.............. >6D04 :     
    PWR................. >6E8A :     
    PWROUT.............. >6E9A :     
    QDUP................ >61FA :     
    QDUPX............... >6206 :     
    QUIT................ >6126 :     
    QUITH............... >611E :     
    QUITKY.............. >009D :     
    QUITLP.............. >6128 :     
    RBRACK.............. >710E :     
    RBRAKH.............. >7108 :     
    RDFER1.............. >74C2 :     
    RDFERR.............. >74AE :     
    RDFTXT.............. >7570 :     
    READ................ >0002 :     
    READSP.............. >66FE :     
    RECBUF.............. >1BA0 :     
    RECLN0.............. >7A8E :     
    RECRSH.............. >7286 :     
    RECURS.............. >7292 :     
    REFDN............... >67B4 :     
    REFILL.............. >0008 :     
    REFUP............... >67AC :     
    REM................. >6A6E :     
    REMH................ >6A68 :     
    REPEAT.............. >66BE :     
    REPETH.............. >66B4 :     
    REPXIT.............. >751A :     
    RET4TH.............. >717E :     
    RETB0............... >833A :     
    RETBNK.............. >A070 :     
    RETSTK.............. >A28C :     
    RL1................. >74E8 :     
    RLOOP............... >7572 :     
    RND................. >780E :     
    RNDH................ >7806 :     
    RNDX................ >6DD8 :     
    ROLL................ >622C :     
    ROLLH............... >6224 :     
    ROLLLP.............. >790C :     
    ROMSPK.............. >60FC :     
    ROMSPX.............. >6130 :     
    ROT................. >618E :     
    ROTH................ >6186 :     
    ROWNUM.............. >74DA :     
    ROWTXT.............. >7706 :     
    RPF................. >76AC :     
    RPFH................ >76A4 :     
    RRSTACK............. >6154 :     
    RS0................. >A022 :     
    RSC................. >6290 :     
    RSCH................ >628A :     
    RSFT................ >6810 :     
    RSFTH............... >680A :     
    RSPOP............... >629E :     
    RSPOPH.............. >6298 :     
    RSPSHH.............. >627C :     
    RSPUSH.............. >6282 :     
    RSRC................ >754A :     
    RSRC1............... >756E :     
    RSRC_............... >755A :     
    RSTACK.............. >0005 :     
    RSTSP............... >6B50 :     
    RSTSP1.............. >6B58 :     
    RSTSP3.............. >6B64 :     
    RT1................. >75DC :     
    RT2................. >75E6 :     
    RT4TH............... >6FF6 :     
    RTDATA.............. >7AF8 :     
    RTDATH.............. >7AEE :     
    RTLIN............... >75BE :     
    RTNAD............... >7F0C :     
    RU80C............... >7454 :     
    RUNISR.............. >834C :     
    S0.................. >A020 :     
    S0H................. >779E :     
    S0_................. >77A4 :     
    S32COL.............. >61A6 :     
    S40COL.............. >61A0 :     
    S80COL.............. >61AC :     
    SAL................. >A08A :     
    SAMS................ >7C62 :     
    SAMSH............... >6928 :     
    SAMS_............... >6930 :     
    SAV8A............... >A14A :     
    SAVCRU.............. >A14C :     
    SAVE5H.............. >7ECE :     
    SAVENT.............. >A14E :     
    SAVKEY.............. >A02A :     
    SAVLEN.............. >A150 :     
    SAVPAB.............. >A152 :     
    SAVVER.............. >A154 :     
    SAY................. >7AA8 :     
    SAYH................ >7AA0 :     
    SAYXIT.............. >66C6 :     
    SCLUP_.............. >6EBA :     
    SCNBLK.............. >6A02 :     
    SCNKEY.............. >762C :     
    SCNKY1.............. >764C :     
    SCNNXT.............. >6A0A :     
    SCREEN.............. >7A60 :     
    SCRLNO.............. >6F0E :     
    SCRLUP.............. >6EA2 :     
    SCRLUT.............. >6480 :     
    SCRNH............... >7A56 :     
    SCROLH.............. >7A68 :     
    SCROLL.............. >7A72 :     
    SCRX................ >A02A :     
    SCRY................ >A02C :     
    SDELIM.............. >A052 :     
    SDIV................ >63B8 :     
    SDIV1............... >641E :     
    SDIV2............... >642A :     
    SDIV3............... >642E :     
    SDIVH............... >63B2 :     
    SEED................ >A078 :     
    SEMI................ >718C :     
    SEMI2............... >71F0 :     
    SEMI3............... >71FC :     
    SEMIH............... >7186 :     
    SENS................ >7638 :     
    SENSH............... >7630 :     
    SETBLH.............. >7D08 :     
    SETBLK.............. >7D12 :     
    SETW................ >785C :     
    SFALSE.............. >6548 :     
    SGET3............... >65D8 :     
    SGET4............... >65D6 :     
    SGET5............... >65D4 :     
    SGO................. >6ADC :     
    SGO2................ >6AE2 :     
    SIDIV............... >6414 :     
    SIGN................ >789C :     
    SIGNDO.............. >6444 :     
    SIMUL............... >644E :     
    SIMUL1.............. >6464 :     
    SKIPBS.............. >6A32 :     
    SKIPLD.............. >60FE :     
    SKIPUD.............. >769A :     
    SMLIST.............. >A10A :     
    SMLST............... >7A18 :     
    SMLSTH.............. >7A0E :     
    SMOD................ >6354 :     
    SMOD1............... >6362 :     
    SMODH............... >634C :     
    SNDXIT.............. >7C2E :     
    SOUND............... >7F06 :     
    SOUND1.............. >7BEC :     
    SOUNDH.............. >7EFC :     
    SOURCE.............. >A05A :     
    SPACE1.............. >6D32 :     
    SPACEH.............. >6D28 :     
    SPADDR.............. >6714 :     
    SPADR............... >A03E :     
    SPAN................ >7648 :     
    SPAN1............... >764E :     
    SPCES............... >6D4C :     
    SPCES1.............. >6D56 :     
    SPCESH.............. >6D42 :     
    SPCESX.............. >6D66 :     
    SPCHRD.............. >9000 :     
    SPCHWT.............. >9400 :     
    SPCHX............... >66FC :     
    SPCNT............... >A03C :     
    SPCSVC.............. >A040 :     
    SPDATA.............. >834A :     
    SPEECH.............. >607A :     
    SPF................. >768A :     
    SPFH................ >7682 :     
    SPKNG............... >7A98 :     
    SPKNGH.............. >7A8C :     
    SPKROM.............. >668C :     
    SPPATH.............. >79FC :     
    SPRCLH.............. >79C4 :     
    SPRCOL.............. >79CE :     
    SPREAD.............. >668A :     
    SPRITE.............. >79A8 :     
    SPRITH.............. >799E :     
    SPRLCH.............. >79D6 :     
    SPRLOC.............. >79E0 :     
    SPRMOV.............. >7A2A :     
    SPRMV1.............. >640C :     
    SPRMVH.............. >7A20 :     
    SPRPAT.............. >7A06 :     
    SPRTX............... >62DC :     
    SPS................. >7698 :     
    SPSH................ >7690 :     
    SPSTAT.............. >8340 :     
    SPSX................ >76A0 :     
    SPWORD.............. >72B2 :     
    SPYES............... >66F8 :     
    SROM................ >6AA8 :     
    SSFLAG.............. >668B :     
    SSLASH.............. >6322 :     
    SSM................. >6378 :     
    SSMH................ >636E :     
    STACK............... >0004 :     
    STACKS.............. >A256 :     
    STADD............... >6852 :     
    STADDH.............. >684C :     
    START40............. >6050 :     
    START80............. >605A :     
    STARTB0............. >606C :     
    STARTB1............. >606C :     
    STATE0.............. >7338 :     
    STATEH.............. >76B2 :     
    STATE_.............. >76BC :     
    STATUS.............. >0009 :     
    STB................. >6872 :     
    STBH................ >686C :     
    STKPNT.............. >8373 :     
    STKTXT.............. >759E :     
    STKUF............... >73CA :     
    STKUFH.............. >73C2 :     
    STKX................ >73DE :     
    STOR0H.............. >687E :     
    STOR0X.............. >688A :     
    STORE............... >6844 :     
    STORE0.............. >6884 :     
    STOREH.............. >683E :     
    STR................. >790E :     
    STRBUF.............. >A244 :     
    STRC1............... >6E18 :     
    STRCU............... >60F2 :     
    STRH................ >7906 :     
    STRING.............. >78F0 :     
    STRM................ >7ABA :     
    STRMH............... >7AB0 :     
    STRNB............... >60DC :     
    STRNG1.............. >78FE :     
    STRNGH.............. >78EA :     
    STRSP2.............. >60A4 :     
    STRSP3.............. >60C2 :     
    STRSPK.............. >608E :     
    STRUE............... >6544 :     
    STRXIT.............. >60F0 :     
    SUB................. >6318 :     
    SUB1................ >62B4 :     
    SUB1H............... >62AE :     
    SUB2................ >62E0 :     
    SUB2H............... >62DA :     
    SUBH................ >6312 :     
    SUMODE.............. >A07A :     
    SWAP................ >617A :     
    SWAPH............... >6172 :     
    SWPBH............... >6218 :     
    SWPB_............... >621E :     
    SYNTH............... >6100 :     
    SYNYES.............. >A042 :     
    TBODYH.............. >6C0A :     
    TEMP................ >A072 :     
    TEMP2............... >A074 :     
    TEMP3............... >A076 :     
    TERM1............... >60BC :     
    TESTLZ.............. >6EF2 :     
    TFNL................ >794A :     
    THEN................ >65A6 :     
    THENH............... >659E :     
    THRU................ >7B7C :     
    THRUH............... >7B74 :     
    THRULP.............. >7B86 :     
    TIB................. >3420 :     
    TIBADR.............. >A1D0 :     
    TIBH................ >7726 :     
    TIBSIZ.............. >A04C :     
    TIB_................ >772E :     
    TICK................ >7242 :     
    TICK2............... >7250 :     
    TICK2H.............. >724A :     
    TICKH............... >723A :     
    TLUT................ >6EF8 :     
    TOBODY.............. >6C14 :     
    TOH................. >703A :     
    TOHX................ >7050 :     
    TOOBIG.............. >6978 :     
    TOOSML.............. >6972 :     
    TORAM............... >7F6C :     
    TOTBLK.............. >A1B2 :     
    TOTERM.............. >60B4 :     
    TOUTIL.............. >7092 :     
    TRAIL............... >7924 :     
    TRAIL1.............. >6E00 :     
    TRAIL2.............. >6DF8 :     
    TRAILH.............. >7916 :     
    TRCOM............... >6A80 :     
    TRCOM1.............. >6C14 :     
    TRCOMH.............. >6A7A :     
    TRLOUT.............. >6DFE :     
    TRUE................ >77E0 :     
    TRUEH............... >77D8 :     
    TRUL1............... >744A :     
    TSTRH............... >792C :     
    TUCK................ >61DE :     
    TUCKH............... >61D6 :     
    TXT0................ >76A6 :     
    TXT1................ >76C5 :     
    TXT2................ >76E4 :     
    TYPCMH.............. >6A88 :     
    TYPE................ >6C96 :     
    TYPE1............... >6C98 :     
    TYPEH............... >6C8E :     
    TYPLP............... >6CA0 :     
    TYPOUT.............. >6CB0 :     
    TYPST1.............. >7940 :     
    TYPSTR.............. >7932 :     
    UDOT................ >781C :     
    UDOTH............... >7816 :     
    UDOTR............... >783E :     
    UDOTRH.............. >7836 :     
    ULESS............... >64FE :     
    ULESSH.............. >64F8 :     
    UMODH............... >6394 :     
    UMSH................ >6332 :     
    UNBAL............... >74A6 :     
    UNTIL............... >6678 :     
    UNTILH.............. >666E :     
    UPDATE.............. >7C7E :     
    UPDATH.............. >7C74 :     
    UPKEY............... >7356 :     
    USE................. >7B08 :     
    USE1................ >7B10 :     
    USEH................ >7B00 :     
    USEXIT.............. >677C :     
    USIGN............... >78A4 :     
    USIGND.............. >75F4 :     
    USIGNH.............. >75E8 :     
    USMOD............... >639E :     
    USRISR.............. >A008 :     
    VALUE............... >7034 :     
    VALUEH.............. >702A :     
    VAR................. >7020 :     
    VARH................ >7014 :     
    VBLNK............... >83D7 :     
    VCHAR............... >7972 :     
    VCHAR1.............. >6268 :     
    VCHAR2.............. >6274 :     
    VCHARH.............. >7968 :     
    VDPA................ >8C02 :     
    VDPFH............... >6898 :     
    VDPFTC.............. >689E :     
    VDPM................ >691A :     
    VDPR................ >8800 :     
    VDPR1............... >A06E :     
    VDPRW............... >68DA :     
    VDPRWH.............. >68D2 :     
    VDPST............... >8802 :     
    VDPSTR.............. >68B2 :     
    VDPW................ >8C00 :     
    VDPWH............... >68AC :     
    VDPWW............... >7D50 :     
    VDPWWH.............. >68C0 :     
    VDPX................ >6926 :     
    VFIND............... >6AE6 :     
    VLINE............... >7600 :     
    VLINE1.............. >7606 :     
    VMBR................ >7F86 :     
    VMBR1............... >7F96 :     
    VMBRH............... >68FC :     
    VMBW................ >7FC6 :     
    VMBW0............... >7FD4 :     
    VMBW1............... >7FE8 :     
    VMBWH............... >690C :     
    VREAD............... >6BF2 :     
    VREAD1.............. >6BF4 :     
    VREAD2.............. >6BF8 :     
    VSBR................ >7F64 :     
    VSBW................ >7F9E :     
    VSBW0............... >7FAC :     
    VSBWMI.............. >78B2 :     
    VWTRF............... >68F4 :     
    VWTRFH.............. >68EC :     
    WARN................ >771E :     
    WARNH............... >7716 :     
    WFNLB............... >795A :     
    WFTXT............... >6D08 :     
    WHEAD............... >7D34 :     
    WHERE............... >7B22 :     
    WHERE1.............. >7B42 :     
    WHEREH.............. >7B18 :     
    WHILE............... >66AC :     
    WHILEH.............. >66A2 :     
    WITHH............... >6506 :     
    WITHIN.............. >6510 :     
    WKSPC............... >8300 :     
    WORD................ >6AA4 :     
    WORD0............... >6AAA :     
    WORD1............... >6ABC :     
    WORD2............... >6AB8 :     
    WORDH............... >6A9C :     
    WORDS1.............. >6CC4 :     
    WORDS2.............. >6CFC :     
    WORDS3.............. >6CE2 :     
    WORDS4.............. >6CE4 :     
    WORDSH.............. >6CB2 :     
    WORDS_.............. >6CBC :     
    WP.................. >A012 :     
    WRAP................ >A032 :     
    WRAPH............... >7660 :     
    WRAP_............... >7668 :     
    WRD1................ >6BA0 :     
    WRD2................ >6BB4 :     
    WRDBUF.............. >A1D2 :     
    WRDFIN.............. >6BD2 :     
    WRDGB............... >6BE8 :     
    WRDXIT1............. >6BDE :     
    WRDXIT2............. >6BE4 :     
    WRITE............... >0003 :     
    WRKBUF.............. >A224 :     
    WSTR................ >7620 :     
    XMAX................ >A02E :     
    XMAXH............... >778E :     
    XMLRTN.............. >7F44 :     
    XORH................ >67D8 :     
    XOR_................ >67E0 :     
    XTAB27.............. >200E :     
    XTHRU............... >7B8E :     
    XUGLY............... >6C44 :     
    XY.................. >6D18 :     
    XYA................. >75EE :     
    XYH................. >6D10 :     
    YMAX................ >A030 :     
    ZBQ................. >7FF4 :     
    ZBRCHH.............. >65DC :     
    ZBRNCH.............. >65E8 :     
    ZCHARS.............. >6A60 :     
    ZEROCHR............. >7EF5 :     
    ZEROS............... >767A :     
    ZEROSH.............. >7670 :     
    _ADD................ >83A2 :     
    _ALIGN.............. >6D7A :     
    _ALLOT.............. >6DA8 :     
    _BIT0............... >78E6 :     
    _BIT1............... >78E8 :     
    _BLKQ............... >6900 :     
    _BLOCK.............. >6780 :     
    _BUF................ >6914 :     
    _CA1................ >7BC2 :     
    _CART............... >7BE0 :     
    _CBOOT.............. >7F50 :     
    _CFA................ >6BF6 :     
    _CLALL.............. >7BBE :     
    _CLEAN.............. >68D2 :     
    _CLS................ >6134 :     
    _CMOVE.............. >660E :     
    _CMOVF.............. >661E :     
    _COINC.............. >62E0 :     
    _COLOR.............. >642C :     
    _COMAB.............. >6D6A :     
    _COMMA.............. >6D4C :     
    _COMPIL............. >6DB2 :     
    _COPYW.............. >663C :     
    _COUNT.............. >6DDC :     
    _DATA............... >6738 :     
    _DCHAR.............. >6292 :     
    _DEPTH.............. >791A :     
    _DIRTY.............. >68DE :     
    _DNOUT.............. >65B4 :     
    _DOWN............... >6560 :     
    _DOWN0.............. >6578 :     
    _DOWN1.............. >6598 :     
    _DOWN2.............. >65AA :     
    _DROP............... >838A :     
    _DUP................ >8382 :     
    _DUP2............... >6B6C :     
    _EDIT............... >6F1C :     
    _EDIT1.............. >6F30 :     
    _EDIT4.............. >6F3A :     
    _FCFND.............. >7A62 :     
    _FCLOP.............. >7A50 :     
    _FCLOS.............. >7A42 :     
    _FCXIT.............. >7A60 :     
    _FEOF............... >7B2E :     
    _FGERR.............. >7A92 :     
    _FGET............... >7A66 :     
    _FGXIT.............. >7A90 :     
    _FICLL.............. >7936 :     
    _FILE............... >792C :     
    _FILL............... >65FC :     
    _FLUSH.............. >6810 :     
    _FOERR.............. >7A38 :     
    _FOPEN.............. >79DC :     
    _FP1................ >7AD2 :     
    _FP2................ >7AE6 :     
    _FPERR.............. >7AF4 :     
    _FPUT............... >7AA2 :     
    _FPVDP.............. >7AFA :     
    _FPXIT.............. >7AF2 :     
    _FREC............... >7B14 :     
    _GCHAR.............. >627A :     
    _GMODE.............. >618C :     
    _HCHAR.............. >624A :     
    _HEADR.............. >6D0E :     
    _HIDE............... >6D8A :     
    _IMM................ >6D98 :     
    _JOYST.............. >6154 :     
    _LEFT............... >6488 :     
    _LEFT1.............. >64AA :     
    _LIT................ >8368 :     
    _LWRAP.............. >64A4 :     
    _MAGFY.............. >632C :     
    _MKBLK.............. >6952 :     
    _MTBUF.............. >68B6 :     
    _MUL................ >83AA :     
    _NEXT............... >8326 :     
    _NTS................ >6E66 :     
    _NUMBR.............. >6C1C :     
    _OPT5............... >7B4C :     
    _OVER............... >838E :     
    _PANEL.............. >65BA :     
    _PICK............... >78EA :     
    _PLUS1.............. >8396 :     
    _PLUS2.............. >839A :     
    _QDIRT.............. >68EA :     
    _RIGHT.............. >64C6 :     
    _RIGHT1............. >64EC :     
    _RND................ >6DBE :     
    _ROLL............... >78F8 :     
    _RWRAP.............. >64E6 :     
    _SAMS............... >664C :     
    _SAY................ >66B0 :     
    _SCREN.............. >6446 :     
    _SCROL.............. >6458 :     
    _SETBK.............. >6942 :     
    _SMLST.............. >63DC :     
    _SPACE.............. >6D0C :     
    _SPAN............... >A04E :     
    _SPCOL.............. >6356 :     
    _SPGET.............. >639C :     
    _SPKNG.............. >668E :     
    _SPLOC.............. >6374 :     
    _SPMOV.............. >63F2 :     
    _SPPAT.............. >63BE :     
    _SPRIT.............. >62AE :     
    _STATE.............. >A04A :     
    _STR................ >6E4C :     
    _STREM.............. >66CA :     
    _STRI1.............. >6E24 :     
    _STRI2.............. >6E3A :     
    _STRIN.............. >6E08 :     
    _SUB................ >83A6 :     
    _SUB2............... >839E :     
    _SWAP............... >835C :     
    _TRAIL.............. >6DEA :     
    _TRCOM.............. >6BFC :     
    _UP................. >650C :     
    _UP0................ >651C :     
    _UP1................ >651E :     
    _UP2................ >653E :     
    _UP3................ >654E :     
    _UPDAT.............. >68A2 :     
    _UPOUT.............. >6558 :     
    _USE................ >674C :     
    _USE3............... >675A :     
    _VCHAR.............. >6256 :     
    _VMBR............... >7838 :     
    _VMBR1.............. >7846 :     
    _VMBR2.............. >7830 :     
    _VMBRI.............. >782A :     
    _VMBW............... >7878 :     
    _VMBW0.............. >7886 :     
    _VMBW1.............. >7896 :     
    _VMBW2.............. >787E :     
    _VMBWX.............. >78A2 :     
    _VSBM1.............. >78C2 :     
    _VSBR............... >7816 :     
    _VSBW............... >7850 :     
    _VSBW0.............. >785E :     
    _VSBWM.............. >78A4 :     
    _VSBWM2............. >78AA :     
    _VWTR............... >78D0 :     
    _VWTRF.............. >6676 :     
    _WARN............... >A068 :     
    _WORD............... >6B7C :     
    _ZBRNCH............. >83B4 :     
    __DUP............... >7FBA :     
